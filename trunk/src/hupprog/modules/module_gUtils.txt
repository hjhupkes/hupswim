Option Compare Database
Option Explicit



Private Const PING_SOCKET_ERROR = 0
Private Const PING_MAX_IP = 10

Private Type PING_WSADATA
  wVersion As Integer
  wHighVersion As Integer
  szDescription(0 To 255) As Byte
  szSystemStatus(0 To 128) As Byte
  iMaxSockets As Integer
  iMaxUdpDg As Integer
  lpVendorInfo As Long
End Type

Private Type PING_HOSTENT
  h_name As Long
  h_aliases As Long
  h_addrtype As Integer
  h_length As Integer
  h_addr_list As Long
End Type

Private Type PING_IP_OPTION_INFORMATION
    bTTL As Byte
    bTos As Byte
    bFlags As Byte
    lOptionsSize As Long
    sOptionsData As String * 128
End Type

Private Type PING_IP_ECHO_REPLY
    bAddress(0 To 3) As Byte
    lStatus As Long
    lRoundTripTime As Long
    iDataSize As Integer
    iReserved As Integer
    lData As Long
    lpOptions As PING_IP_OPTION_INFORMATION
End Type

Private Declare Function pingGetHostByName Lib "wsock32.dll" Alias "gethostbyname" (ByVal sHostName As String) As Long
Private Declare Function pingWSAStartup Lib "wsock32.dll" Alias "WSAStartup" (ByVal wVersionRequired&, lpWSAdata As PING_WSADATA) As Long
Private Declare Function pingWSACleanup Lib "wsock32.dll" Alias "WSACleanup" () As Long
Private Declare Sub pingCopyMemory Lib "kernel32" Alias "RtlMoveMemory" (hpvDest As Any, hpvSource As Any, ByVal cbCopy As Long)
Private Declare Function pingIcmpCreateFile Lib "icmp.dll" Alias "IcmpCreateFile" () As Long
Private Declare Function pingIcmpCloseHandle Lib "icmp.dll" Alias "IcmpCloseHandle" (ByVal hHandle As Long) As Boolean
Private Declare Function pingIcmpSendEcho Lib "icmp.dll" Alias "IcmpSendEcho" (ByVal IcmpHandle As Long, ByVal DestAddress As Long, _
  ByVal RequestData As String, ByVal RequestSize As Integer, RequestOptns As PING_IP_OPTION_INFORMATION, _
  ReplyBuffer As PING_IP_ECHO_REPLY, ByVal ReplySize As Long, ByVal Timeout As Long) As Boolean




Declare Function GetDirNaam Lib "hupswim.dll" Alias "#1" (ByVal dir As String) As Integer
Declare Function GetPictureNaam Lib "huptel.dll" Alias "#4" (ByRef picture As T_Picture) As Integer
Declare Function GetFileName Lib "huptel.dll" Alias "#5" (ByRef file As T_OpenSaveGegevens) As Integer


Declare Function countZip Lib "hupswim.dll" Alias "#2" (ByVal zipFName As String) As Integer
Declare Function unzipAll Lib "hupswim.dll" Alias "#3" (ByVal zipFName As String, ByVal unpackDir As String) As Boolean
Declare Function unzipFile Lib "hupswim.dll" Alias "#4" (ByVal zipFName As String, ByVal unpackDir As String, ByVal fName As String) As Boolean

Declare Function zipFile Lib "hupswim.dll" Alias "#5" (ByVal zipFName As String, ByVal fName As String) As Boolean

Private Declare Function mshStopMouseWheel Lib "hupswim_mouse.dll" Alias "StopMouseWheel" (ByVal hWnd As Long, ByVal lAccessThreadID As Long, Optional ByVal blIsGlobal As Boolean = False) As Boolean
Private Declare Function mshStartMouseWheel Lib "hupswim_mouse.dll" Alias "StartMouseWheel" (ByVal hWnd As Long) As Boolean
Private Declare Function wklGetCurrentThreadId Lib "kernel32" Alias "GetCurrentThreadId" () As Long
Private Declare Function wklLoadLibrary Lib "kernel32" Alias "LoadLibraryA" (ByVal lpLibFileName As String) As Long
Private Declare Function wklFreeLibrary Lib "kernel32" Alias "FreeLibrary" (ByVal hLibModule As Long) As Long




Global Const FILE_DLG_OPEN As Integer = 0
Global Const FILE_DLG_SAVE As Integer = 1

Type T_OpenSaveGegevens
  gegevens(0 To 767) As Byte
End Type

Type T_Picture
    gegevens(0 To 512) As Byte
End Type



Public Sub appDisableMouseWheel(ByVal blSuppErrMsg As Boolean)
On Error GoTo fout

Dim hLib As Long
hLib = 0


hLib = wklLoadLibrary(extractFilePath(CurrentDb().name) & "\hupswim_mouse.dll")
If hLib = 0 Then
  Err.Raise 1, , "Could not load: hupswim_mouse.dll"
End If



Dim lAccessThreadID As Long
' Get the ID for this thread
lAccessThreadID = wklGetCurrentThreadId()

Dim blGlobal As Boolean
blGlobal = False

On Error Resume Next
'This calling dll-calling convention error for some reason; just ignore
mshStopMouseWheel Application.hWndAccessApp, lAccessThreadID, blGlobal

On Error GoTo fout

If (hLib <> 0) Then
  wklFreeLibrary hLib
End If

Exit Sub

fout:
Dim errInf As ERR_INFO
appRecordError "appDisableMouseWheel", errInf

If (hLib <> 0) Then
  wklFreeLibrary hLib
End If

If Not blSuppErrMsg Then
  appDisplayError errInf
End If
Exit Sub

End Sub





Public Sub appCleanRS(ByRef rs As Recordset)
On Error Resume Next

If Not rs Is Nothing Then
  rs.Close
  Set rs = Nothing
End If

End Sub

Public Sub appCleanDB(ByRef db As Database)
On Error Resume Next

If Not db Is Nothing Then
  db.Close
  Set db = Nothing
End If

End Sub


Public Function changeProperty(strPropName As String, varPropType As Variant, varPropValue As Variant) As Boolean
On Error GoTo fout

changeProperty = False

Dim dbs As Database, prp As Property

Const conPropNotFoundError = 3270

Set dbs = CurrentDb
    
dbs.Properties(strPropName) = varPropValue
    
changeProperty = True

Exit Function

fout:
If Err = conPropNotFoundError Then  ' Property not found.
  Set prp = dbs.CreateProperty(strPropName, varPropType, varPropValue)
  dbs.Properties.Append prp
  Resume Next
Else
  MsgBox Err & " changeProperty" & vbCrLf & Error$, 16
  Exit Function
End If
End Function



Public Function tableExists(tableName As String) As Boolean
On Error GoTo fout
Dim db As Database
Dim tbl As TableDef
Set db = CurrentDb()
Set tbl = db.TableDefs(tableName)
tableExists = True
Exit Function
fout:
tableExists = False
Exit Function
End Function

Public Function fieldExistsInTD(ByRef tbDef As TableDef, fName As String) As Boolean
On Error GoTo fout
fieldExistsInTD = False
Dim fld As Field
Set fld = tbDef.Fields(fName)
fieldExistsInTD = True
Exit Function
fout:
Exit Function
End Function




Public Function extractFilePath(ByVal fName As String) As String
On Error Resume Next
Dim path As String, file As String
fileNameSplit fName, path, file

extractFilePath = path

End Function

Public Function extractFileName(ByVal fName As String) As String
On Error Resume Next
Dim path As String, file As String
fileNameSplit fName, path, file

extractFileName = file

End Function

Private Sub fileNameSplit(ByVal fName As String, ByRef dir As String, ByRef file As String)
On Error Resume Next
dir = ""
file = fName

Dim curPos As Long
curPos = Len(fName)
Dim curChar As String
Do Until curPos <= 0
  curChar = Mid(fName, curPos, 1)
  If (curChar = "\") Then
    dir = Left(fName, curPos - 1)
    file = Right(fName, Len(fName) - curPos)
    Exit Sub
  End If
  
  curPos = curPos - 1
Loop

Exit Sub


End Sub

Public Function DirectoryExists(sDirName As String) As Boolean
On Error Resume Next
If (sDirName = "") Then
  DirectoryExists = False
  Exit Function
End If
If dir(directory_goedmaak(sDirName), vbDirectory) = "" Then
  DirectoryExists = False
Else
  DirectoryExists = True
End If
End Function

Public Function FileExists(sFileName As String) As Boolean
On Error Resume Next
If (sFileName = "") Then
  FileExists = False
  Exit Function
End If
If dir(sFileName) = "" Then
  FileExists = False
Else
  FileExists = True
End If
End Function

Public Function FileDateStr(sFileName As String) As String
On Error Resume Next
FileDateStr = Format(Nz(FileDateTime(sFileName), #1/1/1900#), "dd\-mm\-yyyy")
End Function
Public Function FileTimeStr(sFileName As String) As String
On Error Resume Next
FileTimeStr = Format(Nz(FileDateTime(sFileName), #1/1/1900#), "hh\:nn")
End Function

Public Function directory_goedmaak(ByVal directory As String) As String
On Error Resume Next
directory = Trim(directory)
If Right(directory, 1) = "\" Then
    directory_goedmaak = Left(directory, Len(directory) - 1)
Else
    directory_goedmaak = directory
End If
End Function



Public Function fileNamePromptUser(ByVal mode As Integer, ByRef dlgTitle As String, filter As String, ByRef fName As String, Optional blUseCurFName As Boolean = False, Optional forceFileNameOnError As Boolean = True) As Boolean
On Error GoTo fout

fileNamePromptUser = False


Dim tpFile As T_OpenSaveGegevens
Dim i As Integer

tpFile.gegevens(0) = CByte(mode)


For i = 1 To Len(dlgTitle) - 1
  tpFile.gegevens(i) = CByte(Asc(Mid(dlgTitle, i, 1)))
Next i
tpFile.gegevens(i) = 0



If Not blUseCurFName Then
  For i = 256 To 512
    tpFile.gegevens(i) = 0
  Next i
Else
  For i = 256 To (Len(fName) - 1) + 256
    tpFile.gegevens(i) = CByte(Asc(Mid(fName, (i - 256) + 1, 1)))
  Next i
  tpFile.gegevens(i) = 0
End If

For i = 512 To Len(filter) - 1 + 512
  tpFile.gegevens(i) = CByte(Asc(Mid(filter, (i - 512) + 1, 1)))
Next i
tpFile.gegevens(i) = 0



Dim intResult
intResult = GetFileName(tpFile)

If intResult = 1 Then
  Dim sNewName As String
  sNewName = ""
    
  For i = 0 To 257
    If tpFile.gegevens(i) = 0 Then
      Exit For
    End If
    sNewName = sNewName & Chr(tpFile.gegevens(i))
  Next i
  fName = sNewName
Else
  Exit Function
End If

fileNamePromptUser = True

Exit Function

fout:

If (Err = 53) Then
  MsgBox "De dll files hupswim.dll en/of huptel.dll konden niet gevonden worden in c:\windows\system. Ga naar " & _
  "http://home.kpn.nl/wimhupke/hupsoft/downl.htm (onderaan) voor instructies om ze te downloaden.", 16
Else
  MsgBox Err & " fileNamePromptUser" & vbCrLf & Error$
End If

If forceFileNameOnError Then
  On Error Resume Next
  fName = InputBox("Voer bestandsnaam in:", "Fout tijdens openen dialoogvenster voor ophalen bestandsnaam.")
  If (Len(fName) > 0) Then
    fileNamePromptUser = True
  End If
End If

Exit Function

End Function






Public Function fileNamePicturePromptUser(ByRef fName As String, Optional blUseCurName As Boolean = False, Optional forceFileNameOnError As Boolean = True) As Boolean
On Error GoTo fout

fileNamePicturePromptUser = False

Dim tpPicture As T_Picture
Dim i As Integer

Dim dlgName As String

dlgName = "Hupswim"

For i = 0 To Len(dlgName) - 1
  tpPicture.gegevens(i) = CByte(Asc(Mid(dlgName, i + 1, 1)))
Next i
tpPicture.gegevens(i) = 0



If Not blUseCurName Then
  For i = 256 To 512
    tpPicture.gegevens(i) = 0
  Next i
Else
  For i = 256 To (Len(fName) - 1) + 256
    tpPicture.gegevens(i) = CByte(Asc(Mid(fName, (i - 256) + 1, 1)))
  Next i
  tpPicture.gegevens(i) = 0
End If



Dim intResult
intResult = GetPictureNaam(tpPicture)

If intResult = 1 Then
  Dim sNewName As String
  sNewName = ""
    
  For i = 0 To 257
    If tpPicture.gegevens(i) = 0 Then
      Exit For
    End If
    
    sNewName = sNewName & Chr(tpPicture.gegevens(i))
  Next i
  fName = sNewName
Else
  Exit Function
End If



fileNamePicturePromptUser = True


Exit Function

fout:

If (Err = 53) Then
  MsgBox "De dll files hupswim.dll en/of huptel.dll konden niet gevonden worden in c:\windows\system. Ga naar " & _
  "http://home.kpn.nl/wimhupke/hupsoft/downl.htm (onderaan) voor instructies om ze te downloaden.", 16
Else
  MsgBox Err & " fileNamePicturePromptUser" & vbCrLf & Error$
End If

If forceFileNameOnError Then
  On Error Resume Next
   
  fName = InputBox("Voer bestandsnaam in:", "Fout tijdens openen dialoogvenster voor ophalen bestandsnaam.")
  If (Len(fName) > 0) Then
    fileNamePicturePromptUser = True
  End If
End If

Exit Function





End Function



Public Function GetDir() As String
On Error Resume Next
Dim a
Dim dirName As String
dirName = String(255, 0)
Dim sNewName As String

    GetDirNaam (dirName)

sNewName = CStr(dirName)
Dim pos As Long
pos = InStr(1, sNewName, Chr(0)) - 1
sNewName = Left(sNewName, pos)
GetDir = sNewName

End Function

Function goed_naam(x As String) As String
On Error GoTo fout
Dim y, z, u As String
y = Left(x, 1)
z = IIf(Len(x) = 1, "", Right(Left(x, 2), 1))
u = IIf(Len(x) <= 2, "", Right(x, 1))
If y = "." Or y = "/" Or y = "\" Or y = "[" Or y = "]" Or y = ":" Or y = ";" Or y = "|" Or y = "=" Or y = "," Or y = " " Then
         y = "_"
End If
If z = "." Or z = "/" Or z = "\" Or z = "[" Or z = "]" Or z = ":" Or z = ";" Or z = "|" Or z = "=" Or z = "," Or z = " " Then
         z = "_"
End If
If u = "." Or u = "/" Or u = "\" Or u = "[" Or u = "]" Or u = ":" Or u = ";" Or u = "|" Or u = "=" Or u = "," Or u = " " Then
         u = "_"
End If

goed_naam = y & z & u
Exit Function
fout:
goed_naam = "___"
Exit Function

End Function



Public Function fltExtractFieldNames(geg As Recordset) As Boolean
'Deze functie haalt de veldnamen uit een zekere recordset en voegt deze toe in een nieuwe tabel.
On Error GoTo fout

DoCmd.DeleteObject acTable, "~FLTFieldNames"
DoCmd.DeleteObject acTable, "~FLTData"

Dim mydb As Database, tbl As TableDef, tbl2 As TableDef
Set mydb = CurrentDb()
Set tbl = mydb.CreateTableDef("~FLTFieldNames")
Set tbl2 = mydb.CreateTableDef("~FLTData")

tbl.Fields.Append tbl.CreateField("FieldName", dbText, 100)
tbl.Fields.Append tbl.CreateField("FieldType", dbInteger)

tbl2.Fields.Append tbl2.CreateField("FieldName", dbText, 100)
tbl2.Fields.Append tbl2.CreateField("FieldType", dbInteger)
tbl2.Fields.Append tbl2.CreateField("Nr", dbInteger)
tbl2.Fields.Append tbl2.CreateField("OrderBy", dbInteger)
tbl2.Fields.Append tbl2.CreateField("Criteria", dbText, 255)
mydb.TableDefs.Append tbl
mydb.TableDefs.Append tbl2

'Nieuwe tabel gemaakt.

Dim uitv As Recordset
Set uitv = mydb.OpenRecordset("~FLTFieldNames", dbOpenDynaset)

Dim fld As Field
For Each fld In geg.Fields
  uitv.AddNew
  uitv("FieldName") = fld.name
  uitv("FieldType") = fld.type
  uitv.Update
Next fld

fltExtractFieldNames = True
Exit Function
fout:

If Err = 3011 Or Err = 7874 Then 'could not find object to delete
  Resume Next
End If

MsgBox Err & " fltExtractFieldName" & vbCrLf & Error$, 16
Exit Function






End Function





Function hzn(s)
If IsNull(s) Or Nz(s, "") = "" Then
 hzn = Null
Else
 hzn = s
End If
End Function



Public Function GoedTekens(s As String) As String
On Error GoTo fout
Dim i As Integer
Dim tpS As String
tpS = ""
Dim y
For i = 1 To Len(s)
  y = Mid(s, i, 1)
  If y = "." Or y = "/" Or y = "\" Or y = "[" Or y = "]" Or y = ":" Or y = ";" Or y = "|" Or y = "=" Or y = "," Or y = " " Or y = "?" Or y = "<" Or y = ">" Or y = "*" Or y = "#" Then
    y = "_"
  End If
  tpS = tpS & y
Next i

GoedTekens = tpS
Exit Function
fout:
GoedTekens = "_"
Exit Function
End Function


Public Function selGetNewStatus(blCurSel As Boolean, blIsValid As Boolean, blSelOverwrite As Boolean, blSelExtend As Boolean, blSelRestrict As Boolean, blUseValid As Boolean) As Boolean
On Error GoTo fout

'Vervelende logica...
If (blSelOverwrite) Then
  If (blUseValid) Then
    selGetNewStatus = blIsValid
  Else
    selGetNewStatus = Not blIsValid
  End If
ElseIf (blSelExtend) Then
  If (blCurSel) Then
    selGetNewStatus = True
  ElseIf (blUseValid) Then
    selGetNewStatus = blIsValid
  Else
    selGetNewStatus = Not blIsValid
  End If
ElseIf (blSelRestrict) Then
  If (Not blCurSel) Then
    selGetNewStatus = False
  ElseIf (blUseValid) Then
    selGetNewStatus = blIsValid
  Else
    selGetNewStatus = Not blIsValid
  End If
End If



Exit Function
fout:
MsgBox Err & " " & Error$, 16
Exit Function
End Function



Public Function lenDateIsValid(dt As Date) As Boolean
On Error Resume Next
lenDateIsValid = False
Dim yr As Double
yr = val(Format(dt, "yyyy"))
If (yr > 1900 And yr < 2098) Then
  lenDateIsValid = True
End If

End Function



Public Function strEditDistance(ByVal sA As String, ByVal sB As String) As Integer
On Error Resume Next
strEditDistance = -1

Dim iLenA As Integer, iLenB As Integer
iLenA = Len(sA)
iLenB = Len(sB)


If (Len(sA) > 300) Or (Len(sB) > 300) Then
  Exit Function
End If

Dim curDist(0 To 300) As Integer
Dim newDist(0 To 300) As Integer


Dim i As Integer, j As Integer

'Initialisation
For i = 0 To iLenA
  curDist(i) = i
Next i

For j = 1 To iLenB
  newDist(0) = j
  For i = 1 To iLenA
    Dim cIns As Integer, cDel As Integer, cSub As Integer
    cDel = newDist(i - 1) + 1   'delete last letter, and then turn 1..i-1 into 1..j
    cIns = curDist(i) + 1   'turn 1..i into 1..j-1 and add letter j
    cSub = curDist(i - 1) + IIf(Mid(sA, i, 1) = Mid(sB, j, 1), 0, 1) 'turn 1..i-1 into 1..j-1 and substitute sA[i] into sB[j]
    newDist(i) = cDel
    If (cIns < newDist(i)) Then
      newDist(i) = cIns
    End If
    If (cSub < newDist(i)) Then
      newDist(i) = cSub
    End If
  Next i
  
  For i = 0 To iLenA
   curDist(i) = newDist(i)
  Next i
Next j

strEditDistance = curDist(iLenA)

End Function


'Fast wrapper for directoryExists(). If sPath is non-local, the server is first pinged to see if it actually exists on the network
'This is to prevent long delays waiting for directoryExists() to fail.
Public Function lanDirectoryExists(sPath As String, ByVal lTimeOut As Long) As Boolean
On Error Resume Next

lanDirectoryExists = False

If lanTestServerAvailability(sPath, lTimeOut) Then
  lanDirectoryExists = DirectoryExists(sPath)
End If

End Function

'Fast wrapper for fileExists(). If sPath is non-local, the server is first pinged to see if it actually exists on the network
'This is to prevent long delays waiting for fileExists() to fail.
Public Function lanFileExists(sFileName As String, ByVal lTimeOut) As Boolean
On Error Resume Next

lanFileExists = False

If lanTestServerAvailability(sFileName, lTimeOut) Then
  lanFileExists = FileExists(sFileName)
End If

End Function

Public Function lanTestServerAvailability(sPath As String, ByVal lTimeOut As Long) As Boolean

lanTestServerAvailability = False

If (Left(sPath, 2) = "\\") Then
  Dim pos As Integer
  pos = InStr(3, sPath, "\")
  If (pos > 0) Then
    Dim sCompName As String
    sCompName = Mid(sPath, 3, pos - 3)
  End If
  
  Dim lDummy As Long, sDummy As String
  Dim blIsPresent As Boolean
  
  If Not lanCheckComputerStatus(sCompName, lTimeOut, lDummy, sDummy, blIsPresent) Then
    Exit Function
  End If
  
  If (blIsPresent) Then
    lanTestServerAvailability = True
  End If
Else
  lanTestServerAvailability = True
End If

End Function

Private Function lanCheckComputerStatus(ByVal sAddr As String, ByVal lTimeOut As Long, ByRef lSpeed As Long, ByRef sIPAddress As String, ByRef blIsPresent As Boolean) As Boolean
On Error GoTo fout
lanCheckComputerStatus = False

blIsPresent = False
lSpeed = 0
sIPAddress = ""

Dim hFile As Long, lpWSAdata As PING_WSADATA
Dim hHostent As PING_HOSTENT
Dim lAddrList As Long, lAddress As Long
Dim lpOptInfo As PING_IP_OPTION_INFORMATION
Dim lpEchoReply As PING_IP_ECHO_REPLY

Dim blWSAStarted As Boolean

hFile = 0
blWSAStarted = False


pingWSAStartup &H101, lpWSAdata
blWSAStarted = True

Dim lHostByName As Long
lHostByName = pingGetHostByName(sAddr + String(64 - Len(sAddr), 0))

If lHostByName <> PING_SOCKET_ERROR Then
  'dereference some pointers
  pingCopyMemory hHostent.h_name, ByVal lHostByName, Len(hHostent)
  pingCopyMemory lAddrList, ByVal hHostent.h_addr_list, 4
  pingCopyMemory lAddress, ByVal lAddrList, 4
End If

hFile = pingIcmpCreateFile()

If hFile = 0 Then
  Err.Raise 1, , "Could not create file handle"
End If

lpOptInfo.bTTL = 255

If pingIcmpSendEcho(hFile, lAddress, String(32, "A"), 32, lpOptInfo, lpEchoReply, Len(lpEchoReply) + 8, lTimeOut) Then
  sIPAddress = CStr(lpEchoReply.bAddress(0)) + "." + CStr(lpEchoReply.bAddress(1)) + "." + CStr(lpEchoReply.bAddress(2)) + "." + CStr(lpEchoReply.bAddress(3))
  If (lpEchoReply.lStatus = 0) Then
    lSpeed = lpEchoReply.lRoundTripTime
    blIsPresent = True
  End If
End If

pingIcmpCloseHandle hFile
hFile = 0

pingWSACleanup
blWSAStarted = False


lanCheckComputerStatus = True
Exit Function

fout:

Dim errInf As ERR_INFO
appRecordError "lanCheckComputerStats", errInf

On Error Resume Next

If (hFile <> 0) Then
  pingIcmpCloseHandle hFile
  hFile = 0
End If

If (blWSAStarted) Then
  pingWSACleanup
  blWSAStarted = False
End If

appDisplayError errInf
Exit Function

End Function


Public Function appSafeTransferTable(ByVal iImpMode As Integer, ByVal sDBName As String, sSrcName As String, sTgtName As String, ByVal blHandleError As Boolean, ByRef errUnhandled As ERR_INFO) As Boolean
If (iImpMode = acLink) Then
  appSafeTransferTable = appSafeLinkTable(sDBName, sSrcName, sTgtName, blHandleError, errUnhandled)
Else
  appSafeTransferTable = appSafeImportTable(sDBName, sSrcName, sTgtName, blHandleError, errUnhandled)
End If
End Function

Public Function appSafeLinkTable(ByVal sDBName As String, sSrcName As String, sTgtName As String, ByVal blHandleError As Boolean, ByRef errUnhandled As ERR_INFO) As Boolean
On Error GoTo fout
appSafeLinkTable = False

Dim db As Database
Set db = CurrentDb()

Dim tbDef As TableDef
Set tbDef = CurrentDb.CreateTableDef(sTgtName)

tbDef.Connect = ";DATABASE=" & sDBName
tbDef.SourceTableName = sSrcName

db.TableDefs.Append tbDef

If Not tbDef Is Nothing Then
  Set tbDef = Nothing
End If

appSafeLinkTable = True
Exit Function

fout:
Dim errInf As ERR_INFO
appRecordError "appSafeLinkTable", errInf

If Not tbDef Is Nothing Then
  Set tbDef = Nothing
End If

If (blHandleError) Then
  appDisplayError errInf
Else
  appCopyError errInf, errUnhandled
End If
Exit Function

End Function

Public Function appSafeImportTable(ByVal sDBName As String, sSrcName As String, sTgtName As String, ByVal blHandleError As Boolean, ByRef errUnhandled As ERR_INFO) As Boolean
On Error GoTo fout

appSafeImportTable = False

Dim blDeletingTable As Boolean
blDeletingTable = False

'if access 2007 or higher than need special import procedure
'access 2007 = version "12.0"
If val(SysCmd(acSysCmdAccessVer)) < 11.5 Then
  'old access; can safely use transferdatabase
  DoCmd.TransferDatabase acImport, "Microsoft Access", sDBName, acTable, sSrcName, sTgtName
Else

  DoCmd.SetWarnings False
  
  blDeletingTable = True
  DoCmd.DeleteObject acTable, "__safe__import__temp"
  blDeletingTable = False

  'need to first import table and then make new table
  Dim tpErrInf As ERR_INFO
  If Not appSafeLinkTable(sDBName, sSrcName, "__safe__import__temp", blHandleError, tpErrInf) Then
    If (blHandleError) Then
      appRaiseSilentError
    Else
      appReraiseError tpErrInf
    End If
  End If
  
  If Not tableExists("__safe__import__temp") Then
    Err.Raise 3011, , "The table: " & sSrcName & " could not be found in " & vbCrLf & sDBName
  End If
  
  Dim sql As String
  sql = "SELECT [__safe__import__temp].* INTO [" & sTgtName & "] FROM [__safe__import__temp];"
  DoCmd.RunSQL sql
  
  
  'now need to copy over indices
  Dim dsTmp As DIR_SERVER_DATA
  dsInit dsTmp, True, "__safe__import__temp__indexes", 10000
  
  Dim tbSrc As TableDef, tbTgt As TableDef, curDB As Database
  
  Set curDB = CurrentDb()
  Set tbSrc = curDB.TableDefs("__safe__import__temp")
  Set tbTgt = curDB.TableDefs(sTgtName)
  
  Dim iIdx As Integer, nIdx As Integer
  nIdx = tbSrc.Indexes.Count
  
  For iIdx = 0 To nIdx - 1
    Dim idx As Index
    Set idx = tbSrc.Indexes(iIdx)
  
    Dim sIdxPropName As String
    sIdxPropName = "\INDEX_" & iIdx
  
    If Not xdbReadStructure_readIndex(dsTmp, idx, sIdxPropName) Then
      appRaiseSilentError
    End If
  
    Set idx = Nothing
    
    Set idx = tbTgt.CreateIndex
    If Not xdbCreateStructure_writeIndex(dsTmp, idx, sIdxPropName) Then
      appRaiseSilentError
    End If
    
    tbTgt.Indexes.Append idx
    Set idx = Nothing
    
  Next iIdx
  
  

  dsClean dsTmp
  If Not (tbSrc Is Nothing) Then
    Set tbSrc = Nothing
  End If
  If Not (tbTgt Is Nothing) Then
    Set tbTgt = Nothing
  End If


  
  
  blDeletingTable = True
  DoCmd.DeleteObject acTable, "__safe__import__temp"
  blDeletingTable = False
  
  DoCmd.SetWarnings True
  
End If



appSafeImportTable = True
Exit Function

fout:

'could not find object to delete
If (blDeletingTable) Then
  If Err = 3011 Or Err = 7874 Then Resume Next 'could not find object to delete
End If

Dim errInf As ERR_INFO
appRecordError "appSafeImportTable", errInf

DoCmd.SetWarnings True
dsClean dsTmp

If Not (tbSrc Is Nothing) Then
  Set tbSrc = Nothing
End If
If Not (tbTgt Is Nothing) Then
  Set tbTgt = Nothing
End If

If (blHandleError) Then
  appDisplayError errInf
Else
  appCopyError errInf, errUnhandled
End If
Exit Function

End Function




Private Function xdbReadStructure_IsValidTbProp(ByVal sPropName As String) As Boolean
Dim tpRes As Boolean
tpRes = False

Select Case sPropName
  Case "Name"
    tpRes = True
  Case "ValidationRule"
    tpRes = True
  Case "ValidationText"
    tpRes = True
End Select

xdbReadStructure_IsValidTbProp = tpRes

End Function

Private Function xdbReadStructure_IsValidFldProp(ByVal sPropName As String, ByVal blIsRelField As Boolean, ByVal blIsIdx) As Boolean
Dim tpRes As Boolean
tpRes = False

Select Case sPropName
  Case "ValidationRule"
    tpRes = Not (blIsRelField Or blIsIdx)
  Case "ValidationText"
    tpRes = Not (blIsRelField Or blIsIdx)
  Case "Name"
    tpRes = True
  Case "Type"
    tpRes = Not (blIsRelField Or blIsIdx)
  Case "Attributes"
    tpRes = Not blIsRelField
  Case "Size"
    tpRes = Not (blIsRelField Or blIsIdx)
  Case "ForeignName"
    tpRes = blIsRelField
  Case "DefaultValue"
    tpRes = Not (blIsRelField Or blIsIdx)
  Case "Required"
    tpRes = Not (blIsRelField Or blIsIdx)
  Case "AllowZeroLength"
    tpRes = Not (blIsRelField Or blIsIdx)
  Case "Format"
    tpRes = Not (blIsRelField Or blIsIdx)
  Case "InputMask"
    tpRes = Not (blIsRelField Or blIsIdx)
  Case "Description"
    tpRes = Not (blIsRelField Or blIsIdx)
  Case "DisplayControl"
    tpRes = Not (blIsRelField Or blIsIdx)
  
End Select

xdbReadStructure_IsValidFldProp = tpRes

End Function

Private Function xdbReadStructure_IsValidIdxProp(ByVal sPropName As String) As Boolean
Dim tpRes As Boolean
tpRes = False

Select Case sPropName
  Case "Name"
    tpRes = True
  Case "Unique"
    tpRes = True
  Case "Primary"
    tpRes = True
  Case "IgnoreNulls"
    tpRes = True
  
End Select

xdbReadStructure_IsValidIdxProp = tpRes

End Function

Private Function xdbReadStructure_IsValidRelProp(ByVal sPropName As String) As Boolean
Dim tpRes As Boolean
tpRes = False

Select Case sPropName
  Case "Name"
    tpRes = True
  Case "Table"
    tpRes = True
  Case "ForeignTable"
    tpRes = True
  Case "Attributes"
    tpRes = True
End Select

xdbReadStructure_IsValidRelProp = tpRes

End Function


Private Sub xdbReadStructure_exportProp(ByRef dsData As DIR_SERVER_DATA, ByRef prp As Property, ByVal sPropBaseName As String)

Dim blDummy As Boolean, sDummy As String, lDummy As Long
Dim sPropName As String, sPropValue As String

sPropName = sPropBaseName & "\" & prp.name
If prp.type = dbBoolean Then
  sPropValue = rxpFormatBoolean(prp.value)
Else
  sPropValue = CStr(prp.value)
End If
  
If Not dsSetPropertyByName(dsData, sPropName, sPropValue, lDummy, blDummy, sDummy) Then
  appRaiseSilentError
End If



End Sub


Private Function xdbReadStructure_readField(ByRef dsData As DIR_SERVER_DATA, ByRef fld As Field, ByVal sPropBaseName As String, ByVal blIsRelField As Boolean, blIsIdxField As Boolean) As Boolean
On Error GoTo fout
xdbReadStructure_readField = False

Dim prp As Property
For Each prp In fld.Properties
  If xdbReadStructure_IsValidFldProp(prp.name, blIsRelField, blIsIdxField) Then
    xdbReadStructure_exportProp dsData, prp, sPropBaseName
  End If
Next prp

xdbReadStructure_readField = True
Exit Function

fout:
Dim errInf As ERR_INFO
appRecordError "xdbReadStructure_readField", errInf


appDisplayError errInf
Exit Function

End Function


Private Function xdbReadStructure_readIndex(ByRef dsData As DIR_SERVER_DATA, ByRef idx As Index, ByVal sPropBaseName As String) As Boolean
On Error GoTo fout
xdbReadStructure_readIndex = False

Dim prp As Property
For Each prp In idx.Properties
  If xdbReadStructure_IsValidIdxProp(prp.name) Then
    xdbReadStructure_exportProp dsData, prp, sPropBaseName
  End If
Next prp

Dim nFields As Integer
nFields = idx.Fields.Count


Dim lDummy As Long, blDummy As Boolean, sDummy As String

Dim sPropName As String, sPropVal As String

sPropName = sPropBaseName & "\N_FIELDS"
sPropVal = CStr(nFields)
If Not dsSetPropertyByName(dsData, sPropName, sPropVal, lDummy, blDummy, sDummy) Then
  appRaiseSilentError
End If


Dim iff As Integer
For iff = 0 To nFields - 1
  Dim fld As Field
  Set fld = idx.Fields(iff)
  
  Dim sFldPropName As String
  sFldPropName = sPropBaseName & "\FIELD_" & iff
  
  If Not xdbReadStructure_readField(dsData, fld, sFldPropName, False, True) Then
    appRaiseSilentError
  End If
  
  
  Set fld = Nothing
Next iff


xdbReadStructure_readIndex = True
Exit Function

fout:
Dim errInf As ERR_INFO
appRecordError "xdbReadStructure_readIndex", errInf


appDisplayError errInf
Exit Function

End Function



Private Function xdbReadStructure_readTable(ByRef dsData As DIR_SERVER_DATA, ByRef tb As TableDef, ByVal sPropBaseName As String) As Boolean
On Error GoTo fout
xdbReadStructure_readTable = False



Dim prp As Property
For Each prp In tb.Properties
  If xdbReadStructure_IsValidTbProp(prp.name) Then
    xdbReadStructure_exportProp dsData, prp, sPropBaseName
  End If
Next prp



Dim nFields As Integer
nFields = tb.Fields.Count


Dim blDummy As Boolean, lDummy As Long, sDummy As String

Dim sPropName As String, sPropVal As String


sPropName = sPropBaseName & "\N_FIELDS"
sPropVal = CStr(nFields)
If Not dsSetPropertyByName(dsData, sPropName, sPropVal, lDummy, blDummy, sDummy) Then
  appRaiseSilentError
End If

Dim iff As Integer
For iff = 0 To nFields - 1
  Dim fld As Field
  Set fld = tb.Fields(iff)
  
  Dim sFldPropName As String
  sFldPropName = sPropBaseName & "\FIELD_" & iff
  
  If Not xdbReadStructure_readField(dsData, fld, sFldPropName, False, False) Then
    appRaiseSilentError
  End If
  
  
  Set fld = Nothing
Next iff




Dim nIdx As Integer
nIdx = tb.Indexes.Count

sPropName = sPropBaseName & "\N_INDEXES"
sPropVal = CStr(nIdx)
If Not dsSetPropertyByName(dsData, sPropName, sPropVal, lDummy, blDummy, sDummy) Then
  appRaiseSilentError
End If


Dim iIdx As Integer
For iIdx = 0 To nIdx - 1
  Dim idx As Index
  Set idx = tb.Indexes(iIdx)
  
  Dim sIdxPropName As String
  sIdxPropName = sPropBaseName & "\INDEX_" & iIdx
  
  If Not xdbReadStructure_readIndex(dsData, idx, sIdxPropName) Then
    appRaiseSilentError
  End If
  
  
  Set idx = Nothing
Next iIdx


xdbReadStructure_readTable = True
Exit Function

fout:
Dim errInf As ERR_INFO
appRecordError "xdbReadStructure_readTable", errInf


appDisplayError errInf
Exit Function

End Function


Private Function xdbReadStructure_readTables(ByRef db As Database, ByRef dsData As DIR_SERVER_DATA, ByVal sPropBaseName As String) As Boolean
On Error GoTo fout
xdbReadStructure_readTables = False




Dim nTables As Integer
nTables = db.TableDefs.Count

Dim nExpTables As Integer
nExpTables = 0

Dim it As Integer
For it = 0 To nTables - 1
  Dim tb As TableDef
  Set tb = db.TableDefs(it)
  
  Dim blExp As Boolean
  blExp = True
  
  If (dbSystemObject And tb.Attributes) <> 0 Or (dbHiddenObject And tb.Attributes) <> 0 Then
    blExp = False
  End If
  
  If (blExp) Then
    Dim sTbBaseName As String
    sTbBaseName = sPropBaseName & "\TABLE_" & nExpTables
  
    If Not xdbReadStructure_readTable(dsData, tb, sTbBaseName) Then
      appRaiseSilentError
    End If
    
    nExpTables = nExpTables + 1
    
  End If
  
  Set tb = Nothing
  
Next it

Dim blDummy As Boolean, sDummy As String, lDummy As Long

Dim sPropName As String, sPropVal As String


sPropName = sPropBaseName & "\N_TABLES"
sPropVal = CStr(nExpTables)
If Not dsSetPropertyByName(dsData, sPropName, sPropVal, lDummy, blDummy, sDummy) Then
  appRaiseSilentError
End If





xdbReadStructure_readTables = True
Exit Function

fout:
Dim errInf As ERR_INFO
appRecordError "xdbReadStructure_readTables", errInf


appDisplayError errInf
Exit Function

End Function



Private Function xdbReadStructure_readRelation(ByRef dsData As DIR_SERVER_DATA, ByRef rel As Relation, ByVal sPropBaseName As String) As Boolean
On Error GoTo fout
xdbReadStructure_readRelation = False



Dim prp As Property
For Each prp In rel.Properties
  If xdbReadStructure_IsValidRelProp(prp.name) Then
    xdbReadStructure_exportProp dsData, prp, sPropBaseName
  End If
Next prp



Dim nFields As Integer
nFields = rel.Fields.Count

Dim blDummy As Boolean, sDummy As String, lDummy As Long

Dim sPropName As String, sPropVal As String

sPropName = sPropBaseName & "\N_FIELDS"
sPropVal = CStr(nFields)
If Not dsSetPropertyByName(dsData, sPropName, sPropVal, lDummy, blDummy, sDummy) Then
  appRaiseSilentError
End If


Dim iff As Integer
For iff = 0 To nFields - 1
  Dim fld As Field
  Set fld = rel.Fields(iff)
  
  Dim sFldPropName As String
  sFldPropName = sPropBaseName & "\FIELD_" & iff
  
  If Not xdbReadStructure_readField(dsData, fld, sFldPropName, True, False) Then
    appRaiseSilentError
  End If
  
  
  Set fld = Nothing
Next iff




xdbReadStructure_readRelation = True
Exit Function

fout:
Dim errInf As ERR_INFO
appRecordError "xdbReadStructure_readRelation", errInf

appDisplayError errInf
Exit Function

End Function



Private Function xdbReadStructure_readRelations(ByRef db As Database, ByRef dsData As DIR_SERVER_DATA, ByVal sPropBaseName As String) As Boolean
On Error GoTo fout
xdbReadStructure_readRelations = False


Dim nRels As Integer
nRels = db.Relations.Count

Dim blDummy As Boolean, sDummy As String, lDummy As Long

Dim sPropName As String, sPropVal As String

sPropName = sPropBaseName & "\N_RELATIONS"
sPropVal = CStr(nRels)
If Not dsSetPropertyByName(dsData, sPropName, sPropVal, lDummy, blDummy, sDummy) Then
  appRaiseSilentError
End If


Dim iRel As Integer
For iRel = 0 To nRels - 1
  
  Dim rel As Relation
  Set rel = db.Relations(iRel)
  
  Dim sRelBaseName As String
  sRelBaseName = sPropBaseName & "\RELATION_" & iRel
  
  If Not xdbReadStructure_readRelation(dsData, rel, sRelBaseName) Then
    appRaiseSilentError
  End If
  
  Set rel = Nothing

Next iRel




xdbReadStructure_readRelations = True
Exit Function

fout:
Dim errInf As ERR_INFO
appRecordError "xdbReadStructure_readRelations", errInf

appDisplayError errInf
Exit Function

End Function






'To be called only by HJH at design time
Public Function xdbReadStructure(ByVal sFileName As String, sExpName As String) As Boolean
On Error GoTo fout
xdbReadStructure = False

Dim dsData As DIR_SERVER_DATA

If Not dsInit(dsData, False, "fdtgExpDBStructures") Then
  appRaiseSilentError
End If


Dim sPropBaseName As String
sPropBaseName = "EXP_DB_STRUCTURES\" & sExpName

Dim blDummy As Boolean, sDummy As String, lDummy As Long

If Not dsDeletePropertyByName(dsData, sPropBaseName, blDummy, sDummy) Then
  appRaiseSilentError
End If

Dim db As Database
Set db = DBEngine.Workspaces(0).OpenDatabase(sFileName)

Dim lVersionCode As Long

If val(db.Version) >= 4 Then
  lVersionCode = HUP_DB_VERSION_40 'dbVersion40; hardcoded to allow compile in access97
Else
  lVersionCode = HUP_DB_VERSION_30 'dbVersion30;
End If

Dim sPropName As String, sPropVal As String

sPropName = sPropBaseName & "\DB_VERSION"
sPropVal = CStr(lVersionCode)
If Not dsSetPropertyByName(dsData, sPropName, sPropVal, lDummy, blDummy, sDummy) Then
  appRaiseSilentError
End If

If Not xdbReadStructure_readTables(db, dsData, sPropBaseName) Then
  appRaiseSilentError
End If

If Not xdbReadStructure_readRelations(db, dsData, sPropBaseName) Then
  appRaiseSilentError
End If


appCleanDB db
dsClean dsData

xdbReadStructure = True
Exit Function

fout:
Dim errInf As ERR_INFO
appRecordError "xdbReadStructure", errInf

appCleanDB db
dsClean dsData

appDisplayError errInf
Exit Function

End Function

'HJH maintenance function; To be called only by HJH at design time
Public Function fxsStoreString(ByVal sName As String, ByVal sValue As String) As Boolean
On Error GoTo fout
fxsStoreString = False

If (sName = "") Then
  Err.Raise 1, , "Illegal string name"
End If

Dim skFxs As Recordset

Set skFxs = CurrentDb().OpenRecordset("fdtgFixedStrings")
skFxs.Index = "PrimaryKey"

skFxs.Seek "=", sName

If (skFxs.NoMatch) Then
  skFxs.AddNew
  skFxs("FS_Name") = hzn(sName)
Else
  skFxs.Edit
End If

  skFxs("FS_Value") = hzn(sValue)

skFxs.Update

appCleanRS skFxs

fxsStoreString = True
Exit Function

fout:
Dim errInf As ERR_INFO
appRecordError "fxsStoreString", errInf

appCleanRS skFxs

appDisplayError errInf
Exit Function
End Function

Public Function fxsReadString(ByVal sName As String, ByRef sValue As String, ByRef blPresent As Boolean) As Boolean
On Error GoTo fout
fxsReadString = False

blPresent = False
sValue = ""

If (sName = "") Then
  Err.Raise 1, , "Illegal string name"
End If

Dim skFxs As Recordset

Set skFxs = CurrentDb().OpenRecordset("fdtgFixedStrings")
skFxs.Index = "PrimaryKey"

skFxs.Seek "=", sName

If (Not skFxs.NoMatch) Then
  blPresent = True
  sValue = Nz(skFxs("FS_VALUE"))
End If

appCleanRS skFxs

fxsReadString = True
Exit Function

fout:
Dim errInf As ERR_INFO
appRecordError "fxsReadString", errInf

appCleanRS skFxs

appDisplayError errInf
Exit Function
End Function



Private Function xdbCreateStructure_writeField(ByRef dsData As DIR_SERVER_DATA, ByRef fld As Field, ByVal sPropBaseName As String, ByRef nExtProps As Integer, ByRef sExtPropFieldName() As String, ByRef pExtProp() As Property) As Boolean
On Error GoTo fout
xdbCreateStructure_writeField = False

Dim sPropName As String, sPropVal As String

Dim blPresent As Boolean, lDummy As Long


sPropName = sPropBaseName & "\Name"
If Not dsLookupPropertyByName(dsData, sPropName, blPresent, sPropVal, lDummy) Then
  appRaiseSilentError
End If
fld.name = sPropVal

sPropName = sPropBaseName & "\ForeignName"
If Not dsLookupPropertyByName(dsData, sPropName, blPresent, sPropVal, lDummy) Then
  appRaiseSilentError
End If
If (blPresent) Then
  fld.ForeignName = sPropVal
End If

sPropName = sPropBaseName & "\Attributes"
If Not dsLookupPropertyByName(dsData, sPropName, blPresent, sPropVal, lDummy) Then
  appRaiseSilentError
End If
If (blPresent) Then
  fld.Attributes = CLng(sPropVal)
End If

sPropName = sPropBaseName & "\Type"
If Not dsLookupPropertyByName(dsData, sPropName, blPresent, sPropVal, lDummy) Then
  appRaiseSilentError
End If
If (blPresent) Then
  fld.type = CLng(sPropVal)
End If

sPropName = sPropBaseName & "\Size"
If Not dsLookupPropertyByName(dsData, sPropName, blPresent, sPropVal, lDummy) Then
  appRaiseSilentError
End If
If (blPresent) Then
  fld.Size = CLng(sPropVal)
End If

sPropName = sPropBaseName & "\DefaultValue"
If Not dsLookupPropertyByName(dsData, sPropName, blPresent, sPropVal, lDummy) Then
  appRaiseSilentError
End If
If (blPresent) Then
  fld.DefaultValue = sPropVal
End If

sPropName = sPropBaseName & "\ValidationRule"
If Not dsLookupPropertyByName(dsData, sPropName, blPresent, sPropVal, lDummy) Then
  appRaiseSilentError
End If
If (blPresent) Then
  fld.ValidationRule = sPropVal
End If

sPropName = sPropBaseName & "\ValidationText"
If Not dsLookupPropertyByName(dsData, sPropName, blPresent, sPropVal, lDummy) Then
  appRaiseSilentError
End If
If (blPresent) Then
  fld.ValidationText = sPropVal
End If


sPropName = sPropBaseName & "\Required"
If Not dsLookupPropertyByName(dsData, sPropName, blPresent, sPropVal, lDummy) Then
  appRaiseSilentError
End If
If (blPresent) Then
  If (rxpParseBoolean(sPropVal)) Then
    fld.Required = True
  Else
    fld.Required = False
  End If
End If

sPropName = sPropBaseName & "\AllowZeroLength"
If Not dsLookupPropertyByName(dsData, sPropName, blPresent, sPropVal, lDummy) Then
  appRaiseSilentError
End If
If (blPresent) Then
  If (rxpParseBoolean(sPropVal)) Then
    fld.AllowZeroLength = True
  Else
    fld.AllowZeroLength = False
  End If
End If

sPropName = sPropBaseName & "\Format"
If Not dsLookupPropertyByName(dsData, sPropName, blPresent, sPropVal, lDummy) Then
  appRaiseSilentError
End If
If (sPropVal <> "") Then
  sExtPropFieldName(nExtProps) = fld.name
  Set pExtProp(nExtProps) = fld.CreateProperty("Format", dbText, sPropVal)
  nExtProps = nExtProps + 1
End If

sPropName = sPropBaseName & "\InputMask"
If Not dsLookupPropertyByName(dsData, sPropName, blPresent, sPropVal, lDummy) Then
  appRaiseSilentError
End If
If (sPropVal <> "") Then
  sExtPropFieldName(nExtProps) = fld.name
  Set pExtProp(nExtProps) = fld.CreateProperty("InputMask", dbText, sPropVal)
  nExtProps = nExtProps + 1
End If

sPropName = sPropBaseName & "\Description"
If Not dsLookupPropertyByName(dsData, sPropName, blPresent, sPropVal, lDummy) Then
  appRaiseSilentError
End If
If (sPropVal <> "") Then
  sExtPropFieldName(nExtProps) = fld.name
  Set pExtProp(nExtProps) = fld.CreateProperty("Description", dbText, sPropVal)
  nExtProps = nExtProps + 1
End If

sPropName = sPropBaseName & "\DisplayControl"
If Not dsLookupPropertyByName(dsData, sPropName, blPresent, sPropVal, lDummy) Then
  appRaiseSilentError
End If
If (sPropVal <> "") Then
  sExtPropFieldName(nExtProps) = fld.name
  Set pExtProp(nExtProps) = fld.CreateProperty("DisplayControl", dbInteger, CInt(sPropVal))
  nExtProps = nExtProps + 1
End If




xdbCreateStructure_writeField = True
Exit Function

fout:
If (Err = 3219) Then
  Resume Next
End If

Dim errInf As ERR_INFO
appRecordError "xdbCreateStructure_writeField", errInf

appDisplayError errInf
Exit Function

End Function

Private Function xdbCreateStructure_writeIndex(ByRef dsData As DIR_SERVER_DATA, ByRef idx As Index, sPropBaseName As String) As Boolean
On Error GoTo fout
xdbCreateStructure_writeIndex = False


Dim sPropName As String, sPropVal As String

Dim blPresent As Boolean, lDummy As Long


sPropName = sPropBaseName & "\Name"
If Not dsLookupPropertyByName(dsData, sPropName, blPresent, sPropVal, lDummy) Then
  appRaiseSilentError
End If
idx.name = sPropVal

sPropName = sPropBaseName & "\Unique"
If Not dsLookupPropertyByName(dsData, sPropName, blPresent, sPropVal, lDummy) Then
  appRaiseSilentError
End If
If (blPresent) Then
  If (rxpParseBoolean(sPropVal)) Then
    idx.Unique = True
  Else
    idx.Unique = False
  End If
End If

sPropName = sPropBaseName & "\Primary"
If Not dsLookupPropertyByName(dsData, sPropName, blPresent, sPropVal, lDummy) Then
  appRaiseSilentError
End If
If (blPresent) Then
  If (rxpParseBoolean(sPropVal)) Then
    idx.Primary = True
  Else
    idx.Primary = False
  End If
End If


sPropName = sPropBaseName & "\IgnoreNulls"
If Not dsLookupPropertyByName(dsData, sPropName, blPresent, sPropVal, lDummy) Then
  appRaiseSilentError
End If
If (blPresent) Then
  If (rxpParseBoolean(sPropVal)) Then
    idx.IgnoreNulls = True
  Else
    idx.IgnoreNulls = False
  End If
End If



sPropName = sPropBaseName & "\N_FIELDS"
If Not dsLookupPropertyByName(dsData, sPropName, blPresent, sPropVal, lDummy) Then
  appRaiseSilentError
End If

If Not blPresent Then
  Err.Raise 1, , "internal error"
End If

Dim nFields As Integer
nFields = CInt(sPropVal)

Dim iff As Integer
For iff = 0 To nFields - 1
  Dim fld As Field
  Set fld = idx.CreateField()
  
  Dim sFldPropName As String
  sFldPropName = sPropBaseName & "\FIELD_" & iff
  
  Dim nDummy As Integer, sDummy(0 To 0) As String, pDummy(0 To 0) As Property
  
  If Not xdbCreateStructure_writeField(dsData, fld, sFldPropName, nDummy, sDummy, pDummy) Then
    appRaiseSilentError
  End If
  
  idx.Fields.Append fld
  Set fld = Nothing
Next iff


xdbCreateStructure_writeIndex = True
Exit Function

fout:
Dim errInf As ERR_INFO
appRecordError "xdbCreateStructure_writeIndex", errInf

appDisplayError errInf
Exit Function

End Function


Private Function xdbCreateStructure_writeTable(ByRef dsData As DIR_SERVER_DATA, ByRef tb As TableDef, ByVal sPropBaseName As String, ByRef nExtProps As Integer, ByRef sExtPropFieldName() As String, ByRef pExtProp() As Property) As Boolean
On Error GoTo fout
xdbCreateStructure_writeTable = False


Dim sPropName As String, sPropVal As String

Dim blPresent As Boolean, lDummy As Long


sPropName = sPropBaseName & "\Name"
If Not dsLookupPropertyByName(dsData, sPropName, blPresent, sPropVal, lDummy) Then
  appRaiseSilentError
End If
tb.name = sPropVal

sPropName = sPropBaseName & "\ValidationRule"
If Not dsLookupPropertyByName(dsData, sPropName, blPresent, sPropVal, lDummy) Then
  appRaiseSilentError
End If
If (blPresent) Then
  tb.ValidationRule = sPropVal
End If

sPropName = sPropBaseName & "\ValidationText"
If Not dsLookupPropertyByName(dsData, sPropName, blPresent, sPropVal, lDummy) Then
  appRaiseSilentError
End If
If (blPresent) Then
  tb.ValidationText = sPropVal
End If



sPropName = sPropBaseName & "\N_FIELDS"
If Not dsLookupPropertyByName(dsData, sPropName, blPresent, sPropVal, lDummy) Then
  appRaiseSilentError
End If

If Not blPresent Then
  Err.Raise 1, , "internal error"
End If

Dim nFields As Integer
nFields = CInt(sPropVal)

nExtProps = 0

Dim iff As Integer
For iff = 0 To nFields - 1
  Dim fld As Field
  Set fld = tb.CreateField()
  
  Dim sFldPropName As String
  sFldPropName = sPropBaseName & "\FIELD_" & iff
  
  If Not xdbCreateStructure_writeField(dsData, fld, sFldPropName, nExtProps, sExtPropFieldName, pExtProp) Then
    appRaiseSilentError
  End If
  
  tb.Fields.Append fld
  Set fld = Nothing
Next iff


sPropName = sPropBaseName & "\N_INDEXES"
If Not dsLookupPropertyByName(dsData, sPropName, blPresent, sPropVal, lDummy) Then
  appRaiseSilentError
End If

If Not blPresent Then
  Err.Raise 1, , "internal error"
End If

Dim nIdx As Integer
nIdx = CInt(sPropVal)

Dim iIdx As Integer
For iIdx = 0 To nIdx - 1
  Dim idx As Index
  Set idx = tb.CreateIndex()
  
  Dim sIdxPropName As String
  sIdxPropName = sPropBaseName & "\INDEX_" & iIdx
  
  If Not xdbCreateStructure_writeIndex(dsData, idx, sIdxPropName) Then
    appRaiseSilentError
  End If
  
  tb.Indexes.Append idx
  Set idx = Nothing
Next iIdx


xdbCreateStructure_writeTable = True
Exit Function

fout:
Dim errInf As ERR_INFO
appRecordError "xdbCreateStructure_writeTable", errInf

appDisplayError errInf
Exit Function

End Function


Private Function xdbCreateStructure_writeTables(ByRef dsData As DIR_SERVER_DATA, ByRef db As Database, sPropBaseName As String) As Boolean
On Error GoTo fout
xdbCreateStructure_writeTables = False


Dim sPropName As String, sPropVal As String

Dim blPresent As Boolean, lDummy As Long

sPropName = sPropBaseName & "\N_TABLES"
If Not dsLookupPropertyByName(dsData, sPropName, blPresent, sPropVal, lDummy) Then
  appRaiseSilentError
End If

If Not blPresent Then
  Err.Raise 1, , "internal error"
End If

Dim nTables As Integer
nTables = CInt(sPropVal)

Dim it As Integer
For it = 0 To nTables - 1
  Dim tbDef As TableDef
  Set tbDef = db.CreateTableDef()
  
  Dim sTbPropName As String
  sTbPropName = sPropBaseName & "\TABLE_" & it
  
  Dim nExtProps As Integer
  Dim sExtPropFldNames(0 To 1000) As String
  Dim pExtProps(0 To 1000) As Property
  
  If Not xdbCreateStructure_writeTable(dsData, tbDef, sTbPropName, nExtProps, sExtPropFldNames, pExtProps) Then
    appRaiseSilentError
  End If
  
  Dim tpTableName As String
  tpTableName = tbDef.name
  
  db.TableDefs.Append tbDef
  Set tbDef = Nothing
  
  Dim ip As Integer
  For ip = 0 To nExtProps - 1
    Dim fld As Field
    Set fld = db.TableDefs(tpTableName).Fields(sExtPropFldNames(ip))
    fld.Properties.Append fld.CreateProperty(pExtProps(ip).name, pExtProps(ip).type, pExtProps(ip).value)
    Set fld = Nothing
    Set pExtProps(ip) = Nothing
  Next ip
  
Next it


xdbCreateStructure_writeTables = True
Exit Function

fout:
Dim errInf As ERR_INFO
appRecordError "xdbCreateStructure_writeTables", errInf

appDisplayError errInf
Exit Function

End Function

Private Function xdbCreateStructure_writeRelation(ByRef dsData As DIR_SERVER_DATA, ByRef rel As Relation, ByVal sPropBaseName As String) As Boolean
On Error GoTo fout
xdbCreateStructure_writeRelation = False


Dim sPropName As String, sPropVal As String

Dim blPresent As Boolean, lDummy As Long


sPropName = sPropBaseName & "\Name"
If Not dsLookupPropertyByName(dsData, sPropName, blPresent, sPropVal, lDummy) Then
  appRaiseSilentError
End If
rel.name = sPropVal

sPropName = sPropBaseName & "\Table"
If Not dsLookupPropertyByName(dsData, sPropName, blPresent, sPropVal, lDummy) Then
  appRaiseSilentError
End If
If (blPresent) Then
  rel.Table = sPropVal
End If

sPropName = sPropBaseName & "\ForeignTable"
If Not dsLookupPropertyByName(dsData, sPropName, blPresent, sPropVal, lDummy) Then
  appRaiseSilentError
End If
If (blPresent) Then
  rel.ForeignTable = sPropVal
End If

sPropName = sPropBaseName & "\Attributes"
If Not dsLookupPropertyByName(dsData, sPropName, blPresent, sPropVal, lDummy) Then
  appRaiseSilentError
End If
If (blPresent) Then
  rel.Attributes = CLng(sPropVal)
End If




sPropName = sPropBaseName & "\N_FIELDS"
If Not dsLookupPropertyByName(dsData, sPropName, blPresent, sPropVal, lDummy) Then
  appRaiseSilentError
End If

If Not blPresent Then
  Err.Raise 1, , "internal error"
End If

Dim nFields As Integer
nFields = CInt(sPropVal)

Dim iff As Integer
For iff = 0 To nFields - 1
  Dim fld As Field
  Set fld = rel.CreateField()
  
  Dim sFldPropName As String
  sFldPropName = sPropBaseName & "\FIELD_" & iff
  
  Dim nDummy As Integer, sDummy(0 To 0) As String, pDummy(0 To 0) As Property
  
  If Not xdbCreateStructure_writeField(dsData, fld, sFldPropName, nDummy, sDummy, pDummy) Then
    appRaiseSilentError
  End If
  
  rel.Fields.Append fld
  Set fld = Nothing
Next iff


xdbCreateStructure_writeRelation = True
Exit Function

fout:
Dim errInf As ERR_INFO
appRecordError "xdbCreateStructure_writeRelation", errInf

appDisplayError errInf
Exit Function

End Function


Private Function xdbCreateStructure_writeRelations(ByRef dsData As DIR_SERVER_DATA, ByRef db As Database, sPropBaseName As String) As Boolean
On Error GoTo fout
xdbCreateStructure_writeRelations = False


Dim sPropName As String, sPropVal As String

Dim blPresent As Boolean, lDummy As Long

sPropName = sPropBaseName & "\N_RELATIONS"
If Not dsLookupPropertyByName(dsData, sPropName, blPresent, sPropVal, lDummy) Then
  appRaiseSilentError
End If

If Not blPresent Then
  Err.Raise 1, , "internal error"
End If

Dim nRelations As Integer
nRelations = CInt(sPropVal)

Dim ir As Integer
For ir = 0 To nRelations - 1
  Dim rel As Relation
  Set rel = db.CreateRelation()
  
  Dim sRelPropName As String
  sRelPropName = sPropBaseName & "\RELATION_" & ir
  
  If Not xdbCreateStructure_writeRelation(dsData, rel, sRelPropName) Then
    appRaiseSilentError
  End If
  
  Dim blAddingRel As Boolean
  
  blAddingRel = True
    db.Relations.Append rel
  blAddingRel = False
  
  Set rel = Nothing
  
Next ir

xdbCreateStructure_writeRelations = True
Exit Function

fout:

If (blAddingRel) And (Err = 3284) Then
  rel.name = "__relationship__number__" & ir
  Resume
End If
  

Dim errInf As ERR_INFO
appRecordError "xdbCreateStructure_writeRelations", errInf

appDisplayError errInf
Exit Function

End Function



Public Function xdbCreateStructure(ByVal sFileName As String, sExpName As String) As Boolean
On Error GoTo fout
xdbCreateStructure = False



If FileExists(sFileName) Then
  FileSystem.Kill sFileName
End If



Dim dsData As DIR_SERVER_DATA

If Not dsInit(dsData, False, "fdtgExpDBStructures") Then
  appRaiseSilentError
End If

Dim sPropBaseName As String
sPropBaseName = "EXP_DB_STRUCTURES\" & sExpName


Dim sPropName As String, sPropVal As String

Dim blDummy As Boolean, lDummy As Long

Dim lVersionCode As Long
lVersionCode = HUP_DB_VERSION_30

sPropName = sPropBaseName & "\DB_VERSION"
If Not dsLookupPropertyByName(dsData, sPropName, blDummy, sPropVal, lDummy) Then
  appRaiseSilentError
End If

If (sPropVal <> "") Then
  lVersionCode = CLng(sPropVal)
End If

'create the database
Dim db As Database
Set db = DBEngine.Workspaces(0).CreateDatabase(sFileName, DB_LANG_GENERAL, lVersionCode)


If Not xdbCreateStructure_writeTables(dsData, db, sPropBaseName) Then
  appRaiseSilentError
End If

If Not xdbCreateStructure_writeRelations(dsData, db, sPropBaseName) Then
  appRaiseSilentError
End If



appCleanDB db
dsClean dsData

xdbCreateStructure = True
Exit Function

fout:
Dim errInf As ERR_INFO
appRecordError "xdbCreateStructure", errInf

appCleanDB db
dsClean dsData

appDisplayError errInf
Exit Function

End Function


Public Function xdbEncodeTable(ByRef db As Database, ByVal sTbName As String, ByRef sData As String) As Boolean
On Error GoTo fout
xdbEncodeTable = False

sData = ""

Dim rs As Recordset
Set rs = db.OpenRecordset(sTbName)


Const ftype_string = 1
Const ftype_num = 2
Const ftype_dec = 3
Const ftype_log = 4
Const ftype_date = 5

Dim sFieldNames(0 To 1000) As String
Dim iFieldTypes(0 To 1000) As Integer
Dim nFields As Integer

nFields = rs.Fields.Count

Dim iff As Integer
For iff = 0 To nFields - 1
  sFieldNames(iff) = rs.Fields(iff).name
  Select Case rs.Fields(iff).type
    Case dbInteger, dbLong
      iFieldTypes(iff) = ftype_num
    Case dbDouble, dbCurrency, dbSingle, dbFloat
      iFieldTypes(iff) = ftype_dec
    Case dbBoolean
      iFieldTypes(iff) = ftype_log
    Case dbDate
      iFieldTypes(iff) = ftype_date
    Case Else
      iFieldTypes(iff) = ftype_string
  End Select
Next iff


rs.MoveFirst
Do Until rs.EOF
  Dim sEncVal As String
  sData = sData & "<xdb-rec>"
  For iff = 0 To nFields - 1
    sEncVal = ""
    If (Not IsNull(rs.Fields(iff))) Then
      Select Case iFieldTypes(iff)
        Case ftype_string
          sEncVal = Nz(rs.Fields(iff))
        Case ftype_num
          sEncVal = CStr(Nz(rs.Fields(iff)))
        Case ftype_dec
          sEncVal = CStr(Nz(rs.Fields(iff)))
          Dim tpDecPos As Integer
          tpDecPos = InStr(1, sEncVal, ",")
          If (tpDecPos > 0) Then
            sEncVal = Left(sEncVal, tpDecPos - 1) & "." & Right(sEncVal, Len(sEncVal) - tpDecPos)
          End If
        Case ftype_log
          sEncVal = IIf(Nz(rs.Fields(iff), False), "true", "false")
        Case ftype_date
          sEncVal = Format(Nz(rs.Fields(iff), #1/1/1900#), "yyyy\-mm\-dd")
        Case Else
          sEncVal = Nz(rs.Fields(iff))
      End Select
    End If
    
    sData = sData & "<xdb-fld-" & sFieldNames(iff) & ">"
    If (Len(sEncVal) > 0) Then
      sData = sData & gXMLWriter.convertToUTF(sEncVal, False)
    End If
    sData = sData & "</xdb-fld-" & sFieldNames(iff) & ">"
  Next iff
  sData = sData & "</xdb-rec>"
  rs.MoveNext
Loop


appCleanRS rs

xdbEncodeTable = True
Exit Function

fout:
If (Err = 3021) Then Resume Next

Dim errInf As ERR_INFO
appRecordError "xdbEncodeTable", errInf

appCleanRS rs

appDisplayError errInf
Exit Function
End Function


Public Function xdbWriteEncodedStringToTable(ByRef db As Database, ByVal sData As String, ByVal sTbName As String) As Boolean
On Error GoTo fout
xdbWriteEncodedStringToTable = False

Dim rs As Recordset
Set rs = db.OpenRecordset(sTbName)


Const ftype_string = 1
Const ftype_num = 2
Const ftype_dec = 3
Const ftype_log = 4
Const ftype_date = 5

Dim iFieldTypes(0 To 1000) As Integer
Dim nFields As Integer

Dim sOrdFieldNames(0 To 1000) As String
Dim iOrdFieldIdx(0 To 1000) As Integer

nFields = rs.Fields.Count

'Need to use extra counter to the fields here,
'since insstring updates the field count,
'hence cannot use loop counter for this purpose

Dim tpNFields As Integer
tpNFields = 0

Dim iff As Integer
For iff = 0 To nFields - 1
  Dim tpFieldName As String
  tpFieldName = rs.Fields(iff).name
  
  Dim insPos As Integer
  
  insPos = insString(tpFieldName, tpNFields, sOrdFieldNames)
  shiftRightInt insPos, 1, tpNFields - 1, iOrdFieldIdx
  iOrdFieldIdx(insPos) = iff
  
  
  Select Case rs.Fields(iff).type
    Case dbInteger, dbLong
      iFieldTypes(iff) = ftype_num
    Case dbDouble, dbCurrency, dbSingle, dbFloat
      iFieldTypes(iff) = ftype_dec
    Case dbBoolean
      iFieldTypes(iff) = ftype_log
    Case dbDate
      iFieldTypes(iff) = ftype_date
    Case Else
      iFieldTypes(iff) = ftype_string
  End Select
Next iff

While (sData <> "")
  extractToken sData, "<xdb-rec>"
  Dim sRecString As String
  sRecString = extractToken(sData, "</xdb-rec>")
  
  rs.AddNew
  While (sRecString <> "")
    'simple xml; do not allow single item zero emtries such as <xdb-fld-empty-fld/>.
    extractToken sRecString, "<xdb-fld-"
    Dim tpField As String
    Dim tpVal As String
    tpField = extractToken(sRecString, ">")
    tpVal = gXMLReader.convertFromUTF(extractToken(sRecString, "</xdb-fld-" & tpField & ">"), False)
    
    Dim tpLkpPos As Integer
    tpLkpPos = bSearchString(tpField, nFields, sOrdFieldNames)
    If (tpLkpPos >= 0) Then
      Dim tpFldIdx As Integer
      tpFldIdx = iOrdFieldIdx(tpLkpPos)
      
      If (tpVal = "") Then
        rs.Fields(tpFldIdx) = Null
      Else
        Select Case iFieldTypes(tpFldIdx)
          Case ftype_date
            If (Not IsDate(tpVal)) Then
              Err.Raise 1, , "The string: " & Chr(13) & tpVal & Chr(13) & "cannot be converted to a date."
            Else
              rs(tpFldIdx) = CDate(tpVal)
            End If
          Case ftype_log
            rs(tpFldIdx) = (tpVal = "true")
          Case ftype_num
            rs(tpFldIdx) = hzn(tpVal)
          Case ftype_dec
            rs(tpFldIdx) = val(tpVal)
          Case ftype_string
            rs(tpFldIdx) = hzn(tpVal)
        End Select
      End If 'if tpVal <> ""
    End If 'if tpLkpPos >= 0
  Wend
  rs.Update
Wend


appCleanRS rs

xdbWriteEncodedStringToTable = True
Exit Function

fout:
Dim errInf As ERR_INFO
appRecordError "xdbWriteEncodedStringToTable", errInf

appCleanRS rs

appDisplayError errInf
Exit Function
End Function