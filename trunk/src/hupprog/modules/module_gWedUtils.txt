Option Compare Database
Option Explicit

Type PROG_BASIC_INFO
  wednr As Long
  prognr As String
  Afstand As String
  slag As String
  cat As String
  catDes As String
  progType As String
  besAfw As String
  isEstaf As Boolean
  isMCat As Boolean
  isRank As Boolean
  isPnt As Boolean
  lim As String
  resLim As String
  vvt As Double
End Type

Type WED_BASIC_INFO
  wednr As Long
  isMeet As Boolean
  meetMainNr As Long
  date As Date
  avst As Date
  ageDate As Date
  lftBep As String
  baan As Integer
  des As String
  Plaats As String
  qlfConvMode As String
  qlfMinDate As Date
  qlfMaxDate As Date
  qlfRelayMode As String
  qlfBlockDis As Boolean
  qlfBlockTst As Boolean
  meetDes As String
  meetMinDate As Date
  meetMaxDate As Date
  sNationCode As String
End Type

Type VER_BASIC_INFO
  verName As String
  verDepot As String
  verPlaats As String
  verNationCode As String
End Type

Type ZWM_BASIC_INFO
  sStartnr As String
  sVer As String
  sVoornaam As String
  sVoegsel As String
  sAchternaam As String
  lYOB As Long
  dGebDate As Date
  sGes As String
End Type

Public Const DEL_CHOICE_ALL = 0
Public Const DEL_CHOICE_SINGLE_SWM = 1
Public Const DEL_CHOICE_LIST = 2
Public Const DEL_CHOICE_SINGLE_VER = 3


Private Const MAX_N_WEDS_IN_MRU_LIST = 5


Public Function wedSlagDescription(slag As String) As String
On Error Resume Next
Select Case slag
Case "School"
    wedSlagDescription = "school"
Case "RUG"
    wedSlagDescription = "rug"
Case "VRIJ"
    wedSlagDescription = "vrij"
Case "VLinder"
    wedSlagDescription = "vlinder"
Case "WISSEL"
    wedSlagDescription = "wissel"
Case Else
    wedSlagDescription = slag
End Select

End Function

Public Function wedProgApplySelection(blRestrictNummer As Boolean, nrMin As String, nrMax As String, blRestrictAf As Boolean, afString As String, blRestrictSlag As Boolean, slagString As String, blRestrictCat As Boolean, catString As String, blOnlyEstafs As Boolean, blOnlyPers As Boolean, blOnlyPrelims As Boolean, blOnlyFinals As Boolean, blOnlyBoys As Boolean, blOnlyGirls As Boolean, blOnlyMix As Boolean, blSelOverwrite As Boolean, blSelExtend As Boolean, blSelRestrict As Boolean, blUseValid As Boolean) As Boolean
On Error GoTo fout
wedProgApplySelection = False

'first have to parse the different strings and build a table.

Dim valAf(0 To 100) As String
Dim nValAf As Integer
nValAf = 0

Dim valSl(0 To 100) As String
Dim nValSl As Integer
nValSl = 0

Dim valCat(0 To 100) As String
Dim nValCat As Integer
nValCat = 0

Dim insPos As Integer


If (blRestrictAf) Then
  Dim tpAf As String
  tpAf = Trim(extractToken(afString, ","))
  While (nValAf < 100 And tpAf <> "")
    'Insert into the table.
   insPos = insString(tpAf, nValAf, valAf)
   If (insPos = -1) Then
     Err.Raise 1, , "Internal error. Error inserting string."
   End If
    tpAf = Trim(extractToken(afString, ","))
  Wend
End If

If (blRestrictSlag) Then
  Dim tpSl As String
  tpSl = Trim(extractToken(slagString, ","))
  While (nValSl < 100 And tpSl <> "")
    'Insert into the table.
   insPos = insString(tpSl, nValSl, valSl)
   If (insPos = -1) Then
     Err.Raise 1, , "Internal error. Error inserting string."
   End If
    tpSl = Trim(extractToken(slagString, ","))
  Wend
End If

If (blRestrictCat) Then
  Dim tpCat As String
  tpCat = Trim(extractToken(catString, ","))
  While (nValCat < 100 And tpCat <> "")
    'Insert into the table.
   insPos = insString(tpCat, nValCat, valCat)
   If (insPos = -1) Then
     Err.Raise 1, , "Internal error. Error inserting string."
   End If
    tpCat = Trim(extractToken(catString, ","))
  Wend
End If


Dim rs As Recordset
Set rs = CurrentDb().OpenRecordset("gSelProgs")

rs.MoveFirst
Do Until rs.EOF

  Dim blValid As Boolean
  
  
  blValid = True
  
  Dim tpProgType As String
  Dim tpAfstand As String
  Dim tpSlag As String
  'Dim tpCat As String
  Dim tpIsEstaf As Boolean
  Dim tpGes As String
  
  Dim tpValProg As Double
  
  tpProgType = Nz(rs("TP_ProgType"))
  tpAfstand = Nz(rs("TP_Afstand"))
  tpSlag = Nz(rs("TP_Slag"))
  tpCat = Nz(rs("TP_Categorie"))
  tpIsEstaf = Nz(rs("TP_IsEstaf"))
  tpGes = m_of_v(tpCat)
  
  tpValProg = val(Nz(rs("TP_Programmanummer")))
  
  Dim lkpPos As Integer
      
  'Now test all the conditions.
  If (blRestrictAf) Then
     lkpPos = bSearchString(tpAfstand, nValAf, valAf)
     If (lkpPos < 0) Then
       blValid = False
     End If
  End If
  
  If (blValid And blRestrictSlag) Then
    lkpPos = bSearchString(tpSlag, nValSl, valSl)
    If (lkpPos < 0) Then
      blValid = False
    End If
  End If
  
  If (blValid And blRestrictCat) Then
    lkpPos = bSearchString(tpCat, nValCat, valCat)
    If (lkpPos < 0) Then
      blValid = False
    End If
  End If
  
  If (blValid And blRestrictNummer) Then
    If (nrMin <> "") Then
      If (tpValProg < val(nrMin)) Then
        blValid = False
      End If
    End If
    If (nrMax <> "") Then
      If (tpValProg > val(nrMax)) Then
        blValid = False
      End If
    End If
  End If
  
  If (blValid And blOnlyEstafs) Then
    If (Not tpIsEstaf) Then
      blValid = False
    End If
  End If
  
  If (blValid And blOnlyPers) Then
    If (tpIsEstaf) Then
      blValid = False
    End If
  End If
  
  If (blValid And blOnlyBoys) Then
    If (tpGes <> "M") Then
      blValid = False
    End If
  End If
  
  If (blValid And blOnlyGirls) Then
    If (tpGes <> "V") Then
      blValid = False
    End If
  End If
  
  If (blValid And blOnlyMix) Then
    If (tpGes <> "*") Then
      blValid = False
    End If
  End If
  
  If (blValid And blOnlyPrelims) Then
    If (Not finIsFirstRound(tpProgType)) Then
      blValid = False
    End If
  End If
  
  If (blValid And blOnlyFinals) Then
    If (finIsFirstRound(tpProgType)) Then
      blValid = False
    End If
  End If
  
  Dim blCurSelStatus As Boolean
  blCurSelStatus = Nz(rs("TP_TeltMee"))
  Dim blNewSelStatus As Boolean
  blNewSelStatus = selGetNewStatus(blCurSelStatus, blValid, blSelOverwrite, blSelExtend, blSelRestrict, blUseValid)
  
  If (blNewSelStatus <> blCurSelStatus) Then
    rs.Edit
    rs("TP_TeltMee") = blNewSelStatus
    rs.Update
  End If
  


  rs.MoveNext
Loop





wedProgApplySelection = True
Exit Function
fout:
If (Err = 3021) Then Resume Next ' no current record.
MsgBox Err & " " & Error$, 16
Exit Function
End Function





Public Function abcNRGeslacht(gesl As String) As Integer
On Error Resume Next
abcNRGeslacht = 1
If gesl = "M" Then
    abcNRGeslacht = 1
Else
    abcNRGeslacht = 2
End If
End Function

Public Function abcVerdelen(blEmpty As Boolean, blUseTime As Boolean, sSneller As String, sLangzamer As String, sLimiet As String, blHuidig As Boolean, blEntireMeet As Boolean, curProg As String, ByVal curWedAgeDate As Date, ByVal curWedLftMode As String, curWedNr As Long, curMeetMainNr As Long) As Boolean
On Error GoTo fout
abcVerdelen = False

If blUseTime Then
  If Not abcVerdelenTijden(sSneller, sLangzamer, sLimiet, blHuidig, blEntireMeet, curProg, curWedAgeDate, curWedLftMode, curWedNr, curMeetMainNr) Then
    Exit Function
  End If
Else
  If Not abcVerdelenLeeftijden(blEmpty, blHuidig, blEntireMeet, curProg, curWedAgeDate, curWedLftMode, curWedNr, curMeetMainNr) Then
    Exit Function
  End If
  If Not abcPostLftUpdate(blEmpty, blHuidig, blEntireMeet, curProg, curWedNr, curMeetMainNr) Then
    Exit Function
  End If
End If

abcVerdelen = True
Exit Function
fout:
MsgBox Err & " " & Error$, 16
Exit Function
End Function


Public Function lftGenerateMasters() As Boolean
On Error GoTo fout
lftGenerateMasters = False


Dim cats(0 To 100) As String
Dim codes(0 To 100) As String
Dim nCats As Integer
nCats = 0

cats(0) = "J20-24JR"
codes(0) = "20+"

cats(1) = "J25-29JR"
codes(1) = "25+"

cats(2) = "J30-34JR"
codes(2) = "30+"

cats(3) = "J35-40JR"
codes(3) = "35+"

cats(4) = "J40-44JR"
codes(4) = "40+"

cats(5) = "J45-50JR"
codes(5) = "45+"

cats(6) = "J50-54JR"
codes(6) = "50+"

cats(7) = "J55-59JR"
codes(7) = "55+"

cats(8) = "J60-64JR"
codes(8) = "60+"

cats(9) = "J65-69JR"
codes(9) = "65+"

cats(10) = "J70-74JR"
codes(10) = "70+"

cats(11) = "J75-79JR"
codes(11) = "75+"

cats(12) = "J80-84JR"
codes(12) = "80+"

cats(13) = "J85-89JR"
codes(13) = "85+"

cats(14) = "J90-94JR"
codes(14) = "90+"

cats(15) = "J95EO"
codes(15) = "95+"



cats(16) = "M20-24JR"
codes(16) = "20+"

cats(17) = "M25-29JR"
codes(17) = "25+"

cats(18) = "M30-34JR"
codes(18) = "30+"

cats(19) = "M35-40JR"
codes(19) = "35+"

cats(20) = "M40-44JR"
codes(20) = "40+"

cats(21) = "M45-50JR"
codes(21) = "45+"

cats(22) = "M50-54JR"
codes(22) = "50+"

cats(23) = "M55-59JR"
codes(23) = "55+"

cats(24) = "M60-64JR"
codes(24) = "60+"

cats(25) = "M65-69JR"
codes(25) = "65+"

cats(26) = "M70-74JR"
codes(26) = "70+"

cats(27) = "M75-79JR"
codes(27) = "75+"

cats(28) = "M80-84JR"
codes(28) = "80+"

cats(29) = "M85-89JR"
codes(29) = "85+"

cats(30) = "M90EO"
codes(30) = "90+"

cats(31) = "M95EO"
codes(31) = "95+"



cats(32) = "J80-99JRT"
codes(32) = "80+"

cats(33) = "J100-119JRT"
codes(33) = "100+"

cats(34) = "J120-159JRT"
codes(34) = "120+"

cats(35) = "J160-199JRT"
codes(35) = "160+"

cats(36) = "J200-239JRT"
codes(36) = "200+"

cats(37) = "J240-279JRT"
codes(37) = "240+"

cats(38) = "J280-319JRT"
codes(38) = "280+"

cats(39) = "J320-359JRT"
codes(39) = "320+"

cats(40) = "J360EOT"
codes(40) = "360+"


'meisjes totaal
cats(41) = "M80-99JRT"
codes(41) = "80+"

cats(42) = "M100-119JRT"
codes(42) = "100+"

cats(43) = "M120-159JRT"
codes(43) = "120+"

cats(44) = "M160-199JRT"
codes(44) = "160+"

cats(45) = "M200-239JRT"
codes(45) = "200+"

cats(46) = "M240-279JRT"
codes(46) = "240+"

cats(47) = "M280-319JRT"
codes(47) = "280+"

cats(48) = "M320-359JRT"
codes(48) = "320+"

cats(49) = "M360EOT"
codes(49) = "360+"



'meisjes jongens totaal
cats(50) = "MJ80-99JRT"
codes(50) = "80+"

cats(51) = "MJ100-119JRT"
codes(51) = "100+"

cats(52) = "MJ120-159JRT"
codes(52) = "120+"

cats(53) = "MJ160-199JRT"
codes(53) = "160+"

cats(54) = "MJ200-239JRT"
codes(54) = "200+"

cats(55) = "MJ240-279JRT"
codes(55) = "240+"

cats(56) = "MJ280-319JRT"
codes(56) = "280+"

cats(57) = "MJ320-359JRT"
codes(57) = "320+"

cats(58) = "MJ360EOT"
codes(58) = "360+"






nCats = 58



Dim sql As String
sql = "delete * from [glft];"

DoCmd.SetWarnings False
DoCmd.RunSQL sql
DoCmd.SetWarnings True

Dim rs As Recordset
Set rs = CurrentDb().OpenRecordset("glft")


Dim i As Integer
For i = 0 To nCats - 1
  rs.AddNew
    rs("LFT_Categorie") = cats(i)
    rs("LFT_BeschrijvingCategorie") = hzn(catBeschrijvingMooi(cats(i)))
    rs("LFT_Code") = codes(i)
  rs.Update
Next i



lftGenerateMasters = True
Exit Function
fout:
MsgBox Err & " " & Error$, 16
DoCmd.SetWarnings True
Exit Function

End Function
Public Function lftClearAll() As Boolean
On Error GoTo fout
lftClearAll = False

DoCmd.SetWarnings False
DoCmd.RunSQL "delete * from [gLft];"
DoCmd.SetWarnings True

lftClearAll = True
Exit Function
fout:
MsgBox Err & " " & Error$, 16
DoCmd.SetWarnings True
Exit Function
End Function


Public Function abcVerdelenLeeftijden(blEmpty As Boolean, blHuidig As Boolean, blEntireMeet As Boolean, curProg As String, ByVal curWedAgeDate As Date, ByVal curWedLftMode As String, curWedNr As Long, curMeetMainNr As Long) As Boolean
On Error GoTo fout
abcVerdelenLeeftijden = False
Dim sql As String


sql = wedGetABCSQL(blHuidig, blEntireMeet, curProg, curWedNr, curMeetMainNr)


Dim deeln As Recordset, cat As Recordset
Dim jaar As Integer, tpLeeftijd As Integer
Dim gevonden As Boolean
Dim codes(1 To 100, 1 To 2) 'M = 1 , V = 2
'initialiseren
Dim i

jaar = CInt(Format(Nz(curWedAgeDate, Now()), "yyyy"))

'Me.RecordSource = ""

'Set mydb = CurrentDb()
Set deeln = CurrentDb().OpenRecordset(sql, dbOpenDynaset)

Set cat = CurrentDb().OpenRecordset("select * from [dtgCatCodes] where [ct_wedstrijdnummer]=" & curWedNr, dbOpenDynaset)

deeln.MoveFirst


Dim curInfoWed As Long
curInfoWed = -1

Dim tpInfoWed As Long


If Not blEmpty Then
Do Until deeln.EOF

    tpInfoWed = Nz(deeln(FNM_DE_PERS_WEDNR))
    If (tpInfoWed <> curInfoWed) Then
      'Initialize codes
      For i = 1 To 100
        codes(i, 1) = "?"
        codes(i, 2) = "?"
      Next i

      If (blEntireMeet And Not blHuidig) Then
        'recalculate curWedLftMode and curWedDate
        curWedLftMode = wedLkpLftBep(tpInfoWed)
        curWedAgeDate = wedLkpAgeDate(tpInfoWed)
      End If
    
      curInfoWed = tpInfoWed
    End If

    If Nz(deeln(FNM_DE_PERS_STARTNR)) <> "00-000" And Nz(deeln(FNM_DE_PERS_STARTNR)) <> "" Then
        tpLeeftijd = jaar - (CInt(Left(deeln(FNM_DE_PERS_STARTNR), 2)) + 1900)
        If tpLeeftijd > 100 Then tpLeeftijd = tpLeeftijd - 100
        If codes(tpLeeftijd, abcNRGeslacht(deeln(FNM_NA_GES))) = "?" Then
            cat.MoveFirst
            gevonden = False
            Do Until gevonden Or cat.EOF
                If cat_voldoet_bare(Nz(deeln(FNM_DE_PERS_STARTNR)), Nz(cat("CT_Categorie")), Nz(deeln(FNM_NA_GES)), Nz(deeln(FNM_NA_GEBDAT), #1/1/1900#), curWedLftMode, False, curWedAgeDate) = CAT_OK Then
                    codes(tpLeeftijd, abcNRGeslacht(deeln(FNM_NA_GES))) = cat("CT_Code")
                    gevonden = True
                End If
                cat.MoveNext
            Loop
            If Not gevonden Then
                codes(tpLeeftijd, abcNRGeslacht(deeln(FNM_NA_GES))) = ""
            End If
        End If
        If Not codes(tpLeeftijd, abcNRGeslacht(deeln(FNM_NA_GES))) = "" Then
            deeln.Edit
            deeln(FNM_DE_PERS_ABC) = codes(tpLeeftijd, abcNRGeslacht(deeln(FNM_NA_GES)))
            deeln.Update
        End If
        
            
    
    End If

    deeln.MoveNext
Loop
Else ' leeg maken
    Do Until deeln.EOF
        deeln.Edit
        deeln(FNM_DE_PERS_ABC) = Null
        deeln.Update
        deeln.MoveNext
    Loop
End If

abcVerdelenLeeftijden = True
Exit Function
fout:
If (Err = 3021) Then Resume Next  ' no current record.

MsgBox Err & " " & Error$, 16


'debug
On Error GoTo 0
Resume


Exit Function

End Function

Public Function abcVerdelenTijden(sSneller As String, sLangzamer As String, sLimiet As String, blHuidig As Boolean, blEntireMeet As Boolean, curProg As String, ByVal curWedAgeDate As Date, ByVal curWedLftMode As String, curWedNr As Long, curMeetMainNr As Long) As Boolean
On Error GoTo fout
abcVerdelenTijden = False


Dim sql As String


sql = wedGetABCSQL(blHuidig, blEntireMeet, curProg, curWedNr, curMeetMainNr)

Dim deeln As Recordset, cat As Recordset
Dim jaar As Integer, tpLeeftijd As Integer







Set deeln = CurrentDb().OpenRecordset(sql, dbOpenDynaset)


deeln.MoveFirst

Dim tplimiet


Dim limS As String


Dim varProgNames(0 To MAX_N_PROGS) As String
Dim varProgOffs(0 To MAX_N_PROGS) As Integer
Dim varProgCatCnts(0 To MAX_N_PROGS) As Integer
Dim varCatInfo(0 To MAX_N_VAR_CATS) As CAT_INFO
Dim nVarProgs As Integer

Dim dummy(0 To 0) As String



Dim curInfoWedNr As Long
curInfoWedNr = -1
Dim tpInfoWedNr As Long



Do Until deeln.EOF

    tpInfoWedNr = Nz(deeln(FNM_DE_PERS_WEDNR))
    
    If (tpInfoWedNr <> curInfoWedNr) Then
      
      If (blEntireMeet And Not blHuidig) Then
        'recalculate curWedLftMode and curWedDate
        curWedLftMode = wedLkpLftBep(tpInfoWedNr)
        curWedAgeDate = wedLkpDate(tpInfoWedNr)
      End If
      
      
      If Not catInfoGetListForWed(tpInfoWedNr, nVarProgs, varProgNames, dummy, varProgOffs, varProgCatCnts, varCatInfo, False) Then
        Exit Function
      End If
      curInfoWedNr = tpInfoWedNr
    End If


    Dim tpStart As String
    tpStart = Nz(deeln(FNM_DE_PERS_STARTNR))
    
    Dim tpGes As String
    tpGes = Nz(deeln(FNM_NA_GES))
    
    Dim tpGebDat As Date
    tpGebDat = Nz(deeln(FNM_NA_GEBDAT), #1/1/1900#)

    Dim prAfstand As String
    prAfstand = Nz(deeln(FNM_PR_AF))
    



    If (Not prAfstand Like "*x*") Then
        If (Nz(deeln(FNM_DE_PERS_STARTNR) <> "00-000") And (Nz(deeln(FNM_DE_PERS_STARTNR)) <> "")) Then
        
            Dim tpProg As String
            tpProg = Nz(deeln(FNM_DE_PERS_PROG))
            
            
        
        
            If sLimiet = "" Or Not blHuidig Then 'veld opmerking gebruiken
                
                'First find limit.
                limS = ""
                
                'First try varCatInfo
                If (catIsMCat(Nz(deeln(FNM_PR_CAT)))) Then
                   Dim varCatIdx As Integer
                   varCatIdx = catInfoGetSatisfiedCatIdx(curWedAgeDate, curWedLftMode, tpProg, tpStart, tpGes, tpGebDat, nVarProgs, varProgNames, varProgOffs, varProgCatCnts, varCatInfo)
                   
                  If (varCatIdx <> -1) Then
                    limS = Trim(Nz(varCatInfo(varCatIdx).lim))
                  End If
                End If
                
                If (limS = "") Then
                  limS = Nz(deeln(FNM_PR_LIM), "")
                End If
                If (limS = "") Then
                  limS = Nz(deeln(FNM_PR_OPM))
                End If
                
                tplimiet = limGetMiddle(limS)
                
                
                'tplimiet = tussenlimiet(deeln("opmerking"))
            Else
                tplimiet = limParseTijd(sLimiet)
            End If
                    
           If tplimiet > 1 Then
             Dim insTd As Double
             insTd = Nz(deeln(FNM_DE_PERS_INSTD))
           
            If insTd > 1 And insTd <= tplimiet + LIMEPS Then
                deeln.Edit
                deeln(FNM_DE_PERS_ABC) = sSneller
                deeln.Update
            Else
                deeln.Edit
                deeln(FNM_DE_PERS_ABC) = sLangzamer
                deeln.Update
            End If
           End If '(Alleen doen als tplimiet > 0)
            
                
        
        End If
    End If
    deeln.MoveNext
Loop


abcVerdelenTijden = True
Exit Function
fout:

If (Err = 3021) Then Resume Next  ' no current record.

MsgBox Err & " " & Error$, 16
Exit Function
'debug
On Error GoTo 0
Resume

Exit Function

End Function




Public Function lftVerdelen(blDeleteAll As Boolean, blDeleteExisting As Boolean, blEstafUseTotalAge, blOnlyEmpty As Boolean, blOnlyMVar As Boolean, blHuidig As Boolean, blMeet As Boolean, curProg As String, curWedNr As Long, curMeetNr As Long) As Boolean
On Error GoTo fout
lftVerdelen = False




Dim sql As String



'First delete the leeftijdsgroepen that need to be deleted.

If (blDeleteAll Or (blDeleteExisting And (blHuidig Or (Not blOnlyEmpty)))) Then
  'delete all the leeftijdsgroepen
  sql = wedGetLftSQL(blHuidig, blMeet, curProg, curWedNr, curMeetNr, True)
  'get rid of the select clause.
  extractToken sql, " "
  'turn into 'delete statement
  sql = "Delete " & sql
  
  DoCmd.SetWarnings False
  DoCmd.RunSQL sql
  DoCmd.SetWarnings True
End If

'We are done if all we needed to do was delete everything.
If (blDeleteAll) Then
  lftVerdelen = True
  Exit Function
End If


sql = wedGetProgsSQL(blHuidig, blMeet, curProg, curWedNr, curMeetNr, True, False)

Dim rsProgs As Recordset

Set rsProgs = CurrentDb().OpenRecordset(sql)

sql = wedGetLftSQL(blHuidig, blMeet, curProg, curWedNr, curMeetNr, True)
'sql = sql & " ORDER BY wedstrijdnr, programmanummer;"

Dim rsLft As Recordset
Set rsLft = CurrentDb().OpenRecordset(sql)


Dim rsAllLft As Recordset
Set rsAllLft = CurrentDb().OpenRecordset("dtProgrammaLeeftijdsgroepen")
rsAllLft.Index = "PrimaryKey"


Dim rsCat As Recordset
Set rsCat = CurrentDb().OpenRecordset("select * from [gLft];")


rsProgs.MoveFirst

Do Until rsProgs.EOF
  
  
  Dim blProcess As Boolean
  blProcess = True
  
  Dim tpProgCat As String
  Dim tpWedNr As Long
  Dim tpProg As String
  
  
  tpWedNr = Nz(rsProgs(FNM_PR_WED))
  tpProg = Nz(rsProgs(FNM_PR_PROG))
  
  tpProgCat = Nz(rsProgs(FNM_PR_CAT))
  
  If (Not blHuidig) And ((Not catIsMCat(tpProgCat)) And blOnlyMVar) Then
    blProcess = False
  End If
  
  Dim blHasLft As Boolean
  blHasLft = False
  
  If (blProcess And (Not blHuidig)) Then
    rsLft.FindFirst FNM_PRL_WED & "=" & tpWedNr & " and " & FNM_PRL_PROG & "=""" & tpProg & """"
    blHasLft = Not rsLft.NoMatch
    
    If (blHasLft And blOnlyEmpty) Then
      blProcess = False
    End If
  End If
  
  
  If (blProcess) Then
  
    
  
    'Process the current programmanummer.
    Dim tpIsEstaf As Boolean
    tpIsEstaf = Nz(rsProgs(FNM_PR_AF)) Like "*x*"
    Dim tpProgGes As String
    tpProgGes = m_of_v(tpProgCat)
    
    
    If (Not catIsMCat(tpProgCat)) Then
      rsProgs.Edit
        Dim newCat As String
        newCat = catCreateMCat(tpProgGes)
        rsProgs(FNM_PR_CAT) = hzn(newCat)
        rsProgs(FNM_PR_BESCAT) = hzn(catBeschrijving(newCat))
      rsProgs.Update
    End If
    
    
    rsCat.MoveFirst
    Do Until rsCat.EOF
      Dim blProcessCat As Boolean
      blProcessCat = True
      
      Dim tpCat As String
      tpCat = Nz(rsCat("LFT_Categorie"))
      Dim tpBesCat As String
      tpBesCat = Nz(rsCat("LFT_BeschrijvingCategorie"))
      Dim tpCatCode As String
      tpCatCode = Nz(rsCat("LFT_Code"))
      Dim tpGes As String
      tpGes = m_of_v(tpCat)
      
      Dim tpCatIsEstafTotAge As Boolean
      tpCatIsEstafTotAge = catIsEstafTotalAge(tpCat)
      
      
      
      If (tpIsEstaf) Then
        If (tpGes <> tpProgGes) Then
          blProcessCat = False
        ElseIf (blEstafUseTotalAge = (Not tpCatIsEstafTotAge)) Then
          blProcessCat = False
        End If
      Else
        If (tpCatIsEstafTotAge) Then
          blProcessCat = False
        End If
        If (blProcessCat) Then
          If (tpProgGes = "*") Then
            If (tpGes = "*") Then
              blProcessCat = False
            End If
          Else
             If (tpGes <> tpProgGes) Then
               blProcessCat = False
              End If
          End If
        End If
      End If
      
      If blProcessCat Then
      
        rsAllLft.Seek "=", tpWedNr, tpProg, tpCat
        
        If rsAllLft.NoMatch Then
          rsLft.AddNew
            rsLft(FNM_PRL_WED) = tpWedNr
            rsLft(FNM_PRL_PROG) = hzn(tpProg)
            rsLft(FNM_PRL_CAT) = hzn(tpCat)
            rsLft(FNM_PRL_BESCAT) = hzn(tpBesCat)
            rsLft(FNM_PRL_CODE) = hzn(tpCatCode)
          rsLft.Update
        End If
      End If

    
    
      rsCat.MoveNext
    Loop
    
    
    
    
  End If


  rsProgs.MoveNext
Loop



lftVerdelen = True
Exit Function
fout:
If (Err = 3021) Then Resume Next ' no current record
MsgBox Err & " " & Error$, 16
Exit Function
'debug
On Error GoTo 0
Resume Next
End Function


Public Function qsLenexCmdLine() As Boolean
On Error Resume Next

qsLenexCmdLine = False

Dim lxfFName As String
lxfFName = Command()

If FileExists(lxfFName) Then
  If Not lenHandleCompleteImportSequence(extractFilePath(lxfFName), extractFileName(lxfFName), _
    False, -1, #1/1/1900#, #12:00:00 AM#, False, -1) Then
    Exit Function
  End If
End If

qsLenexCmdLine = True
Exit Function

End Function


Public Function qsLenex() As Boolean
On Error Resume Next
qsLenex = False

If Not (lenQuickStart(Nz(dbdir_op()))) Then
  Exit Function
End If
qsLenex = True
End Function

Public Function qsBackup() As Boolean
On Error Resume Next
backup
qsBackup = True
End Function

Public Function qsImpKNZB() As Boolean
On Error Resume Next
DoCmd.OpenForm "gImpKNZB", , , , , acDialog
End Function

Public Function qsImpKNZBStandardMeet() As Boolean
On Error Resume Next
DoCmd.OpenForm "gWIZ_WL_MASTER", , , , , acDialog
End Function



Private Function prReadInfo(ByRef rs As Recordset, ByRef prInfo As PROG_BASIC_INFO) As Boolean
On Error GoTo fout
prReadInfo = False

prInfo.prognr = Nz(rs(FNM_PR_PROG))
prInfo.wednr = Nz(rs(FNM_PR_WED))
prInfo.Afstand = Nz(rs(FNM_PR_AF))
prInfo.slag = Nz(rs(FNM_PR_SL))
prInfo.cat = Nz(rs(FNM_PR_CAT))
prInfo.catDes = Nz(rs(FNM_PR_BESCAT))
prInfo.besAfw = Nz(rs(FNM_PR_BESAFW))

prInfo.isEstaf = prInfo.Afstand Like "*x*"
prInfo.isMCat = catIsMCat(prInfo.cat)

prInfo.progType = Nz(rs(FNM_PR_TYPE))
prInfo.isRank = prInfo.progType = PROG_TYPE_RANKING
prInfo.isPnt = prInfo.progType = PROG_TYPE_PUNT


prInfo.vvt = Nz(rs(FNM_PR_VVT))
prInfo.lim = Nz(rs(FNM_PR_LIM))
prInfo.resLim = Nz(rs(FNM_PR_LIM_RES))

prReadInfo = True
Exit Function
fout:
MsgBox Err & " prReadInfo" & vbCrLf & Error$, 16
Exit Function
End Function

Public Function prLookupNext(ByVal wednr As Long, ByVal prognr As String, ByRef isFound As Boolean, ByRef prInfo As PROG_BASIC_INFO) As Boolean
prLookupNext = prLookup_Perform(wednr, prognr, 1, isFound, prInfo)
End Function

Public Function prLookupPrevious(ByVal wednr As Long, ByVal prognr As String, ByRef isFound As Boolean, ByRef prInfo As PROG_BASIC_INFO) As Boolean
prLookupPrevious = prLookup_Perform(wednr, prognr, -1, isFound, prInfo)
End Function

Public Function prLookup(ByVal wednr As Long, ByVal prognr As String, ByRef isFound As Boolean, ByRef prInfo As PROG_BASIC_INFO) As Boolean
prLookup = prLookup_Perform(wednr, prognr, 0, isFound, prInfo)
End Function

Private Function prLookup_Perform(ByVal wednr As Long, ByVal prognr As String, ByVal direction As Integer, ByRef isFound As Boolean, ByRef prInfo As PROG_BASIC_INFO) As Boolean
On Error GoTo fout
prLookup_Perform = False

isFound = False

Dim rs As Recordset

Dim sql As String

If (direction = 0) Then
  sql = wedGetProgsSQL(True, False, prognr, wednr, -1, False, False)
Else
  sql = wedGetProgsSQL(False, False, "", wednr, -1, False, True)
End If

Set rs = CurrentDb().OpenRecordset(sql)

If (direction = 0) Then
  rs.MoveFirst
  If (Not rs.EOF) Then
    If Not prReadInfo(rs, prInfo) Then
      Exit Function
    End If
    isFound = True
  End If
Else
  rs.FindFirst "[" & FNM_PR_WED & "] = " & wednr & " and [" & FNM_PR_PROG & "] = """ & prognr & """ "
  If Not rs.NoMatch Then
    If (direction < 0) Then
      rs.MovePrevious
    Else
      rs.MoveNext
    End If
    If (Not rs.BOF) And (Not rs.EOF) Then
      If Not prReadInfo(rs, prInfo) Then
        Exit Function
      End If
      isFound = True
    End If
  End If
End If

  



'Set rs = c



prLookup_Perform = True
Exit Function
fout:
If (Err = 3021) Then Resume Next
MsgBox Err & " prLookup_Perform" & vbCrLf & Error$, 16
Exit Function
'debug
On Error GoTo 0
Resume
End Function


Public Function prPromptUser(ByVal wednr As Long, ByRef isOK As Boolean, ByRef lkpWedNr As Long, ByRef lkpProgNr As String) As Boolean
On Error GoTo fout
prPromptUser = False


Dim sql As String
sql = "Delete * from gProgOpzoek;"
DoCmd.SetWarnings False
DoCmd.RunSQL sql
DoCmd.SetWarnings True

Dim rs As Recordset
Set rs = CurrentDb().OpenRecordset("gProgOpzoek")

rs.AddNew
  rs("PO_ARG_Wedstrijdnummer") = wednr
  rs("PO_OK") = False
rs.Update

rs.Close

DoCmd.OpenForm "hxProgOpzoek", , , , , acDialog

Set rs = CurrentDb().OpenRecordset("gProgOpzoek")

rs.MoveFirst
If rs.EOF Then
  Err.Raise 1, , "Intern probleem. Tabel gProgOpzoek is leeg."
End If

isOK = Nz(rs("PO_OK"))


lkpProgNr = Nz(rs("PO_Programmanummer"))
lkpWedNr = Nz(rs("PO_Wedstrijdnummer"))

rs.Close

prPromptUser = True
Exit Function
fout:
If (Err = 3021) Then Resume Next ' no current record
MsgBox Err & " prPromptUser" & vbCrLf & Error$, 16
DoCmd.SetWarnings True
Exit Function
End Function


Public Function wedSuggestBaseFName() As String
On Error Resume Next
wedSuggestBaseFName = Format(Nz(wed_datum(), #1/1/1900#), "yyyy\-mm\-dd") & "=" & GoedTekens(Nz(wed_plaats())) & "-" & GoedTekens(Nz(wed_beschrijving()))
End Function

Public Function wedSuggestBaseFNameMeet() As String
On Error Resume Next
wedSuggestBaseFNameMeet = "onbekend"
Dim blFnd As Boolean, wedInf As WED_BASIC_INFO
If Not wedLookup(waarde(), blFnd, wedInf) Then
  Exit Function
End If
If Not blFnd Then
  Exit Function
End If
wedSuggestBaseFNameMeet = Format(Nz(wedInf.meetMinDate, #1/1/1900#), "yyyy\-mm\-dd") & "=" & GoedTekens(wedInf.Plaats) & "-" & GoedTekens(wedInf.meetDes)
End Function


Private Function prReadProgList(ByRef sProgList As String) As Boolean
On Error GoTo fout
prReadProgList = False

sProgList = ""
Dim rs As Recordset
Set rs = CurrentDb().OpenRecordset("select * from [gSelProgs] order by [tp_programmanummer]")

rs.MoveFirst
Do Until rs.EOF
  If Nz(rs("TP_TeltMee"), False) Then
    If (Len(sProgList) > 0) Then
      sProgList = sProgList & "; "
    End If
    sProgList = sProgList & Nz(rs("TP_Programmanummer"))
  End If
  rs.MoveNext
Loop


prReadProgList = True
Exit Function
fout:
If (Err = 3021) Then Resume Next
MsgBox Err & " prReadProgList" & vbCrLf & Error$, 16
Exit Function
End Function


Private Function prWriteProgList(ByVal sProgList As String) As Boolean
On Error GoTo fout
prWriteProgList = False


Dim sProgs(0 To 1000) As String
Dim nProgs As Integer

nProgs = 0
Dim tpTok As String
tpTok = Trim(extractToken(sProgList, ";"))
While (Len(tpTok) > 0)
   insString tpTok, nProgs, sProgs
   tpTok = Trim(extractToken(sProgList, ";"))
Wend

Dim rs As Recordset
Set rs = CurrentDb().OpenRecordset("select * from [gSelProgs] order by tp_programmanummer")

Dim idx As Integer
idx = 0

rs.MoveFirst
Do Until rs.EOF
  Dim tpProg As String
  Dim blTeltMee As Boolean
  
  blTeltMee = False
  
  tpProg = Nz(rs("TP_Programmanummer"))
  
  
  
  Dim tpDone As Boolean
  tpDone = (idx >= nProgs)
  If (Not tpDone) Then
    tpDone = StrComp(sProgs(idx), tpProg) >= 0
  End If
  While (Not tpDone)
    idx = idx + 1
    
    tpDone = (idx >= nProgs)
    If (Not tpDone) Then
      tpDone = StrComp(sProgs(idx), tpProg) >= 0
    End If
  Wend
  
  
  
  If (idx < nProgs) Then
    If (StrComp(sProgs(idx), tpProg) = 0) Then
      blTeltMee = True
    End If
  End If
  
  rs.Edit
    rs("TP_Teltmee") = blTeltMee
  rs.Update
  
  rs.MoveNext
Loop


prWriteProgList = True
Exit Function
fout:
If (Err = 3021) Then Resume Next
MsgBox Err & " prWriteProgList" & vbCrLf & Error$, 16
Exit Function
End Function

Public Function prWriteProgListToProgTabel(ByVal wednr As Long, ByVal meetMainNr As Long, ByVal blMeet As Boolean, ByRef sProgList As String) As Boolean
On Error GoTo fout
prWriteProgListToProgTabel = False

If Not wedProgTabelVullen(meetMainNr, wednr, blMeet, False, "", "") Then
  Exit Function
End If

If Not prWriteProgList(sProgList) Then
  Exit Function
End If


prWriteProgListToProgTabel = True
Exit Function
fout:
MsgBox Err & " prWriteProgListToProgTabel" & vbCrLf & Error$, 16
Exit Function

End Function


Public Function prEditProgList(ByVal wednr As Long, ByVal meetMainNr As Long, ByVal blMeet As Boolean, ByRef sProgList As String, ByVal blRestrict As Boolean, ByVal restrictSlag As String, ByVal restrictAfstand As String) As Boolean
On Error GoTo fout
prEditProgList = False

If Not wedProgTabelVullen(meetMainNr, wednr, blMeet, blRestrict, restrictSlag, restrictAfstand) Then
  Exit Function
End If

If Not prWriteProgList(sProgList) Then
  Exit Function
End If

DoCmd.OpenForm "gMeetellendeProgrammas", , , , , acDialog, "EntireMeet"

If Not prReadProgList(sProgList) Then
  Exit Function
End If




prEditProgList = True
Exit Function
fout:
MsgBox Err & " prEditList" & vbCrLf & Error$, 16
Exit Function
End Function

Private Function abcWriteABCList(ByVal sAbcList As String) As Boolean
On Error GoTo fout
abcWriteABCList = False

Dim sql As String

sql = "Delete * from [gTempabc];"
DoCmd.SetWarnings False
DoCmd.RunSQL sql
DoCmd.SetWarnings True



'process abc list
Dim sABC(0 To 1000) As String
Dim nABC As Integer

nABC = 0
Dim tpTok As String
tpTok = Trim(extractToken(sAbcList, ";"))
While (Len(tpTok) > 0)
   insString tpTok, nABC, sABC
   tpTok = Trim(extractToken(sAbcList, ";"))
Wend

Dim rs As Recordset
Set rs = CurrentDb().OpenRecordset("gTempabc")


Dim prevABC As String

prevABC = "-------"

Dim i As Integer

For i = 0 To nABC - 1
  If (sABC(i) <> prevABC) Then
    rs.AddNew
    rs("TP_ABC") = sABC(i)
    rs.Update
    prevABC = sABC(i)
  End If
Next i

appCleanRS rs

abcWriteABCList = True
Exit Function
fout:
MsgBox Err & " abcWriteABCList" & vbCrLf & Error$, 16
Exit Function
End Function

Private Function abcReadABCList(ByRef sAbcList As String) As Boolean
On Error GoTo fout
abcReadABCList = False

Dim rs As Recordset
Set rs = CurrentDb().OpenRecordset("select * from [gTempabc] order by [tp_abc]")

sAbcList = ""
Do Until rs.EOF
  Dim tpABC As String
  tpABC = Nz(rs("TP_ABC"))
  If (Len(sAbcList) > 0) Then
    sAbcList = sAbcList & "; "
  End If
  sAbcList = sAbcList & tpABC
  rs.MoveNext
Loop


abcReadABCList = True
Exit Function
fout:
MsgBox Err & " abcWriteABCList" & vbCrLf & Error$, 16
Exit Function
End Function


Public Function abcEditABCList(ByRef abcList As String) As Boolean
On Error GoTo fout
abcEditABCList = False

If Not abcWriteABCList(abcList) Then
  Exit Function
End If

DoCmd.OpenForm "gMeetellendeABC", , , , , acDialog

If Not abcReadABCList(abcList) Then
  Exit Function
End If


abcEditABCList = True
Exit Function
fout:
MsgBox Err & " abcEditABCList" & Error$, 16
Exit Function
End Function






'return the insertion position
Public Function insProg(ByVal inswednr As Long, ByVal insProgNr As String, ByRef cnt As Integer, ByRef pWedNrs() As Long, ByRef pProgNrs() As String) As Integer
On Error GoTo fout
insProg = -1
Dim insPos As Integer
insPos = cnt
Dim done As Boolean
done = (insPos = 0)
While (Not done)
  If (pWedNrs(insPos - 1) > inswednr) Then
    done = False
  ElseIf (pWedNrs(insPos - 1) = inswednr) And (pProgNrs(insPos - 1) > insProgNr) Then
    done = False
  Else
    done = True
  End If
  
  If (Not done) Then
    pWedNrs(insPos) = pWedNrs(insPos - 1)
    pProgNrs(insPos) = pProgNrs(insPos - 1)
    insPos = insPos - 1
  End If
    
  If (insPos = 0) Then
    done = True
  End If
Wend

pWedNrs(insPos) = inswednr
pProgNrs(insPos) = insProgNr
cnt = cnt + 1

insProg = insPos

Exit Function
fout:
MsgBox Err & " " & Error$, 16

End Function

Public Function bSearchProg(ByVal wednrToFind As Long, ByVal progToFind As String, ByRef pWedNrs() As Long, ByRef pProgs() As String, ByRef nProgs) As Integer
On Error GoTo fout
bSearchProg = -1

'need to perform binary search on (wednrToFind, progToFind) pair.
Dim l As Integer, r As Integer, m As Integer
l = 0
r = nProgs
While (r > l)
 m = (l + r) \ 2
 
 Dim comp As Integer
 If (wednrToFind < pWedNrs(m)) Then
   comp = -1
 ElseIf (wednrToFind = pWedNrs(m)) Then
   If (progToFind < pProgs(m)) Then
     comp = -1
   ElseIf (progToFind > pProgs(m)) Then
     comp = 1
   Else 'equal
     comp = 0
   End If
 Else
   comp = 1
 End If
 
 If (comp < 0) Then
   r = m
 ElseIf (comp > 0) Then
   l = m + 1
 Else
   bSearchProg = m
   Exit Function
 End If
Wend





Exit Function
fout:
MsgBox Err & " bSearchProg" & vbCrLf & Error$, 16
End Function




Public Function wedPromptUser(ByRef isOK As Boolean, ByRef lkpWedNr As Long) As Boolean
On Error GoTo fout
wedPromptUser = False


Dim sql As String
sql = "Delete * from gWedOpzoek;"
DoCmd.SetWarnings False
DoCmd.RunSQL sql
DoCmd.SetWarnings True

Dim rs As Recordset
Set rs = CurrentDb().OpenRecordset("gWedOpzoek")

rs.AddNew
  'rs("PO_ARG_Wedstrijdnummer") = wednr
  rs("PO_OK") = False
rs.Update

rs.Close

DoCmd.OpenForm "hxWedOpzoek", , , , , acDialog

Set rs = CurrentDb().OpenRecordset("gWedOpzoek")

rs.MoveFirst
If rs.EOF Then
  Err.Raise 1, , "Intern probleem. Tabel gWedOpzoek is leeg."
End If

isOK = Nz(rs("PO_OK"))


lkpWedNr = Nz(rs("PO_Wedstrijdnummer"))

rs.Close

wedPromptUser = True
Exit Function
fout:
If (Err = 3021) Then Resume Next ' no current record
MsgBox Err & " wedPromptUser" & vbCrLf & Error$, 16
DoCmd.SetWarnings True
Exit Function
End Function








Public Function fltGetTijdFilter(ByRef isOK As Boolean, ByRef lkpFilter As String) As Boolean
On Error GoTo fout
fltGetTijdFilter = False


Dim sql As String
sql = "Delete * from gFILTER_TIJD;"
DoCmd.SetWarnings False
DoCmd.RunSQL sql
DoCmd.SetWarnings True

Dim rs As Recordset
Set rs = CurrentDb().OpenRecordset("gFILTER_TIJD")

rs.AddNew
  rs("TF_SQL") = Null
  rs("TF_OK") = False
rs.Update

rs.Close

DoCmd.OpenForm "hxFILTER_TIJD", , , , , acDialog

Set rs = CurrentDb().OpenRecordset("gFILTER_TIJD")

rs.MoveFirst
If rs.EOF Then
  Err.Raise 1, , "Intern probleem. Tabel gFILTER_TIJD is leeg."
End If

isOK = Nz(rs("TF_OK"))


lkpFilter = Nz(rs("TF_SQL"))

rs.Close

fltGetTijdFilter = True
Exit Function
fout:
If (Err = 3021) Then Resume Next ' no current record
MsgBox Err & " fltGetTijdFilter" & vbCrLf & Error$, 16
DoCmd.SetWarnings True
Exit Function
End Function


'return the insertion position
Public Function insAfSlag(ByVal insAf As String, ByVal insSlag As String, ByRef cnt As Integer, ByRef pAfs() As String, ByRef pSlags() As String) As Integer
On Error GoTo fout
insAfSlag = -1
Dim insPos As Integer
insPos = cnt
Dim done As Boolean
done = (insPos = 0)
While (Not done)
  If (pAfs(insPos - 1) > insAf) Then
    done = False
  ElseIf (pAfs(insPos - 1) = insAf) And (pSlags(insPos - 1) > insSlag) Then
    done = False
  Else
    done = True
  End If
  
  If (Not done) Then
    pAfs(insPos) = pAfs(insPos - 1)
    pSlags(insPos) = pSlags(insPos - 1)
    insPos = insPos - 1
  End If
    
  If (insPos = 0) Then
    done = True
  End If
Wend

pAfs(insPos) = insAf
pSlags(insPos) = insSlag
cnt = cnt + 1

insAfSlag = insPos

Exit Function
fout:
MsgBox Err & " " & Error$, 16

End Function

Public Function bSearchAfSlag(ByVal afToFind As String, ByVal slagToFind As String, ByRef pAfs() As String, ByRef pSlags() As String, ByVal nAfSlags As Integer) As Integer
On Error GoTo fout
bSearchAfSlag = -1

'need to perform binary search on (afToFind, slagToFind) pair.
Dim l As Integer, r As Integer, m As Integer
l = 0
r = nAfSlags
While (r > l)
 m = (l + r) \ 2
 
 Dim comp As Integer
 If (afToFind < pAfs(m)) Then
   comp = -1
 ElseIf (afToFind = pAfs(m)) Then
   If (slagToFind < pSlags(m)) Then
     comp = -1
   ElseIf (slagToFind > pSlags(m)) Then
     comp = 1
   Else 'equal
     comp = 0
   End If
 Else
   comp = 1
 End If
 
 If (comp < 0) Then
   r = m
 ElseIf (comp > 0) Then
   l = m + 1
 Else
   bSearchAfSlag = m
   Exit Function
 End If
Wend





Exit Function
fout:
MsgBox Err & " bSearchAfSlag" & vbCrLf & Error$, 16
End Function


Public Function wedDelDln_PrepareDlnTables(ByVal meetMainNr As Long) As Boolean
On Error GoTo fout
wedDelDln_PrepareDlnTables = False

If Not wedDelDln_Cleanup() Then
  Exit Function
End If


Dim rs As Recordset
Set rs = CurrentDb().OpenRecordset("gDEL_DLN_Options")

rs.AddNew
  rs("DD_ProgsSingleProgOnly") = False
  rs("DD_ProgsEntireMeet") = False
  rs("DD_DelEmptyEstafs") = False
rs.Update

appCleanRS rs



'Need to append verenigingen and swimmers.
'Just get a list of persoonlijke starts and ploegleden.

Dim outS As Recordset
Dim outV As Recordset

Set outS = CurrentDb().OpenRecordset("gDEL_DLN_Zwemmers")
Set outV = CurrentDb().OpenRecordset("gDEL_DLN_Verenigingen")

outS.Index = "PrimaryKey"
outV.Index = "Primarykey"

Dim swmSQL As String
swmSQL = dlnGetDeelnemersPersSQL(False, True, "", meetMainNr, meetMainNr, False)

swmSQL = swmSQL & " ORDER BY " & FNM_DE_PERS_VER_TO_ORDER & ", " & FNM_DE_PERS_STARTNR_TO_ORDER & ""


Set rs = CurrentDb().OpenRecordset(swmSQL)

Dim curVer As String
Dim curStart As String


curVer = ""
curStart = ""

rs.MoveFirst

Do Until rs.EOF
  Dim tpVer As String
  Dim tpStart As String
  
  tpVer = Nz(rs(FNM_DE_PERS_VER))
  tpStart = Nz(rs(FNM_DE_PERS_STARTNR))
  
  If (tpVer <> curVer) Then
  
    outV.AddNew
      outV("DDV_Vereniging") = hzn(tpVer)
    outV.Update
  
    curVer = tpVer
    curStart = ""
  End If
  
  If (tpStart <> curStart) Then
  
    Dim tpNm As String
    Dim tpAchternaam As String, tpVoornaam As String, tpVoegsel As String
    
    tpNm = Nz(rs(FNM_DE_PERS_NAAM))
    tpAchternaam = Nz(rs(FNM_DE_PERS_ACHTNM))
    tpVoornaam = Nz(rs(FNM_DE_PERS_VOORNM))
    tpVoegsel = Nz(rs(FNM_DE_PERS_VOEGSEL))
    
    If (tpAchternaam = "") Then
      tpAchternaam = nmExtractAchternaam(tpNm)
      tpVoornaam = nmExtractVoornaam(tpNm)
      tpVoegsel = nmExtractVoegsel(tpNm)
    End If
    
    Dim tpFindKey As String
    tpFindKey = tpAchternaam & ", " & tpVoornaam & " " & tpVoegsel
  
    outS.AddNew
      outS("DDS_Vereniging") = hzn(tpVer)
      outS("DDS_Startnummer") = hzn(tpStart)
      outS("DDS_Naam") = hzn(tpNm)
      outS("DDS_Achternaam") = hzn(tpAchternaam)
      outS("DDS_Find_Key") = hzn(tpFindKey)
      outS("DDS_Delete") = False
    outS.Update
    
    curStart = tpStart
  End If

  rs.MoveNext
Loop


appCleanRS rs


'Now handle ploegleden

Dim plSQL As String
plSQL = dlnGetPloegledenSQL(False, True, "", meetMainNr, meetMainNr, False)

plSQL = plSQL & " ORDER BY " & FNM_PL_STARTNR_TO_ORDER & ", " & FNM_PL_STARTNR_TO_ORDER




Set rs = CurrentDb().OpenRecordset(plSQL)



curVer = ""
curStart = ""

rs.MoveFirst

Do Until rs.EOF
  
  tpVer = Nz(rs(FNM_PL_VER))
  tpStart = Nz(rs(FNM_PL_STARTNR))
  
  If (tpVer <> curVer) Then
  
    outV.Seek "=", tpVer
  
    If outV.NoMatch Then
      outV.AddNew
        outV("DDV_Vereniging") = hzn(tpVer)
      outV.Update
    End If
  
    curVer = tpVer
    curStart = ""
  End If
  
  If (tpStart <> curStart) Then
  
    tpNm = Nz(rs(FNM_PL_NAAM))
    tpAchternaam = Nz(rs(FNM_PL_ACHTNM))
    tpVoornaam = Nz(rs(FNM_PL_VOORNM))
    tpVoegsel = Nz(rs(FNM_PL_VOEGSEL))
    
    If (tpAchternaam = "") Then
      tpAchternaam = nmExtractAchternaam(tpNm)
      tpVoornaam = nmExtractVoornaam(tpNm)
      tpVoegsel = nmExtractVoegsel(tpNm)
    End If
    
    tpFindKey = tpAchternaam & ", " & tpVoornaam & " " & tpVoegsel
  
    outS.Seek "=", tpVer, tpStart
    If outS.NoMatch Then
      outS.AddNew
        outS("DDS_Vereniging") = hzn(tpVer)
        outS("DDS_Startnummer") = hzn(tpStart)
        outS("DDS_Naam") = hzn(tpNm)
        outS("DDS_Achternaam") = hzn(tpAchternaam)
        outS("DDS_Find_Key") = hzn(tpFindKey)
        outS("DDS_Delete") = False
      outS.Update
    End If
    
    curStart = tpStart
  End If

  rs.MoveNext
Loop

appCleanRS rs

wedDelDln_PrepareDlnTables = True
Exit Function
fout:
If (Err = 3021) Then Resume Next
MsgBox Err & " wedDelDln_PrepareDlnTables" & vbCrLf & Error$, 16
Exit Function


'debug
On Error GoTo 0
Resume

End Function



Public Function wedDelDln_ApplyToProgs() As Boolean
On Error GoTo fout
wedDelDln_ApplyToProgs = False

'first get the options.
Dim rs As Recordset
Set rs = CurrentDb().OpenRecordset("gDEL_DLN_Options")

rs.MoveFirst

Dim iChoice As Integer, sStart As String, sStartVer As String, sVer As String
Dim blSingleProg As Boolean, sCurProg As String, blEntireMeet As Boolean, lWedNr As Long, lMeetMainNr As Long
Dim blDeleteEmptyEstafs As Boolean


iChoice = Nz(rs("DD_Choice"))
sVer = Nz(rs("DD_SingleVer"))
sStart = Nz(rs("DD_SingleStartnummer"))
sStartVer = Nz(rs("DD_SingleStartnummerVer"))
blSingleProg = Nz(rs("DD_ProgsSingleProgOnly"))
sCurProg = Nz(rs("DD_ProgsCurProg"))
blEntireMeet = Nz(rs("DD_ProgsEntireMeet"))
lWedNr = Nz(rs("DD_ProgsWedNr"))
lMeetMainNr = Nz(rs("DD_ProgsMeetMainNr"))
blDeleteEmptyEstafs = Nz(rs("DD_DelEmptyEstafs"))

appCleanRS rs

'options have been gathered.

'now browse through deelnemers and delete the appropriate ones.
Dim sw As Recordset
Set sw = CurrentDb().OpenRecordset("gDEL_DLN_Zwemmers")
sw.Index = "PrimaryKey"



Dim dlnSQL As String
dlnSQL = dlnGetDeelnemersPersSQL(blSingleProg, blEntireMeet, sCurProg, lWedNr, lMeetMainNr, True)

Set rs = CurrentDb().OpenRecordset(dlnSQL, dbOpenDynaset)
rs.MoveFirst
Do Until rs.EOF

  Dim tpVer As String
  tpVer = Nz(rs(FNM_DE_PERS_VER))
  
  Dim tpStart As String
  tpStart = Nz(rs(FNM_DE_PERS_STARTNR))
  
  Dim blShouldDelete As Boolean
  blShouldDelete = False
  
  If (iChoice = DEL_CHOICE_ALL) Then
    blShouldDelete = True
  ElseIf (iChoice = DEL_CHOICE_SINGLE_SWM) Then
    If (tpStart = sStart) And (tpVer = sStartVer) Then
      blShouldDelete = True
    End If
  ElseIf (iChoice = DEL_CHOICE_SINGLE_VER) Then
    If (tpVer = sVer) Then
      blShouldDelete = True
    End If
  ElseIf (iChoice = DEL_CHOICE_LIST) Then
    sw.Seek "=", tpVer, tpStart
    If (Not sw.NoMatch) Then
      If Nz(sw("DDS_Delete"), False) Then
        blShouldDelete = True
      End If
    End If
  End If
  
  
  If (blShouldDelete) Then
    rs.Delete
  End If

  rs.MoveNext
Loop

appCleanRS rs

dlnSQL = dlnGetPloegledenSQL(blSingleProg, blEntireMeet, sCurProg, lWedNr, lMeetMainNr, True)

Set rs = CurrentDb().OpenRecordset(dlnSQL, dbOpenDynaset)

rs.MoveFirst
Do Until rs.EOF

  tpVer = Nz(rs(FNM_PL_VER))
  tpStart = Nz(rs(FNM_PL_STARTNR))
  
  blShouldDelete = False
  
  If (iChoice = DEL_CHOICE_ALL) Then
    blShouldDelete = True
  ElseIf (iChoice = DEL_CHOICE_SINGLE_SWM) Then
    If (tpStart = sStart) And (tpVer = sStartVer) Then
      blShouldDelete = True
    End If
  ElseIf (iChoice = DEL_CHOICE_SINGLE_VER) Then
    If (tpVer = sVer) Then
      blShouldDelete = True
    End If
  ElseIf (iChoice = DEL_CHOICE_LIST) Then
    sw.Seek "=", tpVer, tpStart
    If (Not sw.NoMatch) Then
      If Nz(sw("DDS_Delete"), False) Then
        blShouldDelete = True
      End If
    End If
  End If
  
  
  If (blShouldDelete) Then
    rs.Delete
  End If
  
  
  rs.MoveNext
Loop

appCleanRS rs


If (blDeleteEmptyEstafs) Or (iChoice = DEL_CHOICE_SINGLE_VER) Or (iChoice = DEL_CHOICE_ALL) Then
    'Delete all empty estafettes
    If Not analyzeEstafs(False, lMeetMainNr, lMeetMainNr, "~AN_Estafs") Then
      Exit Function
    End If
    
    Dim estSQL As String
    estSQL = dlnGetDeelnemersEstSQL(blSingleProg, blEntireMeet, sCurProg, lWedNr, lMeetMainNr, True, "")
    
    Dim est As Recordset
    Set est = CurrentDb().OpenRecordset("~AN_Estafs")
    est.Index = "P"
    
    Set rs = CurrentDb().OpenRecordset(estSQL)
    rs.MoveFirst
    Do Until rs.EOF
      Dim tpWed As Long
      Dim tpProg As String
      Dim tpEst As Integer
      tpWed = Nz(rs(FNM_DE_EST_WEDNR))
      tpProg = Nz(rs(FNM_DE_EST_PROG))
      tpEst = Nz(rs(FNM_DE_EST_ESTNR))
      tpVer = Nz(rs(FNM_DE_EST_VER))
      
      blShouldDelete = False
      
      
      est.Seek "=", tpWed, tpProg, tpEst, tpVer
      If Not est.NoMatch Then
        If (Nz(est("EST_ActPloegCnt")) = 0) Then
          If (blDeleteEmptyEstafs) Or (tpVer = sVer) Or (iChoice = DEL_CHOICE_ALL) Then
            blShouldDelete = True
          End If
        End If
      Else
        'est not present -> no ploegleden -> delete
        If (blDeleteEmptyEstafs) Or (tpVer = sVer) Or (iChoice = DEL_CHOICE_ALL) Then
          blShouldDelete = True
        End If
      End If
      
      If (blShouldDelete) Then
        rs.Delete
      End If
      
      rs.MoveNext
    Loop
    
End If

appCleanRS rs

wedDelDln_ApplyToProgs = True
Exit Function
fout:
If (Err = 3021) Then Resume Next ' no current record
MsgBox Err & " wedDelDln_ApplyToProgs" & vbCrLf & Error$, 16
Exit Function
End Function



Public Function wedDelDln_Cleanup() As Boolean
On Error GoTo fout
wedDelDln_Cleanup = False



Dim sql As String


DoCmd.SetWarnings False

sql = "Delete * from gDEL_DLN_Zwemmers;"
DoCmd.RunSQL sql

sql = "Delete * from gDEL_DLN_Verenigingen;"
DoCmd.RunSQL sql

sql = "Delete * from gDEL_DLN_Options;"
DoCmd.RunSQL sql


DoCmd.SetWarnings True


wedDelDln_Cleanup = True
Exit Function
fout:
DoCmd.SetWarnings True
MsgBox Err & " wedDelDln_Cleanup" & vbCrLf & Error$, 16
Exit Function
End Function





Private Function appAcquireWedMRUList(ByRef nWeds As Integer, ByRef lWedNrs() As Long) As Boolean
On Error GoTo fout
appAcquireWedMRUList = False

nWeds = 0

Dim dsData As DIR_SERVER_DATA

If Not dsInit(dsData, False, "") Then
  Exit Function
End If


Dim blIsPresent As Boolean
blIsPresent = False

Dim sDummy As String, lDummy As Long

If Not dsLookupPropertyByName(dsData, "GLOBAL\WEDMRULIST", blIsPresent, sDummy, lDummy) Then
  Exit Function
End If

If (blIsPresent) Then

  nWeds = CInt(dsGetLong(dsData, "GLOBAL\WEDMRULIST\nWeds"))
  
  If (nWeds > 0) And (nWeds <= MAX_N_WEDS_IN_MRU_LIST) Then
  
    Dim i As Integer
    For i = 0 To nWeds - 1
      lWedNrs(i) = dsGetLong(dsData, "GLOBAL\WEDMRULIST\wed_" & i & "_nummer")
    Next i
  
  Else
    nWeds = 0
  End If


End If


dsClean dsData

appAcquireWedMRUList = True
Exit Function

fout:
MsgBox Err & " appAcquireWedMRUList" & vbCrLf & Error$, 16
Exit Function

End Function
Private Function appSaveWedMRUList(ByVal nWeds As Integer, ByRef lWedNrs() As Long) As Boolean
On Error GoTo fout
appSaveWedMRUList = False


Dim dsData As DIR_SERVER_DATA

If Not dsInit(dsData, False, "") Then
  Exit Function
End If

Dim blDummy As Boolean, sDummy As String

If Not dsDeletePropertyByName(dsData, "GLOBAL\WEDMRULIST", blDummy, sDummy) Then
  Exit Function
End If

dsSetLong dsData, "GLOBAL\WEDMRULIST\nWeds", nWeds

Dim i As Integer
For i = 0 To nWeds - 1
  dsSetLong dsData, "GLOBAL\WEDMRULIST\wed_" & i & "_nummer", lWedNrs(i)
Next i


dsClean dsData


appSaveWedMRUList = True
Exit Function

fout:
MsgBox Err & " appSaveWedMRUList" & vbCrLf & Error$, 16
Exit Function

End Function


Public Function appExportWedMRUList() As Boolean
On Error GoTo fout
appExportWedMRUList = False


Dim sql As String
sql = "Delete * from gWedMRUList"

DoCmd.SetWarnings False
DoCmd.RunSQL sql
DoCmd.SetWarnings True


Dim nWeds As Integer, lWedNummers(0 To MAX_N_WEDS_IN_MRU_LIST) As Long

Dim skWed As Recordset
Set skWed = CurrentDb().OpenRecordset(TNM_WED)
skWed.Index = "PrimaryKey"

If Not appAcquireWedMRUList(nWeds, lWedNummers) Then
  Exit Function
End If

Dim rsOut As Recordset
Set rsOut = CurrentDb().OpenRecordset("gWedMRUList")


Dim tpVolg As Integer
tpVolg = 0

Dim i As Integer
For i = 0 To nWeds - 1
  skWed.Seek "=", lWedNummers(i)
  If (Not skWed.NoMatch) Then
    Dim tpPlaats As String, tpDat As Date, tpDes As String
    tpPlaats = Nz(skWed(FNM_WED_PLAATS))
    tpDat = Nz(skWed(FNM_WED_DATUM), #1/1/1900#)
    tpDes = Nz(skWed(FNM_WED_DES))
    
    tpVolg = tpVolg + 1
    rsOut.AddNew
      rsOut("WED_MRU_Volgorde") = tpVolg
      rsOut("WED_MRU_Wedstrijdnummer") = lWedNummers(i)
      If (lenDateIsValid(tpDat)) Then
        rsOut("WED_MRU_Datum") = tpDat
      End If
      rsOut("WED_MRU_Plaats") = hzn(tpPlaats)
      rsOut("WED_MRU_Beschrijving") = hzn(tpDes)
    rsOut.Update
  End If
Next i



appExportWedMRUList = True
Exit Function

fout:
DoCmd.SetWarnings True
MsgBox Err & " appExportWedMRUList" & vbCrLf & Error$, 16
Exit Function
End Function

Public Sub appWedMRUAddWed(ByVal lWedNr As Long)
On Error GoTo fout

Dim nWeds As Integer, lWedNrs(0 To MAX_N_WEDS_IN_MRU_LIST) As Long

If Not appAcquireWedMRUList(nWeds, lWedNrs) Then
  Exit Sub
End If

Dim isInList As Boolean, posInList As Integer
isInList = False

Dim i As Integer

For i = 0 To nWeds - 1
  If (lWedNrs(i) = lWedNr) Then
    isInList = True
    posInList = i
    Exit For
  End If
Next i


Dim shiftStartPos As Integer


If isInList Then
  shiftStartPos = posInList
Else
  If (nWeds = MAX_N_WEDS_IN_MRU_LIST) Then
    shiftStartPos = nWeds - 1
  Else
    shiftStartPos = nWeds
    nWeds = nWeds + 1
  End If
End If

If (shiftStartPos <> 0) Then
  For i = shiftStartPos To 1 Step -1
    lWedNrs(i) = lWedNrs(i - 1)
  Next i
End If
lWedNrs(0) = lWedNr


If Not appSaveWedMRUList(nWeds, lWedNrs) Then
  Exit Sub
End If

Exit Sub
fout:
MsgBox Err & " appWedMRUAddWed" & vbCrLf & Error$, 16
Exit Sub
End Sub




Private Function wedMove_handleTable(ByRef db As Database, ByVal sTbName As String, ByVal sFldWedNr As String, ByVal blAddRecs As Boolean, ByVal lWedNr As Long, ByVal lTgtWedNr As Long) As Boolean
On Error GoTo fout
wedMove_handleTable = False

Dim tb As TableDef, fld As Field

Set tb = db.TableDefs(sTbName)


If (blAddRecs) Then

  Dim sqlListSrc As String
  sqlListSrc = ""

  Dim sqlListTgt As String
  sqlListTgt = ""


  For Each fld In tb.Fields
    Dim tpName As String
    tpName = fld.name
    
    If (tpName <> "DE_Index" And tpName <> "TY_Counter" And tpName <> "JD_Teller") Then
    
      If (sqlListSrc <> "") Then
        sqlListSrc = sqlListSrc & ", "
      End If
      If (sqlListTgt <> "") Then
        sqlListTgt = sqlListTgt & ", "
      End If
      
      
      If (tpName = sFldWedNr) Then
        sqlListSrc = sqlListSrc & CStr(lTgtWedNr)
      Else
        sqlListSrc = sqlListSrc & "[" & tpName & "]"
      End If
      
      
      sqlListTgt = sqlListTgt & "[" & tpName & "]"
    End If
  Next fld
  
  Dim sqlWhere As String
  sqlWhere = "Where [" & sFldWedNr & "] = " & lWedNr & " "
  
  Dim sql As String
  sql = "Insert into [" & sTbName & "] (" & sqlListTgt & ") select " & sqlListSrc & " from [" & sTbName & "] " & sqlWhere & ";"
  
  
  DoCmd.SetWarnings False
  db.Execute sql
  DoCmd.SetWarnings True

Else

  sql = "update [" & sTbName & "] set [" & sFldWedNr & "] = " & lTgtWedNr & " where [" & sFldWedNr & "] = " & lWedNr & ";"
  
  
  DoCmd.SetWarnings False
  db.Execute sql
  DoCmd.SetWarnings True


End If




wedMove_handleTable = True
Exit Function:
fout:
DoCmd.SetWarnings True
MsgBox Err & " wedMove_handleTable" & vbCrLf & Error$, 16
Exit Function

'debug
On Error GoTo 0
Resume

End Function



Private Function wedMove(ByRef skWed As Recordset, ByVal lSrcWedNr As Long, ByVal lTgtWedNr As Long) As Boolean
On Error GoTo fout

wedMove = False



Dim blTransInProgress As Boolean
blTransInProgress = False




Dim sTbs(0 To 40) As String
Dim sWedFld(0 To 40) As String
Dim blAdd(0 To 40) As Boolean
Dim nTbs As Integer

Dim blUseSimpleEdit As Boolean

wediMove_prepareSpecialTables blUseSimpleEdit, sTbs, sWedFld, blAdd, nTbs


If (blUseSimpleEdit) Then

  skWed.Seek "=", lSrcWedNr
  
  If (skWed.NoMatch) Then
    Err.Raise 1, , "Internal error"
  End If
  
  skWed.Edit
    skWed(FNM_WED_NR) = lTgtWedNr
  skWed.Update
  
  Dim dsNtxData As DIR_SERVER_DATA
  
  If Not dsInit(dsNtxData, False, "") Then
    Exit Function
  End If
    
  If Not dsRenamePropertyByName(dsNtxData, appGetName() & "\WED_AUX_DATA\" & lSrcWedNr, appGetName() & "\WED_AUX_DATA\" & lTgtWedNr) Then
    Exit Function
  End If
    
  If Not dsClean(dsNtxData) Then
    Exit Function
  End If
  


Else
  
  
  
  
  Dim wrkSpace As Workspace
  Set wrkSpace = DBEngine(0)
  
  Dim db As Database
  Set db = wrkSpace(0)
  
  
  wrkSpace.BeginTrans
  
    blTransInProgress = True
    
    Dim i As Integer
    For i = 0 To nTbs - 1
      If Not wedMove_handleTable(db, sTbs(i), sWedFld(i), blAdd(i), lSrcWedNr, lTgtWedNr) Then
        Err.Raise 2, , "Silent"
      End If
    
    Next i
    
    Dim sql As String
    
    
    'Weds have been moved.
    
    'We can also move over the data in the directory server
    Dim dsTxData As DIR_SERVER_DATA
    If Not dsInit_Transactional(db, dsTxData, False, "") Then
      Err.Raise 2, , "Silent"
    End If
    
    If Not dsRenamePropertyByName(dsTxData, appGetName() & "\WED_AUX_DATA\" & lSrcWedNr, appGetName() & "\WED_AUX_DATA\" & lTgtWedNr) Then
      Err.Raise 2, , "Silent"
    End If
    
    If Not dsClean(dsTxData) Then
      Err.Raise 2, , "Silent"
    End If
    
    
    
    'We can now delete the original wedstrijd
    
    sql = "delete * from " & TNM_WED & " where [" & FNM_WED_NR & "] = " & lSrcWedNr
    
    DoCmd.SetWarnings False
    db.Execute sql
    DoCmd.SetWarnings True
    
    
    
    
    
  wrkSpace.CommitTrans
  
  Set wrkSpace = Nothing
  Set db = Nothing
  
  
  
  blTransInProgress = False


End If 'if blUseSimpleEdit

wedMove = True

Exit Function

fout:

Dim blSilent As Boolean, msg As String
If (Err = 2) Then
  blSilent = True
Else
  msg = Err & " wedMove" & vbCrLf & Error$
End If

On Error Resume Next

DoCmd.SetWarnings True
If (blTransInProgress) Then
  wrkSpace.Rollback
  Set wrkSpace = Nothing
  Set db = Nothing
End If

If Not blSilent Then
  MsgBox msg, 16
End If

Exit Function


End Function




Private Function wedNrChange_clean() As Boolean
On Error GoTo fout
wedNrChange_clean = False

DoCmd.SetWarnings False

Dim sql As String
sql = "delete * from gWedNummerChange;"

DoCmd.RunSQL sql

DoCmd.SetWarnings True

wedNrChange_clean = True
Exit Function
fout:
DoCmd.SetWarnings True
MsgBox Err & " wedNrChange_clean" & vbCrLf & Error$, 16
Exit Function
End Function

Private Function wedNrChange_perform_addDependents() As Boolean
On Error GoTo fout
wedNrChange_perform_addDependents = False


Dim skChange As Recordset
Set skChange = CurrentDb().OpenRecordset("gWedNummerChange")
skChange.Index = "PrimaryKey"

Dim skChangeNew As Recordset
Set skChangeNew = CurrentDb().OpenRecordset("gWedNummerChange")
skChangeNew.Index = "IdxNewNummer"


Dim rs As Recordset, sql As String
sql = "SELECT " & TNM_WED & ".* FROM " & TNM_WED & " INNER JOIN gWedNummerChange ON " & TNM_WED & "." & FNM_WED_MAIN_NR & " = " & _
      "gWedNummerChange.NR_OldNummer;"
Set rs = CurrentDb().OpenRecordset(sql)

rs.MoveFirst
Do Until rs.EOF
  Dim tpWed As Long
  tpWed = Nz(rs(FNM_WED_NR))
  
  skChange.Seek "=", tpWed
  
  If (skChange.NoMatch) Then
    'have to add; since it is a dependent
    Dim tpWedMainNr As Long
    tpWedMainNr = Nz(rs(FNM_WED_MAIN_NR), -1)
    If (tpWedMainNr <= 0) Then
      Err.Raise 1, , "Internal error"
    End If
    
    skChangeNew.Seek "=", tpWed
    If (Not skChangeNew.NoMatch) Then
      Err.Raise 1, , "Het wedstrijdnummer: " & tpWed & " valt buiten het datum bereik maar is nodig voor de chronologische volgorde. " & vbCrLf & "Vergroot het datum-bereik"
    End If
    
    skChange.AddNew
      skChange("NR_OldNummer") = tpWed
      skChange("NR_NewNummer") = tpWed
      skChange("NR_OldMainNummer") = tpWedMainNr
    skChange.Update

  End If
  
  rs.MoveNext
Loop

appCleanRS rs

appCleanRS skChange
appCleanRS skChangeNew


wedNrChange_perform_addDependents = True
Exit Function

fout:
If (Err = 3021) Then Resume Next
MsgBox Err & " wedNrChange_perform_addDependents" & vbCrLf & Error$, 16


appCleanRS rs
appCleanRS skChange
appCleanRS skChangeNew


Exit Function

End Function



Private Function wedNrChange_perform_calcNewMainNrs() As Boolean
On Error GoTo fout
wedNrChange_perform_calcNewMainNrs = False


Dim skChange As Recordset
Set skChange = CurrentDb().OpenRecordset("gWedNummerChange")
skChange.Index = "PrimaryKey"

Dim rs As Recordset
Set rs = CurrentDb().OpenRecordset("select * from gWedNummerChange", dbOpenDynaset)
rs.MoveFirst
Do Until rs.EOF
  Dim tpOldMainNr As Long
  tpOldMainNr = Nz(rs("NR_OldMainNummer"), -1)
  
  Dim tpNewMainNr As Long
  tpNewMainNr = tpOldMainNr
  
  
  'Check to see if the mainNr has been changed
  If (tpOldMainNr > 0) Then
    skChange.Seek "=", tpOldMainNr
    If (Not skChange.NoMatch) Then
      tpNewMainNr = Nz(skChange("NR_INT_CurrentNummer"))
    End If
  End If
  
  If (tpNewMainNr > 0) Then
    rs.Edit
      rs("NR_INT_CurrentMainNummer") = tpNewMainNr
    rs.Update
  End If
  
  rs.MoveNext
Loop

appCleanRS rs
appCleanRS skChange


wedNrChange_perform_calcNewMainNrs = True
Exit Function

fout:
If (Err = 3021) Then Resume Next
MsgBox Err & " wedNrChange_perform_calcNewMainNrs" & vbCrLf & Error$, 16
Exit Function

End Function



Private Function wedNrChange_perform_clearMainWedNrs() As Boolean
On Error GoTo fout
wedNrChange_perform_clearMainWedNrs = False


Dim skWed As Recordset
Set skWed = CurrentDb().OpenRecordset(TNM_WED)
skWed.Index = "PrimaryKey"

Dim rs As Recordset
Set rs = CurrentDb().OpenRecordset("select * from gWedNummerChange where nz([NR_OldMainNummer]) > 0")
rs.MoveFirst
Do Until rs.EOF

  Dim tpWedNr As Long
  tpWedNr = Nz(rs("NR_OldNummer"))
  
  skWed.Seek "=", tpWedNr
  
  If (skWed.NoMatch) Then
    Err.Raise 1, , "Internal error"
  End If
  
  skWed.Edit
    skWed(FNM_WED_MAIN_NR) = Null
  skWed.Update

  rs.MoveNext
Loop

appCleanRS rs
appCleanRS skWed


wedNrChange_perform_clearMainWedNrs = True
Exit Function

fout:
If (Err = 3021) Then Resume Next
MsgBox Err & " wedNrChange_perform_clearMainWedNrs" & vbCrLf & Error$, 16
Exit Function

End Function

Private Function wedNrChange_perform_restoreMainWedNrs() As Boolean
On Error GoTo fout
wedNrChange_perform_restoreMainWedNrs = False


Dim skWed As Recordset
Set skWed = CurrentDb().OpenRecordset(TNM_WED)
skWed.Index = "PrimaryKey"

Dim rs As Recordset
Set rs = CurrentDb().OpenRecordset("select * from gWedNummerChange where nz([NR_OldMainNummer]) > 0")
rs.MoveFirst
Do Until rs.EOF

  Dim tpWedNr As Long
  tpWedNr = Nz(rs("NR_INT_CurrentNummer"))
  
  Dim tpNewMainNr As Long
  tpNewMainNr = Nz(rs("NR_INT_CurrentMainNummer"))
  
  skWed.Seek "=", tpWedNr
  
  If (skWed.NoMatch) Then
    Err.Raise 1, , "Internal error"
  End If
  
  skWed.Edit
    skWed(FNM_WED_MAIN_NR) = tpNewMainNr
  skWed.Update

  rs.MoveNext
Loop

appCleanRS rs

appCleanRS skWed


wedNrChange_perform_restoreMainWedNrs = True
Exit Function

fout:
If (Err = 3021) Then Resume Next
MsgBox Err & " wedNrChange_perform_restoreMainWedNrs" & vbCrLf & Error$, 16
Exit Function

On Error GoTo 0
Resume

End Function

Private Function wedNrChange_perform_testValidity(ByRef isValid As Boolean, ByRef offendingWedNr As Long) As Boolean
On Error GoTo fout
wedNrChange_perform_testValidity = False

isValid = True

Dim rs As Recordset
Set rs = CurrentDb().OpenRecordset("gWedNummerChange")

Dim skWed As Recordset
Set skWed = CurrentDb().OpenRecordset(TNM_WED)
skWed.Index = "PrimaryKey"

Dim skChange As Recordset
Set skChange = CurrentDb().OpenRecordset("gWedNummerChange")
skChange.Index = "PrimaryKey"

rs.MoveFirst
Do Until rs.EOF
  
  Dim tpNewNr As Long
  tpNewNr = Nz(rs("NR_NewNummer"))
  
  skWed.Seek "=", tpNewNr
  
  If (Not skWed.NoMatch) Then
    skChange.Seek "=", tpNewNr
    If (skChange.NoMatch) Then
      'This will cause an external block: anticipate and fail.
      offendingWedNr = tpNewNr
      isValid = False
      Exit Do
    End If
  End If

  rs.MoveNext
Loop

appCleanRS rs
appCleanRS skWed
appCleanRS skChange

wedNrChange_perform_testValidity = True
Exit Function

fout:
If (Err = 3021) Then Resume Next
MsgBox Err & " wedNrChange_perform_testValidity" & vbCrLf & Error$, 16
Exit Function

End Function


Private Function wedNrChange_perform_updateWedNrs(ByRef freeWedNr As Long) As Boolean
On Error GoTo fout
wedNrChange_perform_updateWedNrs = False


Dim skWed As Recordset
Set skWed = CurrentDb().OpenRecordset(TNM_WED)
skWed.Index = "PrimaryKey"


skWed.Seek "=", freeWedNr
If Not skWed.NoMatch Then
  Err.Raise 1, , "Internal error"
End If

Dim skChangeCurNr As Recordset
Set skChangeCurNr = CurrentDb().OpenRecordset("gWedNummerChange")
skChangeCurNr.Index = "IdxCurNummer"




Dim rs As Recordset
Set rs = CurrentDb().OpenRecordset("select * from gWedNummerChange;", dbOpenDynaset)
rs.MoveFirst
Do Until rs.EOF

  Dim tpCurNr As Long
  tpCurNr = Nz(rs("NR_INT_CurrentNummer"), -1)
  
  Dim tpNewNr As Long
  tpNewNr = Nz(rs("NR_NewNummer"))
  
  
  If (tpCurNr <> tpNewNr) Then
  
    'first check to see if this nummer is free
    skWed.Seek "=", tpNewNr
    
    'First free up this new nummer
    If (Not skWed.NoMatch) Then
      skChangeCurNr.Seek "=", tpNewNr
      If (skChangeCurNr.NoMatch) Then
        'We have a block in place
        'This should have been trapped
        Err.Raise 1, , "Internal error"
      End If
      
      
      'Change the nummer and mark this change
      If Not wedMove(skWed, tpNewNr, freeWedNr) Then
        Exit Function
      End If
            
      skChangeCurNr.Edit
        skChangeCurNr("NR_INT_CurrentNummer") = freeWedNr
      skChangeCurNr.Update
      
      'update the freeWedNr
      freeWedNr = tpNewNr
      
    End If
    
    
    'The new nummer is free
    
    If Not wedMove(skWed, tpCurNr, tpNewNr) Then
      Exit Function
    End If
    
    rs.Edit
      rs("NR_INT_CurrentNummer") = tpNewNr
    rs.Update
    
    If (freeWedNr = tpNewNr) Then
      freeWedNr = tpCurNr
    End If
    
  End If 'if tpCurNr <> tpNewNr

  rs.MoveNext
Loop

appCleanRS rs
appCleanRS skChangeCurNr
appCleanRS skWed

wedNrChange_perform_updateWedNrs = True
Exit Function

fout:
If (Err = 3021) Then Resume Next
MsgBox Err & " wedNrChange_perform_updateWedNrs" & vbCrLf & Error$, 16
Exit Function

End Function


Private Function wedNrChange_perform() As Boolean
On Error GoTo fout
wedNrChange_perform = False

'First check if we have a free wedstrijd nummer which we can use
Dim freeWedNr As Long
freeWedNr = -100

If Nz(DLookup("[" & FNM_WED_NR & "]", TNM_WED, "[" & FNM_WED_NR & "] = " & freeWedNr), 0) <> 0 Then
  Err.Raise 1, , "Het wedstrijdnummer: -100 is in gebruik "
End If

'first add all dependents

If (Not wedNrChange_perform_addDependents()) Then
  Exit Function
End If

Dim blIsValid As Boolean, tpOffWedNr As Long

If Not wedNrChange_perform_testValidity(blIsValid, tpOffWedNr) Then
  Exit Function
End If

If (Not blIsValid) Then
  Err.Raise 1, , "Het wedstrijdnummer: " & tpOffWedNr & " valt buiten het datum bereik maar is nodig voor de chronologische volgorde. " & vbCrLf & "Vergroot het datum-bereik"
End If


'Initialize the current nummers.
Dim sql As String
sql = "update gWedNummerChange set NR_INT_CurrentNummer = NR_OldNummer;"
DoCmd.SetWarnings False
DoCmd.RunSQL sql
DoCmd.SetWarnings True



'Now clear all MainWedstrijdNummer fields
If Not wedNrChange_perform_clearMainWedNrs() Then
  Exit Function
End If

Dim blIsOK As Boolean

blIsOK = True

If Not wedNrChange_perform_updateWedNrs(freeWedNr) Then
  blIsOK = False
End If


'Try to restore the main nummers, even if the update unexpectedly failed.
If Not wedNrChange_perform_calcNewMainNrs() Then
  Exit Function
End If

If Not wedNrChange_perform_restoreMainWedNrs() Then
  Exit Function
End If

If (Not blIsOK) Then
  Exit Function
End If


wedNrChange_perform = True
Exit Function

fout:
DoCmd.SetWarnings True
MsgBox Err & " wedNrChange_perform" & vbCrLf & Error$, 16
Exit Function

End Function

Public Function wedNrSingleChange(ByVal oldWedNr As Long, ByVal newWedNr As Long) As Boolean
On Error GoTo fout
wedNrSingleChange = False

If Not wediNrChange_notify() Then
  Exit Function
End If

Dim skWed As Recordset
Set skWed = CurrentDb().OpenRecordset(TNM_WED)
skWed.Index = "PrimaryKey"

skWed.Seek "=", newWedNr
If (Not skWed.NoMatch) Then
  Err.Raise 1, , "Nieuwe wedstrijdnummer: " & newWedNr & " bestaat al"
End If

Dim oldMainNr As Long

skWed.Seek "=", oldWedNr
If skWed.NoMatch Then
  Err.Raise 1, , "Oud wedstrijdnummer: " & oldWedNr & " bestaat niet"
Else
  oldMainNr = Nz(skWed(FNM_WED_MAIN_NR), -1)
End If

If Not wedNrChange_clean() Then
  Exit Function
End If

Dim rs As Recordset
Set rs = CurrentDb().OpenRecordset("gWedNummerChange")

rs.AddNew
  rs("NR_OldNummer") = oldWedNr
  rs("NR_NewNummer") = newWedNr
  If (oldMainNr > 0) Then
    rs("NR_OldMainNummer") = oldMainNr
  End If
rs.Update

appCleanRS rs

If Not wedNrChange_perform() Then
  Exit Function
End If

If Not wedNrChange_clean() Then
  Exit Function
End If


wedNrSingleChange = True
Exit Function

fout:
MsgBox Err & " wedNrSingleChange" & vbCrLf & Error$, 16
Exit Function
End Function


Public Function wedNrChronologicalChange(ByVal dFirstDate As Date) As Boolean


'=========================================================
'Hernummert de wedstrijden in chronologische volgorde.
'Vereiste is dat in de geselecteerde periode geen wedstrijdnummers
'van een andere periode liggen.
'=========================================================


On Error GoTo fout
wedNrChronologicalChange = False

If Not wediNrChange_notify() Then
  Exit Function
End If

If Not wedNrChange_clean() Then
  Exit Function
End If



 Dim lWedsPerYear As Long, lMinWedNrToChange As Long
 
 wediNrChronologicalChange_getStats lWedsPerYear, lMinWedNrToChange


'Perform two scans of the data; one to find the minimum wedstrijd numer in the selected period for each year
'The second pass is to fill the gWedNummerChange table
Dim sql As String
sql = "Select * from " & TNM_WED & " where [" & FNM_WED_DATUM & "] >= #" & Format(dFirstDate, "mm\-dd\-yyyy") & "# and [" & FNM_WED_NR & "] > " & lMinWedNrToChange & " order by [" & FNM_WED_DATUM & "], [" & FNM_WED_NR & "];"

Dim rs As Recordset
Set rs = CurrentDb().OpenRecordset(sql)

Dim rsOut As Recordset
Set rsOut = CurrentDb().OpenRecordset("gWedNummerChange")

Dim lYears(0 To 1000) As Long
Dim lYearMinEncNr(0 To 1000) As Long
Dim iYearNProcessed(0 To 1000) As Integer
Dim nYears As Integer

nYears = 0


rs.MoveFirst
Do Until rs.EOF
  Dim tpNr As Long, tpYear As Long
  tpNr = Nz(rs(FNM_WED_NR))
  tpYear = tpNr \ lWedsPerYear
  Dim lkpPos As Integer
  lkpPos = bSearchLong(tpYear, nYears, lYears)
  If (lkpPos < 0) Then
    'need to insert
    Dim insPos As Integer
    insPos = insLong(tpYear, nYears, lYears)
    shiftRightLong insPos, 1, (nYears - 1), lYearMinEncNr
    
    
    lYearMinEncNr(insPos) = tpNr
    
  Else
    If (tpNr < lYearMinEncNr(lkpPos)) Then
      lYearMinEncNr(lkpPos) = tpNr
    End If
  End If
  rs.MoveNext
Loop

Dim i As Integer
For i = 0 To nYears - 1
  iYearNProcessed(i) = 0
Next i


'The second pass:
rs.MoveFirst
Do Until rs.EOF
  tpNr = Nz(rs(FNM_WED_NR))
  tpYear = tpNr \ lWedsPerYear
  
  lkpPos = bSearchLong(tpYear, nYears, lYears)
  If (lkpPos < 0) Then
    Err.Raise 1, , "Internal error"
  End If
  
  Dim tpOldMainNr As Long
  Dim tpNewNr As Long
  
  tpOldMainNr = Nz(rs(FNM_WED_MAIN_NR), -1)
  
  tpNewNr = lYearMinEncNr(lkpPos) + iYearNProcessed(lkpPos)
  
  rsOut.AddNew
    rsOut("NR_OldNummer") = tpNr
    If (tpOldMainNr > 0) Then
      rsOut("NR_OldMainNummer") = tpOldMainNr
    End If
    rsOut("NR_NewNummer") = tpNewNr
  rsOut.Update
  
  iYearNProcessed(lkpPos) = iYearNProcessed(lkpPos) + 1

  rs.MoveNext
Loop

appCleanRS rs
appCleanRS rsOut


If Not wedNrChange_perform() Then
  Exit Function
End If

If Not wedNrChange_clean() Then
  Exit Function
End If


wedNrChronologicalChange = True
Exit Function
fout:
If (Err = 3021) Then Resume Next

MsgBox Err & " wedNrChronologicalChange" & vbCrLf & Error$, 16

Exit Function


'debug

On Error GoTo 0
Resume

End Function



Public Function wedMayDeleteMultiple(ByRef wednrs() As Long, ByRef wedDelete() As Boolean, ByVal nWeds As Integer) As Boolean
On Error GoTo fout
wedMayDeleteMultiple = False


'Handle multiple deletions


Dim ordWeds(0 To 10000) As Long
Dim ordWedDelete(0 To 10000) As Boolean
Dim ordWedOrgNr(0 To 1000) As Integer
Dim nOrdWeds As Integer



Dim blCancelAll As Boolean
blCancelAll = False



'First order the wedstrijden
Dim i As Integer
For i = nWeds - 1 To 0 Step -1

  If (Not blCancelAll) Then
    If (i < nWeds - 1) Then
      If wednrs(i) < wednrs(i + 1) Then
        MsgBox "Kan alleen wedstrijden verwijderen indien deze op aflopend wedstrijdnummer zijn gesorteerd.", vbCritical
        blCancelAll = True
      End If
    End If
  End If

  Dim tpWed As Long
  tpWed = wednrs(i)
  Dim insPos As Integer
  Dim oldOrdWedCnt As Integer
  oldOrdWedCnt = nOrdWeds
  insPos = insLong(tpWed, nOrdWeds, ordWeds)
  shiftRightInt insPos, 1, oldOrdWedCnt, ordWedOrgNr
  ordWedOrgNr(insPos) = i
Next i




Dim blIsFirstDeletion As Boolean
Dim blDeleteIsCancelled As Boolean
Dim blSuppressWarnings As Boolean
Dim blWarningDisplayed As Boolean
Dim blSuppressPrompted As Boolean



blIsFirstDeletion = True
blDeleteIsCancelled = False
blSuppressWarnings = False
blWarningDisplayed = False
blSuppressPrompted = False






If Not blCancelAll Then
  For i = 0 To nOrdWeds - 1
    
    ordWedDelete(i) = True
    
    If (blIsFirstDeletion) Then
      blIsFirstDeletion = False
      If (MsgBox("Geselecteerde wedstrijd(en) verwijderen?", vbOKCancel + vbQuestion) = vbCancel) Then
        blDeleteIsCancelled = True
      End If
    End If
    
    If (blDeleteIsCancelled) Then
      ordWedDelete(i) = False
    Else
      Dim isGlobalCancel As Boolean, isWarning As Boolean
      
      If (Not blSuppressWarnings) And (blWarningDisplayed) Then
        If Not blSuppressPrompted Then
          blSuppressPrompted = True
          If MsgBox("Wilt u evt waarschuwingen onderdrukken voor de volgende wedstrijden die worden verwijderd?", _
            vbQuestion + vbYesNo + vbDefaultButton2) = vbYes Then
            blSuppressWarnings = True
          End If
        End If
      End If
    
          
      If Not wediMayDelete_prompt(ordWeds(i), True, blSuppressWarnings, True, isWarning, isGlobalCancel) Then
        ordWedDelete(i) = False
      End If
    
      If (isGlobalCancel) Then
        blDeleteIsCancelled = True
      End If
    
      If (isWarning) Then
        blWarningDisplayed = True
      End If
    End If 'if blDeleteIsCancelled
    
  Next i
End If

 


If Not blCancelAll Then
  For i = 0 To nOrdWeds - 1
    If ordWedDelete(i) Then
      If Not wedMayDelete_prepareDelete(ordWeds(i), True, ordWeds, ordWedDelete, nOrdWeds) Then
        blCancelAll = True
        Exit For
      End If
    End If
  Next i
End If
  
If (blCancelAll) Then
  For i = 0 To nOrdWeds - 1
    ordWedDelete(i) = False
  Next i
End If


'Now convert data back to original.
For i = 0 To nOrdWeds - 1
  wedDelete(ordWedOrgNr(i)) = ordWedDelete(i)
Next i


wedMayDeleteMultiple = True
Exit Function
fout:
MsgBox Err & " wedMayDeleteMultiple" & vbCrLf & Error$, 16
Exit Function
End Function


Private Function wedMayDelete_prepareDelete_delOrClear(ByVal wednr As Long, ByVal blIsMultiple As Boolean, ByRef wedsToDelete() As Long, ByRef wedsWillDelete() As Boolean, ByVal nWedsToDelete, ByVal fNameWed As String, fNameToUpdate As String, ByVal tbName As String) As Boolean
On Error GoTo fout
wedMayDelete_prepareDelete_delOrClear = False


If (fNameWed = fNameToUpdate) Then

  Dim sql As String
  sql = "Delete * from [" & tbName & "] where [" & fNameWed & "] =" & wednr & ";"
  DoCmd.SetWarnings False
  DoCmd.RunSQL sql
  DoCmd.SetWarnings True

Else
  
  Dim rs As Recordset
  Set rs = CurrentDb().OpenRecordset("select * from [" & tbName & "] where [" & fNameToUpdate & "] = " & wednr)
  
  rs.MoveFirst
  Do Until rs.EOF
    Dim tpWed As Long, tpInsWed As Long
    tpWed = Nz(rs(fNameWed))
    
    Dim tpRefWillDel As Boolean
    tpRefWillDel = False
    
    If (blIsMultiple) Then
      Dim lkpPos As Integer
      lkpPos = bSearchLong(tpWed, nWedsToDelete, wedsToDelete)
      If lkpPos >= 0 Then
        If (wedsWillDelete(lkpPos)) Then
          tpRefWillDel = True
        End If
      End If
    Else
      If tpWed = wednr Then
        tpRefWillDel = True
      End If
    End If
    
    If (tpRefWillDel) Then
      rs.Delete
    Else
      rs.Edit
        rs(fNameToUpdate) = Null
      rs.Update
    End If
    
    rs.MoveNext
  Loop
  
  appCleanRS rs

End If



wedMayDelete_prepareDelete_delOrClear = True
Exit Function
fout:
If (Err = 3021) Then Resume Next
MsgBox Err & " wedMayDelete_prepareDelete_delOrClear" & vbCrLf & Error$, 16
Exit Function
End Function


Private Function wedMayDelete_prepareDelete(ByVal wednr As Long, ByVal blIsMultiple As Boolean, ByRef wedsToDelete() As Long, ByRef wedsWillDelete() As Boolean, ByVal nWedsToDelete) As Boolean
On Error GoTo fout
wedMayDelete_prepareDelete = False



Dim nTbs As Integer
Dim sTbNames(0 To 100) As String
Dim fNamesWed(0 To 100) As String
Dim fNamesToUpdate(0 To 100) As String

wediMayDelete_prepareDeleteTables nTbs, sTbNames, fNamesWed, fNamesToUpdate

Dim i  As Integer

For i = 0 To nTbs - 1

  If Not wedMayDelete_prepareDelete_delOrClear(wednr, blIsMultiple, wedsToDelete, wedsWillDelete, nWedsToDelete, fNamesWed(i), fNamesToUpdate(i), sTbNames(i)) Then
    Exit Function
  End If

Next i

'Also need to update MainWedstrijdNummers
'This needs to be treated specially due to locking mechanisms.

Dim rs As Recordset
Set rs = CurrentDb().OpenRecordset("select * from [" & TNM_WED & "] where [" & FNM_WED_MAIN_NR & "] = " & wednr)
rs.MoveFirst
Do Until rs.EOF
  Dim tpWed As Long
  tpWed = Nz(rs(FNM_WED_NR))
  
  Dim tpRefWillDel As Boolean
  tpRefWillDel = False
  
  If (blIsMultiple) Then
    Dim lkpPos As Integer
    lkpPos = bSearchLong(tpWed, nWedsToDelete, wedsToDelete)
    If lkpPos >= 0 Then
      If (wedsWillDelete(lkpPos)) Then
        tpRefWillDel = True
      End If
    End If
  Else
    If tpWed = wednr Then
      tpRefWillDel = True
    End If
  End If
  
  If (tpRefWillDel) Then
    'Check to see if we have a forward reference.
    If (blIsMultiple) Then
      If (tpWed < wednr) Then
        Err.Raise 1, , "Het eerste deel van de meerdaagse wedstrijd: " & wednr & vbCrLf & "heeft een hoger wedstrijdnummer dan een van de latere delen: " & tpWed & _
          vbCrLf & "Dit kan problemen opleveren met het verwijderen. " & vbCrLf & _
          "Probeer deze wedstrijden een-voor-een te verwijderen."
      End If
    End If
  Else
    rs.Edit
      rs(FNM_WED_PART_OF_MEET) = False
      rs(FNM_WED_MAIN_NR) = Null
    rs.Update
  End If
     
  rs.MoveNext
Loop

appCleanRS rs



Dim dsData As DIR_SERVER_DATA

If Not dsInit(dsData, False, "") Then
  Exit Function
End If

Dim blDummy As Boolean, sDummy As String
If Not dsDeletePropertyByName(dsData, appGetName & "\WED_AUX_DATA\" & wednr, blDummy, sDummy) Then
  Exit Function
End If

If Not dsClean(dsData) Then
  Exit Function
End If



wedMayDelete_prepareDelete = True
Exit Function
fout:
If (Err = 3021) Then Resume Next
MsgBox Err & " wedMayDelete_prepareDelete" & vbCrLf & Error$, 16
Exit Function
End Function



Public Function wedMayDelete(wednr As Long) As Boolean
'Return true als wedstrijd verwijderd moet worden, false anders...
'Deze functie zoekt eerst uit of een wedstrijd verwijderd kan worden en zo ja, maakt alles klaar om het te verwijderen.
'Bedoeld om in wed_master na het drukken op Delete eerst een voorbereiding tot deleten te initiren.

On Error GoTo fout




wedMayDelete = False


Dim blDummy As Boolean

If Not wediMayDelete_prompt(wednr, False, False, False, blDummy, blDummy) Then
  Exit Function
End If

Dim lDummy(0 To 0) As Long
Dim bDummy(0 To 0) As Boolean

If Not wedMayDelete_prepareDelete(wednr, False, lDummy, bDummy, 0) Then
  Exit Function
End If

'Nu hebben we alles gedaan wat nodig is..

wedMayDelete = True



Exit Function
fout:
MsgBox Err & " wedMayDelete" & vbCrLf & Error$, 16
Exit Function

'debug
On Error GoTo 0
Resume


Exit Function
End Function