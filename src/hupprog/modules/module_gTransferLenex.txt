Option Compare Database
Option Explicit


Global Const LX_VALID = -1
Global Const LX_INVALID_FNAME = 0
Global Const LX_UZIP_FAILURE = 1
Global Const LX_ZIP_CNT_INVALID = 2
Global Const LX_XML_SYN_INVALID = 3
Global Const LX_XML_STR_INVALID = 4
Global Const LX_UNKNOWN_FAILURE = 5


'Special numbering conventions:

'ageGroups:
'  xid for special single agegroup for a prog nr is 3* prID
'  xid for agegroups in gIMP_LEN_Leeftijdsgroepen is 3* lftID + 1
'  xid for other agegroups in 2 mod 3



'Elements ENTRIES, RESULTS and ARCHIVEDTIMES are shared by ATHLETE and RELAY.
'Therefore: ATHELETEXID = 0 mod 2
'           RELAYXID = 1 Mod 2

'Element RELAYPOSITIONS is shared by RELAY, ENTRY, RESULT and ARCHIVEDTIME
'Therefore chose: ENTRY = 0 mod 7
'                 RESULT = 1 mod 7
'                 RELAY = 2 Mod 7
'                 ARCHIVEDTIME = 3 mod 7
            
'This can be realized by the choice:
'RELAYXID = RELAY_ID * 14 + 9
'ATHLETEXID = ATHLETE_ID * 2
'ENTRYXID = ENTRY_ID * 7
'RESULTXID = RESULT_ID * 7 + 1
'ARCHIVEDTIMEXID = ARCHIVEDTIME_ID * 7 + 3



Private Function lenFormatHandicap(ByVal sHnd As String) As String

lenFormatHandicap = ""
If sHnd = "AB" Then
  lenFormatHandicap = "GER.AB"
ElseIf (sHnd = "GB") Then
  lenFormatHandicap = "GER.GB"
ElseIf (Left(sHnd, 1) = "S") Then
  Dim lNr As Long
  lNr = CLng(val(Right(sHnd, Len(sHnd) - 1)))
  lenFormatHandicap = CStr(lNr)
End If

If (lenFormatHandicap = "") Then
  lenFormatHandicap = "0"
End If

End Function

Public Function lenParseHandicap(ByVal sLenHnd As String) As String

lenParseHandicap = ""
If sLenHnd = "GER.AB" Then
  lenParseHandicap = "GER.AB"
ElseIf (sLenHnd = "GER.GB") Then
  lenParseHandicap = "GB"
Else
  Dim lNr As Long
  lNr = CLng(val(sLenHnd))
  Dim blIsValid As Boolean
  blIsValid = False
  If (lNr > 0) And (lNr <= 15) Then
    blIsValid = True
  ElseIf (lNr = 20) Or (lNr = 34) Or (lNr = 49) Then
    blIsValid = True
  End If
  
  If (blIsValid) Then
    lenParseHandicap = "S" & CStr(lNr)
  End If
End If

End Function




Public Function lenCleanupDuplicateLimits() As Boolean
On Error GoTo fout
lenCleanupDuplicateLimits = False

'Need to remove any duplicate limits.
'For now, don't bother.

lenCleanupDuplicateLimits = True
Exit Function
fout:
MsgBox Err & " " & Error$, 16
Exit Function
End Function

Public Function lenCleanupDuplicateRecords() As Boolean
On Error GoTo fout
lenCleanupDuplicateRecords = False

'Need to remove any duplicate limits.
'For now, don't bother.

lenCleanupDuplicateRecords = True
Exit Function
fout:
MsgBox Err & " " & Error$, 16
Exit Function
End Function

Private Function lenAppendLimit(ByVal isVVT As Boolean, ByVal isMinLim As Boolean, ByVal isMaxLim As Boolean, ByVal bn As Integer, ByVal cat As String, ByVal td As Double, ByVal afst As String, ByVal slag As String, ByVal lProgID As Long, ByRef lastUsedLimID As Long, ByRef rsLims As Recordset) As Boolean
On Error GoTo fout
lenAppendLimit = False

rsLims.AddNew
  lastUsedLimID = lastUsedLimID + 1
  rsLims("LIM_ID") = lastUsedLimID
  
  
  rsLims("LIM_IsVVT") = isVVT
  rsLims("LIM_IsMinLim") = isMinLim
  rsLims("LIM_IsMaxLim") = isMaxLim
  rsLims("LIM_Baan") = bn
  rsLims("LIM_Categorie") = hzn(cat)
  rsLims("LIM_Tijd") = td
  rsLims("LIM_Afstand") = hzn(afst)
  rsLims("LIM_Slag") = hzn(slag)
  If (isVVT) Then
    rsLims("LIM_Name") = "Vvt"
  Else
    rsLims("LIM_Name") = "Limiet"
  End If
  
  If (lProgID >= 0) Then
    rsLims("LIM_PR_ID") = lProgID
  End If
  
rsLims.Update

lenAppendLimit = True
Exit Function
fout:
MsgBox Err & " " & Error$, 16
Exit Function
End Function
Public Function lenExtractLimsRecsFromCatInfo(ByVal wedBnLen As Integer, ByVal wedQlfConvMode As String, ByVal lProgID As Long, ByVal prAfst As String, ByVal prSlag As String, ByRef catInf As CAT_INFO, ByRef lastUsedRecID As Long, ByRef lastUsedLimID As Long, ByRef rsRecs As Recordset, ByRef rsLims As Recordset, ByVal expLims As Boolean, ByVal expRecs As Boolean) As Boolean
On Error GoTo fout
lenExtractLimsRecsFromCatInfo = False

If (catInf.vvt > 0.01) Then
  If Not lenAppendLimit(True, False, False, 25, Nz(Trim(catInf.cat)), catInf.vvt, prAfst, prSlag, lProgID, lastUsedLimID, rsLims) Then
    Exit Function
  End If
End If

Dim is25Of50 As Boolean, lim25 As Double, lim50 As Double, limMin As Double, limMax As Double, limMid As Double, hasMid As Boolean

Dim limS As String
limS = Trim(catInf.lim)

If (expLims) Then
    If (limS <> "") Then
      If (analyzeLimiet(limS, is25Of50, lim25, lim50, limMin, limMax, hasMid, limMid)) Then
        'Export the limit.
        If (is25Of50) Then
          If Not lenAppendLimit(False, False, True, 25, Nz(Trim(catInf.cat)), lim25, prAfst, prSlag, lProgID, lastUsedLimID, rsLims) Then
            Exit Function
          End If
          If Not lenAppendLimit(False, False, True, 50, Nz(Trim(catInf.cat)), lim50, prAfst, prSlag, lProgID, lastUsedLimID, rsLims) Then
            Exit Function
          End If
        Else
          Dim blWriteBoth As Boolean
          blWriteBoth = Not (wedQlfConvMode = QLF_CONV_SAME_LN_ONLY)
          If (limMin > 0.01) Then
            If (blWriteBoth) Then
              If Not lenAppendLimit(False, True, False, 25, Nz(Trim(catInf.cat)), limMin, prAfst, prSlag, lProgID, lastUsedLimID, rsLims) Then
                 Exit Function
              End If
              If Not lenAppendLimit(False, True, False, 50, Nz(Trim(catInf.cat)), limMin, prAfst, prSlag, lProgID, lastUsedLimID, rsLims) Then
                Exit Function
              End If
            Else
              If Not lenAppendLimit(False, True, False, wedBnLen, Nz(Trim(catInf.cat)), limMin, prAfst, prSlag, lProgID, lastUsedLimID, rsLims) Then
                Exit Function
              End If
            End If
          End If
          
          If (limMax < 8888) Then
            If (blWriteBoth) Then
              If Not lenAppendLimit(False, False, True, 25, Nz(Trim(catInf.cat)), limMax, prAfst, prSlag, lProgID, lastUsedLimID, rsLims) Then
                 Exit Function
              End If
              If Not lenAppendLimit(False, False, True, 50, Nz(Trim(catInf.cat)), limMax, prAfst, prSlag, lProgID, lastUsedLimID, rsLims) Then
                Exit Function
              End If
            Else
              If Not lenAppendLimit(False, False, True, wedBnLen, Nz(Trim(catInf.cat)), limMax, prAfst, prSlag, lProgID, lastUsedLimID, rsLims) Then
                Exit Function
              End If
            End If
          End If
        End If
      End If
    End If 'if limS <> ""
End If 'if expLims

'Now look at records.
If (expRecs) Then
  If (catInf.rec.tijd > 0.01) Then
    'Have to export the record.
    'For the moment we do not bother (too many restrictions etc).
  End If
End If







lenExtractLimsRecsFromCatInfo = True
Exit Function
fout:
MsgBox Err & " " & Error$, 16
Exit Function
End Function







Private Function lenFormatStartnummer(st As String, ByVal yob As Long) As String
On Error Resume Next
If (yob >= 2000) Then
  lenFormatStartnummer = "20" & Left(st, 2) & Right(st, 5)
Else
  lenFormatStartnummer = "19" & Left(st, 2) & Right(st, 5)
End If
End Function

Private Function lenFormatAge(ByVal age As Integer) As String
On Error Resume Next
If (age <= 0) Then
  lenFormatAge = "-1"
Else
  lenFormatAge = age
End If

End Function
Private Function lenFormatBirthDate(ByVal gebDate As Date, jaartal As Long) As String
On Error Resume Next
If Not lenDateIsValid(gebDate) Then
  gebDate = DateAdd("yyyy", jaartal - 1900, #1/1/1900#)
End If
lenFormatBirthDate = lenFormatDate(gebDate)
  
End Function

Private Function lenParseBoolean(s As String) As Boolean
On Error Resume Next
lenParseBoolean = False
If (s = "TRUE" Or s = "true" Or s = "yes" Or s = "-1") Then
  lenParseBoolean = True
End If
End Function
Private Function lenFormatBoolean(b As Boolean) As String
On Error Resume Next
If (b) Then
  lenFormatBoolean = "true"
Else
  lenFormatBoolean = "false"
End If

End Function


Private Function lenApplyGeslacht(cat As String, ges As String) As String
On Error Resume Next
lenApplyGeslacht = cat
If (cat = "") Then
  If (ges = "M") Then
    lenApplyGeslacht = "HEREN"
  ElseIf (ges = "V") Then
    lenApplyGeslacht = "DAMES"
  Else
    lenApplyGeslacht = "MIX"
  End If
End If

If (m_of_v(cat) = "*" And ges <> "*") Then
  If (cat = "MIX" Or cat = "ZWEEDS") Then
    If (ges = "M") Then
      lenApplyGeslacht = "HEREN"
    ElseIf (ges = "V") Then
      lenApplyGeslacht = "DAMES"
    End If
  ElseIf Left(cat, 2) = "MJ" Then
    If (ges = "M") Then
      lenApplyGeslacht = "J" & Right(cat, Len(cat) - 2)
    ElseIf (ges = "V") Then
      lenApplyGeslacht = "M" & Right(cat, Len(cat) - 2)
    End If
  End If
End If
    

End Function

Private Function lenFormatLimitType(ByVal isVVT As Boolean, ByVal isMinLim As Boolean, ByVal isMaxLim As Boolean) As String
On Error Resume Next
lenFormatLimitType = ""
If (isVVT) Then
  lenFormatLimitType = "DEFAULT"
ElseIf isMinLim Then
  lenFormatLimitType = "MINIMUM"
ElseIf isMaxLim Then
  lenFormatLimitType = "MAXIMUM"
End If

End Function



Private Sub lenParseLimitType(ByVal limType As String, ByRef isVVT As Boolean, ByRef isMinLim As Boolean, ByRef isMaxLim As Boolean, ByRef isLevel As Boolean)
On Error Resume Next
isMaxLim = True
isVVT = False
isMinLim = False
isLevel = False

If (limType = "MINIMUM") Then
  isMaxLim = False
  isMinLim = True
ElseIf (limType = "DEFAULT") Then
  isMaxLim = False
  isVVT = True
ElseIf (limType = "LEVEL") Then
  isMaxLim = False
  isLevel = True
End If

End Sub



Private Function lenParseCourse(ByVal course As String) As Integer
On Error Resume Next
lenParseCourse = IIf(course = "LCM", 50, 25)
End Function
Private Function lenFormatBaanlengte(ByVal baan As Integer) As String
On Error Resume Next
If (baan = 50) Then
  lenFormatBaanlengte = "LCM"
Else
  lenFormatBaanlengte = "SCM"
End If
End Function

Private Function lenParseResultStatus(ByVal st As String) As String
On Error Resume Next
Dim tpS As String
If (st = "") Then
  lenParseResultStatus = ""
  Exit Function
End If
tpS = ""

If (st = "DSQ") Then
  tpS = "DQ"
ElseIf (st = "DNF") Then
  tpS = "AF"
ElseIf (st = "DNS") Then
  tpS = DIS_NGZA
ElseIf (st = "WDR") Then
  tpS = DIS_AFM
ElseIf (st = "NED.SICK") Then
  tpS = DIS_NG
ElseIf (st = "SICK") Then
  tpS = DIS_NG
End If
lenParseResultStatus = tpS
  
End Function

Private Function lenFormatDiscode(ByVal dis As String) As String
On Error Resume Next
lenFormatDiscode = ""
If (dis = "") Then
  Exit Function
End If
If (dis = DIS_NG) Then
  lenFormatDiscode = "SICK"
ElseIf (dis = "AF") Then
  lenFormatDiscode = "DNF"
ElseIf (dis = DIS_NGZA) Then
  lenFormatDiscode = "DNS"
ElseIf (dis = DIS_AFM) Then
  lenFormatDiscode = "WDR"
Else
  lenFormatDiscode = "DSQ"
End If

End Function


Private Function lenFormatThreeDigitCode(ByVal Code As Long) As String
On Error Resume Next
If (Code < 0) Then
  lenFormatThreeDigitCode = ""
ElseIf (Code < 1000) Then
  lenFormatThreeDigitCode = Format(Code, "000")
Else
  Code = Code - 1000
  Dim ia As Integer, ib As Integer, ic As Integer
  ic = Code Mod 26
  Code = Code \ 26
  ib = Code Mod 26
  Code = Code \ 26
  ia = Code Mod 26
  
  lenFormatThreeDigitCode = Chr(Asc("A") + ia) & Chr(Asc("A") + ib) & Chr(Asc("A") + ic)
  
  
End If
End Function

'todo: move to gLenex
Public Function lenParseStartnr(ByVal sCode As String, ByVal sNationCode As String, ByVal dGebDate As Date, ByRef maxUsedExtAthID As Long, ByRef isCodeValid As Boolean) As String
On Error Resume Next
lenParseStartnr = ""
isCodeValid = False

If (lenIsValidStartnr(sCode)) Then
  If (Len(sCode) = 8) Then
    lenParseStartnr = sCode
  ElseIf (Len(sCode) = 9) Then
    lenParseStartnr = Mid(sCode, 3, 2) & "-" & Right(sCode, 5)
  Else
    lenParseStartnr = Left(sCode, 2) & "-" & Right(sCode, 5)
  End If
  isCodeValid = True
Else
  Dim yr As Integer
  yr = CInt(val(Format(dGebDate, "yy")))
  
  Dim fp As String
  
  If (Len(sNationCode) >= 2) Then
    fp = Left(sNationCode, 2)
  Else
    fp = "XX"
  End If
  
  lenParseStartnr = Format(yr, "00") & "-" & fp & lenFormatThreeDigitCode(maxUsedExtAthID + 1)
  maxUsedExtAthID = maxUsedExtAthID + 1
End If
  

End Function


'todo: move to gLenex
Public Function lenParseDepotnr(sCode As String, sNationCode As String, ByRef maxUsedExtDepNr As Long, ByRef isCodeValid As Boolean) As String
On Error Resume Next
lenParseDepotnr = ""
isCodeValid = False

If (lenIsValidDepotnr(sCode)) Then
  lenParseDepotnr = sCode
  isCodeValid = True
Else
  isCodeValid = False
  Dim fp As String
  
  If (Len(sNationCode) >= 2) Then
    fp = Left(sNationCode, 2)
  Else
    fp = "XX"
  End If
  
  lenParseDepotnr = fp & "-" & lenFormatThreeDigitCode(maxUsedExtDepNr + 1)
  maxUsedExtDepNr = maxUsedExtDepNr + 1
  
End If


Exit Function
End Function


'Todo: move to module gLenex
Public Function lenIsValidDepotnr(dp As String) As Boolean
On Error Resume Next
lenIsValidDepotnr = False
If Len(dp) = 6 Then
  If (Mid(dp, 3, 1) = "-") Then
    lenIsValidDepotnr = True
  End If
End If
End Function


Private Function lenParseProgType(pt As String, finType As String) As String
On Error Resume Next
Dim tpS As String
If (pt = "FIN") Then
  If (finType = "A") Then
    tpS = PROG_TYPE_AFIN
  ElseIf (finType = "B") Then
    tpS = PROG_TYPE_BFIN
  ElseIf (finType = "C") Then
    tpS = PROG_TYPE_CFIN
  Else
    tpS = PROG_TYPE_FIN
  End If
ElseIf (pt = "SEM") Then
  tpS = PROG_TYPE_SF
ElseIf (pt = "QUA") Then
  tpS = PROG_TYPE_QF
ElseIf (pt = "PRE") Then
  tpS = PROG_TYPE_SER
ElseIf (pt Like "SO*") Then
  tpS = PROG_TYPE_SWOFF
ElseIf (pt = "TIM") Then
  tpS = PROG_TYPE_SER
ElseIf (pt = "FHT") Then
  tpS = PROG_TYPE_FST
End If
lenParseProgType = tpS

End Function

Private Function lenFormatFinalType(pt As String) As String
On Error Resume Next
Dim tpS As String
If (pt = PROG_TYPE_AFIN) Then
  tpS = "A"
ElseIf (pt = PROG_TYPE_BFIN) Then
  tpS = "B"
ElseIf (pt = PROG_TYPE_CFIN) Then
  tpS = "C"
Else
  tpS = ""
End If
lenFormatFinalType = tpS
  
End Function
Public Function lenQRYFormatProgType(pt As String) As String
On Error Resume Next
Dim tpS As String
If (pt = PROG_TYPE_FIN Or pt = PROG_TYPE_AFIN Or pt = PROG_TYPE_BFIN Or pt = PROG_TYPE_CFIN) Then
  tpS = "FIN"
ElseIf (pt = PROG_TYPE_SF) Then
  tpS = "SEM"
ElseIf (pt = PROG_TYPE_QF) Then
  tpS = "QUA"
ElseIf (pt = PROG_TYPE_FST) Then
  tpS = "FHT"
ElseIf (pt = PROG_TYPE_SER) Then
  tpS = "TIM"
ElseIf (pt = PROG_TYPE_SWOFF) Then
  tpS = "SOP"
Else
  tpS = "TIM"
End If
lenQRYFormatProgType = tpS

End Function
Public Function lenQRYReformatProgType(lxProgType As String, prvLXProgType As String) As String
On Error Resume Next
lenQRYReformatProgType = lxProgType
If (lxProgType = "SOP") Then
  If (prvLXProgType = "SEM") Then
    lenQRYReformatProgType = "SOS"
  ElseIf (prvLXProgType = "QUA") Then
    lenQRYReformatProgType = "SOQ"
  End If
End If
  

End Function
Public Function lenQRYReformatPrvProgType(prvLXProgType, lxProgType) As String
On Error Resume Next
lenQRYReformatPrvProgType = prvLXProgType
If (prvLXProgType = "TIM" And (lxProgType = "QUA" Or lxProgType = "SEM" Or lxProgType = "FIN")) Then
  lenQRYReformatPrvProgType = "PRE"
End If

End Function


Private Function lenParseSwimtime(tm As String) As Double
On Error Resume Next
If (tm = "NT" Or tm = "") Then
  lenParseSwimtime = 0
Else
  Dim hr As Integer, min As Integer, sec As Integer, h As Integer
  hr = CInt(val(Mid(tm, 1, 2)))
  min = CInt(val(Mid(tm, 4, 2)))
  sec = CInt(val(Mid(tm, 7, 2)))
  h = CInt(val(Mid(tm, 10, 2)))
  lenParseSwimtime = hr * CDbl(10000) + min * CDbl(100) + CDbl(sec) + h * 0.01
End If
  

End Function
Public Function lenFormatSwimTime(t As Double) As String
On Error Resume Next
If (t < 0.01 Or (t > 8888 And t < 9999.999)) Then
  lenFormatSwimTime = "NT"
  Exit Function
End If

Dim hr As Integer, min As Integer, sec As Integer, h As Integer
hr = 0
Dim tot As Long
tot = CLng(t * 100)
hr = tot \ 1000000
tot = tot Mod 1000000
min = tot \ 10000
tot = tot Mod 10000
sec = tot \ 100
h = tot Mod 100

lenFormatSwimTime = Format(hr, "00") & ":" & Format(min, "00") & ":" & Format(sec, "00") & "." & Format(h, "00")
End Function

Private Function lenParseGender(gender As String) As String
On Error Resume Next
If (gender = "M") Then
  lenParseGender = "M"
ElseIf (gender = "F") Then
  lenParseGender = "V"
Else
  lenParseGender = "*"
End If
End Function
Private Function lenFormatGeslacht(ges As String, ByVal blUseXForMixed As Boolean) As String
On Error Resume Next
If (ges = "M") Then
  lenFormatGeslacht = "M"
ElseIf (ges = "V") Then
  lenFormatGeslacht = "F"
ElseIf (blUseXForMixed) Then
  lenFormatGeslacht = "X"
Else
  lenFormatGeslacht = ""
End If
End Function



Private Function lenFormatCategorie(ByVal cat As String, ByVal wedAgeDate As Date, ByVal lftModeBep As String, ByRef gender As String, ByRef ageMin As Integer, ByRef ageMax As Integer, ByRef isTotAge As Boolean, ByRef isMCat As Boolean, ByVal blUseXForMixed As Boolean) As Boolean
On Error GoTo fout
lenFormatCategorie = False



'Here have to translate the age category into LENEX readable terms.
Dim catMinAge As Integer, catMaxAge As Integer
If Not catGetAllowedAgeRange_bare(cat, catMinAge, catMaxAge, wedAgeDate, lftModeBep, lftModeBep, True) Then
  Exit Function
End If

isTotAge = False


If (catIsEstafTotalAge(cat)) Then
  isTotAge = True
End If
    
If (catMinAge <= 0) Then
  ageMin = -1
Else
  ageMin = catMinAge
End If
If (catMaxAge >= CAT_MAX_AGE) Then
  ageMax = -1
Else
  ageMax = catMaxAge
End If

isMCat = False
If (catIsMCat(cat)) Then
  isMCat = True
End If

Dim ges As String
ges = m_of_v(cat)

gender = lenFormatGeslacht(ges, blUseXForMixed)



lenFormatCategorie = True
Exit Function
fout:
MsgBox Err & " " & Error$, 16
Exit Function
End Function



Public Function lenParseAgeGroup(ByVal lftModeBep As String, ByVal ageDate As Date, ByVal lenGender As String, ByVal ageMin As Integer, ByVal ageMax As Integer, ByVal isTotAge As Boolean, Optional isMCat As Boolean = False) As String
On Error Resume Next

Dim sGes As String
sGes = lenParseGender(lenGender)

If (isMCat) Then
  lenParseAgeGroup = catCreateMCat(sGes)
Else
  lenParseAgeGroup = catCreateFromAge(True, True, ageDate, lftModeBep, sGes, ageMin, ageMax)
End If

End Function

Private Function lenParseStroke(s As String) As String
On Error Resume Next
If (s = "BACK") Then
  lenParseStroke = "RUG"
ElseIf (s = "BREAST") Then
  lenParseStroke = "SCHOOL"
ElseIf (s = "FLY") Then
  lenParseStroke = "VLINDER"
ElseIf (s = "FREE") Then
  lenParseStroke = "VRIJ"
ElseIf (s = "MEDLEY") Then
  lenParseStroke = "WISSEL"
Else
  lenParseStroke = "ONB"
End If
  


End Function
Private Function lenFormatStroke(s As String) As String
On Error Resume Next
If (s = "RUG") Then
  lenFormatStroke = "BACK"
ElseIf (s = "SCHOOL") Then
  lenFormatStroke = "BREAST"
ElseIf (s = "VLINDER") Then
  lenFormatStroke = "FLY"
ElseIf (s = "VRIJ") Then
  lenFormatStroke = "FREE"
ElseIf (s = "WISSEL") Then
  lenFormatStroke = "MEDLEY"
Else
  lenFormatStroke = "UNKNOWN"
End If
End Function

Private Function lenParseCurrency(s As String) As Double
On Error Resume Next
lenParseCurrency = val(s) * 0.01
End Function
Private Function lenFormatCurrency(d As Double) As String
On Error Resume Next
lenFormatCurrency = CStr(CLng(d * 100))
End Function
Private Function lenParseLxQLFRelayMode(s As String) As String
On Error Resume Next
lenParseLxQLFRelayMode = RELAY_MODE_BOTH
If (s = LX_RELAY_MODE_CLUB) Then
  lenParseLxQLFRelayMode = RELAY_MODE_TEAM
ElseIf (s = LX_RELAY_MODE_IND) Then
  lenParseLxQLFRelayMode = RELAY_MODE_IND
ElseIf (s = LX_RELAY_MODE_BOTH) Then
  lenParseLxQLFRelayMode = RELAY_MODE_BOTH
End If
End Function

Private Function lenFormatQLFRelayMode(hupRelayMode As String) As String
On Error Resume Next
lenFormatQLFRelayMode = LX_RELAY_MODE_NONE
If (hupRelayMode = RELAY_MODE_IND) Then
  lenFormatQLFRelayMode = LX_RELAY_MODE_IND
ElseIf (hupRelayMode = RELAY_MODE_TEAM) Then
  lenFormatQLFRelayMode = LX_RELAY_MODE_CLUB
End If

End Function

Private Function lenParseQLFConversion(conv As String) As String
On Error Resume Next
If (conv = "NONE") Then
  lenParseQLFConversion = QLF_CONV_SAME_LN_ONLY
ElseIf (conv = "FINA_POINTS") Then
  lenParseQLFConversion = QLF_CONV_FINA_POINTS
Else
  lenParseQLFConversion = QLF_CONV_NONE
End If
  
End Function
Private Function lenFormatQLFConversion(conv As String) As String
On Error Resume Next
If (conv = QLF_CONV_SAME_LN_ONLY) Then
  lenFormatQLFConversion = "NONE"
ElseIf (conv = QLF_CONV_FINA_POINTS) Then
  lenFormatQLFConversion = "FINA_POINTS"
ElseIf (conv = QLF_CONV_PREFER_LCM) Then
  'This is not yet supported in lenex.
  lenFormatQLFConversion = "LCM_AS_SCM"
Else
  lenFormatQLFConversion = "LCM_AS_SCM"
End If
End Function



Private Function lenIsAutoTiming(timeStr As String) As Boolean
On Error Resume Next
lenIsAutoTiming = False
If (timeStr = "AUTOMATIC") Then
  lenIsAutoTiming = True
End If
  
End Function
Private Function lenFormatTiming(isAutoTiming As Boolean) As String
On Error Resume Next
If (isAutoTiming) Then
  lenFormatTiming = "AUTOMATIC"
Else
  lenFormatTiming = "MANUAL1"
End If

End Function


Private Function lenParseDaytime(dTime As String) As Date
On Error Resume Next
lenParseDaytime = #12:00:00 AM#
lenParseDaytime = CDate(dTime)
End Function



Private Function lenGetMonthStr(mn As Integer) As String
On Error Resume Next
Dim tpS As String
tpS = ""
Select Case mn
  Case 1
    tpS = Format(DateAdd("m", 0, #1/1/2000#), "mmmm")
  Case 2
    tpS = Format(DateAdd("m", 1, #1/1/2000#), "mmmm")
  Case 3
    tpS = Format(DateAdd("m", 2, #1/1/2000#), "mmmm")
  Case 4
    tpS = Format(DateAdd("m", 3, #1/1/2000#), "mmmm")
  Case 5
    tpS = Format(DateAdd("m", 4, #1/1/2000#), "mmmm")
  Case 6
    tpS = Format(DateAdd("m", 5, #1/1/2000#), "mmmm")
  Case 7
    tpS = Format(DateAdd("m", 6, #1/1/2000#), "mmmm")
  Case 8
    tpS = Format(DateAdd("m", 7, #1/1/2000#), "mmmm")
  Case 9
    tpS = Format(DateAdd("m", 8, #1/1/2000#), "mmmm")
  Case 10
    tpS = Format(DateAdd("m", 9, #1/1/2000#), "mmmm")
  Case 11
    tpS = Format(DateAdd("m", 10, #1/1/2000#), "mmmm")
  Case 12
    tpS = Format(DateAdd("m", 11, #1/1/2000#), "mmmm")
End Select
lenGetMonthStr = tpS
    
End Function

Private Function lenParseDate(ds As String) As Date
On Error Resume Next
If (ds = "") Then
  lenParseDate = #1/1/1900#
  Exit Function
End If
Dim yr As Integer
Dim mn As Integer
Dim dy As Integer
yr = CInt(val(Left(ds, 4)))
mn = CInt(val(Mid(ds, 6, 2)))
dy = CInt(val(Mid(ds, 9, 2)))
If (yr <= 0) Or (dy <= 0) Or (mn <= 0) Then
  lenParseDate = #1/1/1900#
Else
  lenParseDate = CDate(dy & " " & lenGetMonthStr(mn) & " " & yr)
End If

End Function
Private Function lenFormatTime(dt) As String
On Error Resume Next
lenFormatTime = ""
If Not IsNull(dt) Then
  lenFormatTime = Format(dt, "hh:nn")
End If
End Function
Private Function lenFormatDate(dt) As String
On Error Resume Next
lenFormatDate = ""
If Not IsNull(dt) Then
  lenFormatDate = Format(dt, "yyyy-mm-dd")
End If
End Function
Private Function lenFormatDate2(dd As Integer, mm As Integer, yyyy As Integer) As String
On Error Resume Next
lenFormatDate2 = ""
lenFormatDate2 = Format(yyyy, "0000") & "-" & Format(mm, "00") & "-" & Format(dd, "00")
End Function



Private Function lenParseAgeDateType(tp As String, Optional default As String = LFT_MODE_SZYR) As String
On Error Resume Next
If (tp = "") Then
  lenParseAgeDateType = default
ElseIf (tp = "DATE") Then
  lenParseAgeDateType = LFT_MODE_WEDDAT
ElseIf (tp = "YEAR") Then
  lenParseAgeDateType = LFT_MODE_WEDYR_END
Else
  lenParseAgeDateType = LFT_MODE_SZYR
End If
End Function
Private Function lenFormatLftBepaling(lftBep As String) As String
On Error Resume Next
If (lftBep = LFT_MODE_WEDDAT) Then
  lenFormatLftBepaling = "DATE"
ElseIf (lftBep = LFT_MODE_WEDYR_END) Then
  lenFormatLftBepaling = "YEAR"
ElseIf (lftBep = LFT_MODE_SZYR) Then
  lenFormatLftBepaling = "CAN.FNQ"
ElseIf (lftBep = "") Then
  lenFormatLftBepaling = "CAN.FNQ"
Else 'SZ_YR or WEDYR_START or nothing: should not be used.
  lenFormatLftBepaling = "NED"
End If
End Function



Private Function lenAppendLXFee(ByRef fee As Recordset, ByVal feeID As Long, ByVal currencyStr As String, ByVal value As Double, ByVal isPerClub As Boolean, ByVal isPerAthlete As Boolean, ByVal isPerRelay As Boolean, ByVal isMeetGlobalFee As Boolean) As Boolean
On Error GoTo fout
lenAppendLXFee = False

fee.AddNew
  fee("ID_FEE") = feeID
  fee("LEN_VALUE") = lenFormatCurrency(value)
  
  fee("LEN_CURRENCY") = currencyStr
  
  If (isMeetGlobalFee) Then
    Dim lenKostenType As String
    If (isPerClub) Then
      lenKostenType = "CLUB"
    ElseIf isPerAthlete Then
      lenKostenType = "ATHLETE"
    Else
      lenKostenType = "RELAY"
    End If
    
    fee("LEN_TYPE") = hzn(lenKostenType)
  End If
  
fee.Update

lenAppendLXFee = True
Exit Function
fout:
MsgBox Err & " " & Error$, 16
End Function


Private Function lenLoadLXFee(ByRef fee As Recordset, ByVal feeID As Long, ByRef currencyStr As String, ByRef value As Double, ByRef isPerClub As Boolean, ByRef isPerAthlete As Boolean, ByRef isPerRelay As Boolean) As Boolean
On Error GoTo fout
lenLoadLXFee = False

currencyStr = ""
value = 0
isPerAthlete = False
isPerClub = False
isPerRelay = False

If (feeID >= 0) Then
  fee.Seek "=", feeID
  If (Not fee.NoMatch) Then
    'analyze kosten.
    
    value = lenParseCurrency(Nz(fee("LEN_VALUE")))
    currencyStr = Nz(fee("LEN_CURRENCY"))
    
    
    Dim kostenType As String
    kostenType = Nz(fee("LEN_TYPE"))
    
    If (kostenType = "CLUB") Then
      isPerClub = True
    ElseIf (kostenType = "ATHLETE") Then
      isPerAthlete = True
    ElseIf (kostenType = "RELAY") Then
      isPerRelay = True
    End If
  End If
End If


lenLoadLXFee = True
Exit Function
fout:
MsgBox Err & " " & Error$, 16
Exit Function
End Function


Private Function lenLoadLXPool(ByRef pool As Recordset, ByVal poolID As Long, ByRef nBanen As Integer, ByRef iFirstBaan As Integer, ByRef name As String) As Boolean
On Error GoTo fout
lenLoadLXPool = False

nBanen = 6
iFirstBaan = 1
name = ""

If (poolID >= 0) Then
  pool.Seek "=", poolID
  If (Not pool.NoMatch) Then
    name = Nz(pool("LEN_NAME"))
    
    nBanen = 1 + CInt(val(Nz(pool("LEN_LANEMAX")))) - CInt(val(Nz(pool("LEN_LANEMIN"))))
    iFirstBaan = CInt(val(Nz(pool("LEN_LANEMIN"))))
    If (nBanen < 2) Then
      nBanen = 6
    End If
    If (iFirstBaan < 1) Then
      iFirstBaan = 1
    End If
  End If
End If

lenLoadLXPool = True
Exit Function
fout:
MsgBox Err & " " & Error$, 16
Exit Function
End Function

Private Function lenAppendLXPool(ByRef pool As Recordset, ByVal poolID As Long, ByVal nBanen As Integer, ByVal iFirstBaan As Integer, ByVal name As String) As Boolean
On Error GoTo fout
lenAppendLXPool = False

If (iFirstBaan < 1) Then
  iFirstBaan = 1
End If

pool.AddNew
  pool("ID_Pool") = poolID
  
  pool("LEN_LANEMIN") = 1 + (iFirstBaan - 1)
  pool("LEN_LANEMAX") = nBanen + (iFirstBaan - 1)
  pool("LEN_NAME") = hzn(name)

pool.Update

lenAppendLXPool = True
Exit Function
fout:
MsgBox Err & " " & Error$, 16
Exit Function
End Function

Private Function lenLoadLXQualify(ByRef qlf As Recordset, ByVal qlfID As Long, ByRef qlfConv As String, ByRef qlfRelayMode As String, ByRef qlfFromValid As Boolean, ByRef qlfFromDate As Date, ByRef qlfUntilValid As Boolean, ByRef qlfUntilDate As Date) As Boolean
On Error GoTo fout
lenLoadLXQualify = False

qlfConv = lenParseQLFConversion("")
qlfFromValid = False
qlfUntilValid = False
qlfRelayMode = lenParseLxQLFRelayMode("")


If (qlfID >= 0) Then
  qlf.Seek "=", qlfID
  If (Not qlf.NoMatch) Then
    qlfConv = lenParseQLFConversion(Nz(qlf("LEN_CONVERSION")))
    qlfRelayMode = lenParseLxQLFRelayMode(Nz(qlf("LEN_RELAYMODE")))
    Dim qlfFromDatS As String, qlfUntilDatS As String
    qlfFromDatS = Nz(qlf("LEN_FROM"))
    qlfUntilDatS = Nz(qlf("LEN_UNTIL"))
    If (qlfFromDatS <> "") Then
      qlfFromDate = lenParseDate(qlfFromDatS)
      qlfFromValid = lenDateIsValid(qlfFromDate)
    End If
    If (qlfUntilDatS <> "") Then
      qlfUntilDate = lenParseDate(qlfUntilDatS)
      qlfUntilValid = lenDateIsValid(qlfUntilDate)
    End If
  End If
End If

lenLoadLXQualify = True
Exit Function
fout:
MsgBox Err & " " & Error$, 16
Exit Function
End Function

Private Function lenAppendLXQualify(ByRef qlf As Recordset, ByVal qlfID As Long, ByVal qlfConv As String, ByVal qlfRelayMode As String, ByVal qlfFromDate As Date, ByVal qlfUntilDate As Date) As Boolean
On Error GoTo fout
lenAppendLXQualify = False

qlf.AddNew
  qlf("ID_QUALIFY") = qlfID
  qlf("LEN_CONVERSION") = hzn(lenFormatQLFConversion(qlfConv))
  qlf("LEN_RELAYMODE") = hzn(lenFormatQLFRelayMode(qlfRelayMode))
  
  If (lenDateIsValid(qlfFromDate)) Then
    qlf("LEN_FROM") = hzn(lenFormatDate(qlfFromDate))
  Else
    qlf("LEN_FROM") = "1900-01-01"
  End If
  If (lenDateIsValid(qlfUntilDate)) Then
    qlf("LEN_UNTIL") = hzn(lenFormatDate(qlfUntilDate))
  Else
    qlf("LEN_UNTIL") = "2099-01-01"
  End If

qlf.Update


lenAppendLXQualify = True
Exit Function
fout:
MsgBox Err & " " & Error$, 16
Exit Function
End Function

Private Function lenLoadLXAgeDate(ad As Recordset, ByVal ageDateID As Long, ByVal wedDate As Date, ByRef lftBepMode As String, ByRef lftDatValid As Boolean, ByRef lftDat As Date) As Boolean
On Error GoTo fout
lenLoadLXAgeDate = False

lftBepMode = LFT_MODE_SZYR
lftDatValid = False

If (ageDateID >= 0) Then
  ad.Seek "=", ageDateID
  If (Not ad.NoMatch) Then
  
    Dim lxADType As String
    lxADType = Nz(ad("LEN_TYPE"))
    
  
    lftBepMode = lenParseAgeDateType(lxADType)
    
    
    
    
    Dim lftDatS As String
    lftDatS = Nz(ad("LEN_VALUE"))
    If (lftDatS <> "") Then
      lftDat = lenParseDate(lftDatS)
      lftDatValid = lenDateIsValid(lftDat)
    End If
    
    
    If (lftBepMode <> LFT_MODE_SZYR) Then
    
      'Try to see if we can simplify lftModeBep. The tactic will be as follows:
      '-if possibile, make it LFT_MODE_SZYR.
      '-if this is impossible, try LFT_MODE_WEDYR_START or LFT_MODE_WEDYR_END.
    
    
      If (lenDateIsValid(wedDate) And lftDatValid) Then
        'See if we can simplify lftBepMode.
        Dim wedYYYY As Integer, wedMM As Integer, wedDD As Integer
        Dim lftYYYY As Integer, lftMM As Integer, lftDD As Integer
        wedYYYY = CInt(val(Format(wedDate, "yyyy")))
        wedMM = CInt(val(Format(wedDate, "mm")))
        wedDD = CInt(val(Format(wedDate, "dd")))
        
        lftYYYY = CInt(val(Format(lftDat, "yyyy")))
        lftMM = CInt(val(Format(lftDat, "mm")))
        lftDD = CInt(val(Format(lftDat, "dd")))
        
        If (lxADType = LX_LFT_MODE_DATE) Then
          If (lftMM = 1 And lftDD = 1) Then
            If (wedMM >= 8 And (wedYYYY + 1 = lftYYYY)) Or (wedMM < 8 And wedYYYY = lftYYYY) Then
              lftBepMode = LFT_MODE_SZYR
              lftDat = wedDate
            ElseIf (wedYYYY = lftYYYY) Then
              lftBepMode = LFT_MODE_WEDYR_START
              lftDat = wedDate
            End If
          ElseIf (lftMM = 12 And lftDD = 31) Then
            If (wedMM >= 8 And (wedYYYY + 1 = lftYYYY + 1)) Or (wedMM < 8 And wedYYYY = lftYYYY + 1) Then
              lftBepMode = LFT_MODE_SZYR
              lftDat = wedDate
            ElseIf (wedYYYY = lftYYYY) Then
              lftBepMode = LFT_MODE_WEDYR_END
              lftDat = wedDate
            End If
          End If
        ElseIf (lxADType = LX_LFT_MODE_YEAR) Then
          'wrong: LX_LFT_MODE_YEAR means lft at END of year.
          'If (wedMM < 8 And (wedYYYY = lftYYYY)) Then
          '  lftBepMode = LFT_MODE_SZYR
          'End If
          If (wedMM > 8 And (wedYYYY = lftYYYY)) Then
            lftBepMode = LFT_MODE_SZYR
            lftDat = wedDate
          End If
        End If
      End If
    End If
    
    
  End If
End If

lenLoadLXAgeDate = True
Exit Function
fout:
MsgBox Err & " " & Error$, 16
Exit Function
End Function
Private Function lenAppendLXAgeDate(ad As Recordset, ByVal ageDateID As Long, ByVal lftBepMode As String, ByVal fltDat As Date, ByVal wedDat As Date) As Boolean
On Error GoTo fout
lenAppendLXAgeDate = False

ad.AddNew
  ad("ID_AGEDATE") = ageDateID
  
  If (lftBepMode = LFT_MODE_WEDYR_START) Then
    If (lenDateIsValid(wedDat)) Then
      'Have to determine 1 jan of wedstrijd season / year.
      Dim mm As Integer, dd As Integer, yyyy As Integer
      mm = CInt(val(Format(wedDat, "mm")))
      dd = CInt(val(Format(wedDat, "dd")))
      yyyy = CInt(val(Format(wedDat, "yyyy")))
      If (lftBepMode = LFT_MODE_SZYR) And (mm >= 8) Then
        ad("LEN_VALUE") = hzn(lenFormatDate2(1, 1, yyyy + 1))
      Else
        ad("LEN_VALUE") = hzn(lenFormatDate2(1, 1, yyyy))
      End If
    Else
      Err.Raise 1, , "Wedstrijddatum is ongeldig of niet ingevuld!"
    End If
    ad("LEN_TYPE") = hzn(lenFormatLftBepaling(LFT_MODE_WEDDAT))
  Else
    'LFT_MODE_SZYR or LFT_MODE_WEDDAT or LFT_MODE_WEDYR_END or nothing
    ad("LEN_TYPE") = hzn(lenFormatLftBepaling(lftBepMode))
    If (lenDateIsValid(fltDat)) Then
      ad("LEN_Value") = hzn(lenFormatDate(fltDat))
    End If
  End If
ad.Update


lenAppendLXAgeDate = True
Exit Function
fout:
MsgBox Err & " " & Error$, 16
Exit Function
End Function


Private Function lenWriteSimpleCollection(ByRef rs As Recordset, ByVal ID As Long, ByVal objType As String, Optional objTypeMeervoud As String = "") As Boolean
On Error GoTo fout
lenWriteSimpleCollection = False

rs.AddNew
If (objTypeMeervoud = "") Then
  rs("ID_" & objType & "S") = ID
Else
  rs("ID_" & objTypeMeervoud) = ID
End If
rs("SYS_REF_" & objType & "_COLL") = ID
rs.Update

lenWriteSimpleCollection = True
Exit Function
fout:
MsgBox Err & " " & Error$, 16
Exit Function

End Function

Private Function lenAddToCollection(ByRef coll As Recordset, ByVal collID As Long, ByVal objID As Long, ByVal objType As String) As Boolean
On Error GoTo fout
lenAddToCollection = False

coll.AddNew
coll("ID_" & objType & "_COLL") = collID
coll("SYS_REF_CH_" & objType) = objID
coll.Update

lenAddToCollection = True
Exit Function
fout:
MsgBox Err & " " & Error$, 16
Exit Function
End Function

Private Function lenWriteSessionsToXMLTables(ByRef maxUsedKostenID As Long, ByRef glbWedDate As Date, ByRef lftBep As String, ByRef currencyStr As String) As Boolean
On Error GoTo fout
lenWriteSessionsToXMLTables = False


Dim ssOutp As Recordset
Dim ssSQL As String

Set ssOutp = CurrentDb().OpenRecordset("LEN_SESSION")

Dim ssCollOutp As Recordset
Set ssCollOutp = CurrentDb().OpenRecordset("LEN_SESSION_COLL")

Dim mtSessions As Recordset
Set mtSessions = CurrentDb().OpenRecordset("LEN_SESSIONS")

Dim mtOutp As Recordset
Set mtOutp = CurrentDb().OpenRecordset("LEN_MEET")


Dim mtMeetColl As Recordset
Set mtMeetColl = CurrentDb().OpenRecordset("LEN_MEET_COLL")

Dim pools As Recordset
Set pools = CurrentDb().OpenRecordset("LEN_POOL")

Dim ageDate As Recordset
Set ageDate = CurrentDb().OpenRecordset("LEN_AGEDATE")

Dim qualify As Recordset
Set qualify = CurrentDb().OpenRecordset("LEN_Qualify")


Dim evs  As Recordset
Set evs = CurrentDb().OpenRecordset("LEN_EVENTS")


Dim Kosten As Recordset
Set Kosten = CurrentDb().OpenRecordset("LEN_FEE")
Kosten.Index = "P"
Dim kostenColl As Recordset
Set kostenColl = CurrentDb().OpenRecordset("LEN_FEE_COLL")


Dim rsFees As Recordset
Set rsFees = CurrentDb().OpenRecordset("LEN_FEES")


Dim wed As Recordset
Set wed = CurrentDb().OpenRecordset("select * from gIMP_LEN_WEDSTRIJDEN where (not nz([we_PartOfTimeArchive], false) ) order by we_id")
wed.MoveFirst

Dim blIsFirst As Boolean
blIsFirst = True

Dim maxUsedSessionID As Long
maxUsedSessionID = 0
Dim maxUsedPoolID As Long
maxUsedPoolID = 0
'Dim maxUsedAgeDateID As Long
'maxUsedAgeDateID = 0
'Dim maxUsedQualifyID As Long
'maxUsedQualifyID = 0


Dim maxUsedSessionNr As Long
maxUsedSessionNr = 0



Do Until wed.EOF
  If (blIsFirst) Then
    'Output a single meet.
    If Not lenAddToCollection(mtMeetColl, 1, 1, "MEET") Then Exit Function
    
    mtOutp.AddNew
      mtOutp("ID_Meet") = 1
      
      lftBep = Nz(wed("WE_Leeftijdsbepaling"))
      Dim lftDat As Date
      lftDat = Nz(wed("WE_LeeftijdsDatum"), #1/1/1900#)
      Dim wedDat As Date
      wedDat = Nz(wed("WE_Datum"), #1/1/1900#)
      
      glbWedDate = wedDat
      
      If Not lenAppendLXAgeDate(ageDate, 1, lftBep, lftDat, wedDat) Then Exit Function
      mtOutp("SYS_REF_AGEDATE") = 1
      
      mtOutp("LEN_CITY") = wed("WE_Plaats")
      
      
      'check to see if there are clubs.
      Dim nClubs As Long
      nClubs = 0
      nClubs = Nz(DCount("V_ID", "gIMP_LEN_VER", "not (nz([v_partOfRecord], false) or nz([v_partOfTimeArchive], false) )"))
      
      If (nClubs > 0) Then
        mtOutp("SYS_REF_CLUBS") = 1
      End If
      
      'maxUsedContactID = maxUsedContactID + 1
      mtOutp("SYS_REF_CONTACT") = wed("WE_Contact_ID")
      
      mtOutp("LEN_COURSE") = hzn(lenFormatBaanlengte(Nz(wed("WE_Baanlengte"))))
      mtOutp("LEN_NAME") = wed("WE_Beschrijving")
      mtOutp("LEN_NATION") = wed("WE_NATION")
      mtOutp("LEN_ORGANIZER") = wed("WE_Organiserende_Vereniging")
      
      
      Dim tpInsDeadlineDate As Date, tpInsDeadlineTime As Date
      tpInsDeadlineDate = Nz(wed("WE_InsDeadlineDate"), #1/1/1900#)
      tpInsDeadlineTime = Nz(wed("WE_InsDeadlineTime"), #1/1/1900#)
          
      If lenDateIsValid(tpInsDeadlineDate) Then
        mtOutp("LEN_Deadline") = lenFormatDate(tpInsDeadlineDate)
      End If
      
      If Not IsNull(wed("WE_InsDeadlineTime")) Then
        mtOutp("LEN_Deadlinetime") = lenFormatTime(tpInsDeadlineTime)
      End If
      
      
      
      
      
      Dim nBanen As Integer, iFirstBaan As Integer
      nBanen = Nz(wed("WE_AantalBanen"))
      iFirstBaan = Nz(wed("WE_EersteBaan"), 1)
      
      Dim zwbadNaam As String
      zwbadNaam = Nz(wed("WE_Zwembad"))
      
      maxUsedPoolID = maxUsedPoolID + 1
      If (Not lenAppendLXPool(pools, maxUsedPoolID, nBanen, iFirstBaan, zwbadNaam)) Then Exit Function
      mtOutp("SYS_REF_POOL") = maxUsedPoolID
      
      Dim qlfConv As String
      qlfConv = Nz(wed("WE_QLF_CONVERSION"))
      Dim qlfFrom As Date
      qlfFrom = Nz(wed("WE_QLF_FROM"), #1/1/1900#)
      Dim qlfUntil As Date
      qlfUntil = Nz(wed("WE_QLF_UNTIL"), #1/1/1900#)
      Dim qlfRelayMode As String
      qlfRelayMode = Nz(wed("WE_QLF_RelayMode"))
      
      If Not lenAppendLXQualify(qualify, 1, qlfConv, qlfRelayMode, qlfFrom, qlfUntil) Then Exit Function
      
      mtOutp("SYS_REF_QUALIFY") = 1
      
      mtOutp("SYS_REF_SESSIONS") = 1
      
      mtOutp("LEN_TIMING") = hzn(lenFormatTiming(Nz(wed("WE_ElektronischeTijd"))))
      
      'Kosten exporteren.
      mtOutp("SYS_REF_MEETFEEDETAILS") = Null
      
      currencyStr = Nz(wed("WE_Kosten_Currency"))
      
      If (currencyStr = "") Then
        currencyStr = "EUR"
      End If
      
      Dim kostenWritten As Boolean
      kostenWritten = False
      
      Dim kostenBulkVer As Double
      Dim kostenBulkZw As Double
      Dim kostenRelay As Double
      
      kostenBulkVer = Nz(wed("WE_BulkKostenVer"), 0)
      kostenBulkZw = Nz(wed("WE_BulkKostenZwemmer"), 0)
      kostenRelay = Nz(wed("WE_KostenRelay"), 0)
      
      If (kostenBulkVer > 0.01) Then
        mtOutp("SYS_REF_FEE_COLL") = 1
        
        
        
        
        maxUsedKostenID = maxUsedKostenID + 1
        If Not lenAppendLXFee(Kosten, maxUsedKostenID, currencyStr, kostenBulkVer, True, False, False, True) Then Exit Function
        If Not lenAddToCollection(kostenColl, 1, maxUsedKostenID, "FEE") Then Exit Function
               
        kostenWritten = True
      End If
      If (kostenBulkZw > 0.01) Then
        If (Not kostenWritten) Then
          mtOutp("SYS_REF_FEE_COLL") = 1
        End If
        
        maxUsedKostenID = maxUsedKostenID + 1
        If Not lenAppendLXFee(Kosten, maxUsedKostenID, currencyStr, kostenBulkZw, False, True, False, True) Then Exit Function
        If Not lenAddToCollection(kostenColl, 1, maxUsedKostenID, "FEE") Then Exit Function
        
      
        kostenWritten = True
      End If
      If (kostenRelay > 0.01) Then
        If (Not kostenWritten) Then
          mtOutp("SYS_REF_FEE_COLL") = 1
        End If
        
        maxUsedKostenID = maxUsedKostenID + 1
        If Not lenAppendLXFee(Kosten, maxUsedKostenID, currencyStr, kostenRelay, False, False, True, True) Then Exit Function
        If Not lenAddToCollection(kostenColl, 1, maxUsedKostenID, "FEE") Then Exit Function
        
      
        kostenWritten = True
      End If
      
      If (Not kostenWritten) Then
        mtOutp("SYS_REF_FEE_COLL") = Null
        
      Else
      
        'lenex 3.0 uses a new FEES object.
        'We just set it to point to the collection just created
        mtOutp("SYS_REF_FEES") = 1
        If Not lenWriteSimpleCollection(rsFees, 1, "FEE") Then
          Exit Function
        End If
        
      End If
      
      
      mtOutp("SYS_REF_SESSIONS") = 1
      
      If Not lenWriteSimpleCollection(mtSessions, 1, "SESSION") Then Exit Function
      
      
    mtOutp.Update
  
    blIsFirst = False
  End If
  
  ssOutp.AddNew
  ssOutp("ID_SESSION") = wed("WE_ID")
  
  maxUsedSessionNr = maxUsedSessionNr + 1
  ssOutp("LEN_NUMBER") = maxUsedSessionNr
  
  
  If Not lenAddToCollection(ssCollOutp, 1, Nz(wed("WE_ID"), -1), "SESSION") Then Exit Function
  
  ssOutp("LEN_COURSE") = hzn(lenFormatBaanlengte(Nz(wed("WE_Baanlengte"))))
  ssOutp("LEN_DATE") = hzn(lenFormatDate(Nz(wed("WE_DATUM"), #1/1/1900#)))
  If Not IsNull(wed("WE_Aanvang")) Then
    ssOutp("LEN_DAYTIME") = hzn(lenFormatTime(Nz(wed("WE_Aanvang"))))
  End If
  
  If Not IsNull(wed("WE_Inzwemmen")) Then
    ssOutp("LEN_warmupfrom") = hzn(lenFormatTime(Nz(wed("WE_Inzwemmen"))))
  End If
  
  If Not IsNull(wed("WE_AanvangJuryVergadering")) Then
    ssOutp("LEN_officialmeeting") = hzn(lenFormatTime(Nz(wed("WE_AanvangJuryVergadering"))))
  End If
  
  
  ssOutp("SYS_REF_EVENTS") = wed("WE_ID")
  If Not lenWriteSimpleCollection(evs, Nz(wed("WE_ID")), "EVENT") Then Exit Function
  
  
  ssOutp("SYS_REF_JUDGES") = Null
  ssOutp("LEN_NAME") = wed("WE_Beschrijving_Extra")
  
  maxUsedPoolID = maxUsedPoolID + 1
  nBanen = Nz(wed("WE_AantalBanen"))
  iFirstBaan = Nz(wed("WE_EersteBaan"), 1)
  zwbadNaam = Nz(wed("WE_Zwembad"))
  If Not lenAppendLXPool(pools, maxUsedPoolID, nBanen, iFirstBaan, zwbadNaam) Then Exit Function
  ssOutp("SYS_REF_POOL") = maxUsedPoolID
  
  ssOutp.Update
    
  
  

    

  wed.MoveNext
Loop




appCleanRS ssOutp
appCleanRS ssCollOutp
appCleanRS mtSessions
appCleanRS mtOutp
appCleanRS mtMeetColl
appCleanRS pools
appCleanRS ageDate
appCleanRS qualify
appCleanRS evs
appCleanRS Kosten
appCleanRS kostenColl
appCleanRS rsFees
appCleanRS wed



lenWriteSessionsToXMLTables = True
Exit Function
fout:
If (Err = 3021) Then Resume Next
MsgBox Err & " " & Error$, 16

Exit Function

'debug
On Error GoTo 0
Resume

Exit Function
End Function




Private Function lenReadSessionsFromXMLTables(ByVal lxVersion As Long, ByRef glbWedDate As Date, ByRef glbAgeDate As Date, ByRef lftBep As String, ByRef glbBaanLengte As Integer, ByRef maxUsedWedID As Long, ByRef maxUsedContID As Long) As Boolean
On Error GoTo fout
lenReadSessionsFromXMLTables = False





Dim ss As Recordset
Dim ssSQL As String
ssSQL = "SELECT LEN_SESSION.*, LEN_MEET.* " & _
    "FROM ((LEN_MEET INNER JOIN LEN_SESSIONS ON LEN_MEET.SYS_REF_SESSIONS = LEN_SESSIONS.ID_SESSIONS) INNER JOIN " & _
    "LEN_SESSION_COLL ON LEN_SESSIONS.SYS_REF_SESSION_COLL = LEN_SESSION_COLL.ID_SESSION_COLL) INNER JOIN " & _
    "LEN_SESSION ON LEN_SESSION_COLL.SYS_REF_CH_SESSION = LEN_SESSION.ID_SESSION order by LEN_SESSION.ID_SESSION; "

Set ss = CurrentDb().OpenRecordset(ssSQL)
ss.MoveFirst

Dim pools As Recordset
Set pools = CurrentDb().OpenRecordset("LEN_POOL")
pools.Index = "P"

Dim ageDate As Recordset
Set ageDate = CurrentDb().OpenRecordset("LEN_AGEDATE")
ageDate.Index = "P"

Dim qualify As Recordset
Set qualify = CurrentDb().OpenRecordset("LEN_Qualify")
qualify.Index = "P"


Dim wedOutp As Recordset
Set wedOutp = CurrentDb().OpenRecordset("gIMP_LEN_Wedstrijden")

Dim Kosten As Recordset
Set Kosten = CurrentDb().OpenRecordset("LEN_FEE")
Kosten.Index = "P"
Dim kostenColl As Recordset
Set kostenColl = CurrentDb().OpenRecordset("select * from LEN_FEE_COLL order by [ID_FEE_COLL]", dbOpenDynaset)

Dim rsFees As Recordset
Set rsFees = CurrentDb().OpenRecordset("LEN_FEES")
rsFees.Index = "P"


Dim ssCont As Recordset
Set ssCont = CurrentDb().OpenRecordset("LEN_CONTACT")
ssCont.Index = "P"

Dim cntOutp As Recordset
Set cntOutp = CurrentDb().OpenRecordset("gIMP_LEN_CONTACT")

Dim isFirst As Boolean
isFirst = True
Dim wedContactID As Long

wedContactID = -1





Do Until ss.EOF
  wedOutp.AddNew
  
  If (isFirst) Then
    Dim tpContID As Long
    tpContID = Nz(ss("SYS_REF_CONTACT"), -1)
     Dim contInf As CONTACT_INFO
     If Not lenLoadLXContact(ssCont, tpContID, contInf) Then
       Exit Function
     End If
     If (contInf.naam <> "") Then
       maxUsedContID = maxUsedContID + 1
       If Not lenAppendContact(cntOutp, maxUsedContID, contInf) Then
         Exit Function
       End If
       wedContactID = maxUsedContID
     End If
     
     
     Dim glbDateStr As String
     glbWedDate = #1/1/1900#
     glbDateStr = Nz(ss("LEN_DATE"))
     If (glbDateStr <> "") Then
       glbWedDate = lenParseDate(glbDateStr)
     End If
     
     
     lftBep = ""
     Dim ssAgeDateID As Long
     ssAgeDateID = Nz(ss("SYS_REF_AGEDATE"), -1)
    
     Dim dtAgeValid As Boolean
     Dim dtAge As Date
    
     If (Not lenLoadLXAgeDate(ageDate, ssAgeDateID, glbWedDate, lftBep, dtAgeValid, dtAge)) Then
       Exit Function
     End If
      
     
     If (dtAgeValid) Then
       glbAgeDate = dtAge
     Else
       glbAgeDate = glbWedDate
     End If
     
     
     isFirst = False
  End If
  
  If (wedContactID <> -1) Then
    wedOutp("WE_Contact_ID") = wedContactID
  Else
    wedOutp("WE_Contact_ID") = Null
  End If
  
  Dim tpWedID As Long
  tpWedID = Nz(ss("ID_Session"), -1)
  
  wedOutp("WE_ID") = tpWedID
  
  If (tpWedID > maxUsedWedID) Then
    maxUsedWedID = tpWedID
  End If
  
  If (Nz(ss("LEN_SESSION.LEN_Number") > 0)) Then
    wedOutp("WE_LEN_SessionNr") = Nz(ss("LEN_SESSION.LEN_Number"))
  End If
  
  
  
  
  Dim datStr As String
  Dim wedDat As Date
  wedDat = #1/1/1900#
  datStr = Nz(ss("LEN_DATE"))
  If (datStr <> "") Then
     wedDat = lenParseDate(datStr)
     wedOutp("WE_Datum") = wedDat
  End If
  
  wedOutp("WE_Leeftijdsdatum") = glbAgeDate
  wedOutp("WE_Leeftijdsbepaling") = hzn(lftBep)
         

  
  Dim ssPoolID As Long
  ssPoolID = Nz(ss("LEN_SESSION.SYS_REF_POOL"), -1)
  If (ssPoolID < 0) Then
    ssPoolID = Nz(ss("LEN_MEET.SYS_REF_POOL"), -1)
  End If
  
  Dim poolName As String, poolNBanen As Integer, poolFirstBaan As Integer
  If (Not lenLoadLXPool(pools, ssPoolID, poolNBanen, poolFirstBaan, poolName)) Then
    Exit Function
  End If
  
  wedOutp("WE_AantalBanen") = poolNBanen
  If (poolFirstBaan > 1) Then
    wedOutp("WE_EersteBaan") = poolFirstBaan
  Else
    wedOutp("WE_EersteBaan") = Null
  End If
  wedOutp("WE_Zwembad") = hzn(poolName)
    
  wedOutp("WE_Plaats") = ss("LEN_CITY")
  wedOutp("WE_Beschrijving") = ss("LEN_Meet.LEN_NAME")
  wedOutp("WE_Beschrijving_extra") = ss("LEN_Session.LEN_NAME")
  
  glbBaanLengte = lenParseCourse(Nz(ss("LEN_MEET.LEN_COURSE")))
  
  
  Dim locBaanLengteS As String
  locBaanLengteS = Nz(ss("LEN_SESSION.LEN_COURSE"))
  Dim locBaan As Integer
  locBaan = glbBaanLengte
  If (locBaanLengteS <> "") Then
    locBaan = lenParseCourse(locBaanLengteS)
  End If
    
  
  wedOutp("WE_Baanlengte") = lenParseCourse(Nz(ss("LEN_MEET.LEN_COURSE")))
  
  Dim timeStr As String
  timeStr = Nz(ss("LEN_DAYTIME"))
  If (timeStr <> "") Then
    wedOutp("WE_Aanvang") = lenParseDaytime(timeStr)
  End If
  
  timeStr = Nz(ss("LEN_warmupfrom"))
  If (timeStr <> "") Then
    wedOutp("WE_Inzwemmen") = lenParseDaytime(timeStr)
  End If
  
  timeStr = Nz(ss("LEN_officialmeeting"))
  If (timeStr <> "") Then
    wedOutp("WE_AanvangJuryVergadering") = lenParseDaytime(timeStr)
  End If
  
  
  
  wedOutp("WE_Organiserende_Vereniging") = ss("LEN_ORGANIZER")
  

  wedOutp("WE_ElektronischeTijd") = lenIsAutoTiming(Nz(ss("LEN_TIMING")))
  
  
  Dim ssQualifyID As Long
  ssQualifyID = Nz(ss("SYS_REF_QUALIFY"), -1)
  
  Dim qlfRelayMode As String, qlfConv As String, qlfFromValid As Boolean, qlfUntilValid As Boolean
  Dim qlfFromDate As Date, qlfUntilDate As Date
  If (Not lenLoadLXQualify(qualify, ssQualifyID, qlfConv, qlfRelayMode, qlfFromValid, qlfFromDate, qlfUntilValid, qlfUntilDate)) Then
    Exit Function
  End If
 
  
  wedOutp("WE_QLF_CONVERSION") = hzn(qlfConv)
  wedOutp("WE_QLF_RelayMode") = hzn(qlfRelayMode)
  If (qlfFromValid) Then
    wedOutp("WE_QLF_From") = qlfFromDate
  End If
  If (qlfUntilValid) Then
    wedOutp("WE_QLF_Until") = qlfUntilDate
  End If
  
  
  Dim tpInsDeadlineDate As Date
  tpInsDeadlineDate = lenParseDate(Nz(ss("LEN_Deadline")))
  
  
  wedOutp("WE_InsDeadlineDate") = Null
  wedOutp("WE_InsDeadlineTime") = Null
  
  If lenDateIsValid(tpInsDeadlineDate) Then
    wedOutp("WE_InsDeadlineDate") = tpInsDeadlineDate
    If Not IsNull(ss("LEN_Deadlinetime")) Then
      wedOutp("WE_InsDeadlineTime") = lenParseDaytime(Nz(ss("LEN_Deadlinetime")))
    End If
  End If
  
  
  
  Dim ssFeeCollID As Long
  
  If (lxVersion < LX_VERSION_3) Then
    ssFeeCollID = Nz(ss("SYS_REF_FEE_COLL"), -1)
  Else
    ssFeeCollID = -1
    Dim tpFeesXID As Long
    tpFeesXID = Nz(ss("SYS_REF_FEES"), -1)
    rsFees.Seek "=", tpFeesXID
    If Not rsFees.NoMatch Then
      ssFeeCollID = Nz(rsFees("SYS_REF_FEE_COLL"), -1)
    End If
  End If
  
  
  Dim ssFeeID As Long, done As Boolean
  If (Not lenCollPrepareIt(kostenColl, ssFeeCollID, "FEE", done)) Then
    Exit Function
  End If
  Do Until done
    If (Not lenCollGetNextID(kostenColl, ssFeeCollID, "FEE", ssFeeID, done)) Then
      Exit Function
    End If
    
    Dim kostenVal As Double
    Dim kostenCurrS As String
    Dim kostenPerClub As Boolean
    Dim kostenPerZw As Boolean
    Dim kostenPerPloeg As Boolean
    
    If Not (lenLoadLXFee(Kosten, ssFeeID, kostenCurrS, kostenVal, kostenPerClub, kostenPerZw, kostenPerPloeg)) Then
      Exit Function
    End If
        
    wedOutp("WE_Kosten_Currency") = hzn(kostenCurrS)
        
        
    If (kostenPerClub) Then
      wedOutp("WE_BulkKostenVer") = kostenVal
    ElseIf (kostenPerZw) Then
      wedOutp("WE_BulkKostenZwemmer") = kostenVal
    ElseIf (kostenPerPloeg) Then
      wedOutp("WE_KostenRelay") = kostenVal
    End If
    
  Loop
  
  
   
   wedOutp("WE_NATION") = ss("LEN_NATION")
   
   wedOutp("WE_PartOfTimeArchive") = False
  
  
  
  wedOutp.Update
  

  ss.MoveNext
Loop






appCleanRS ss
appCleanRS pools
appCleanRS ageDate
appCleanRS qualify
appCleanRS wedOutp
appCleanRS Kosten
appCleanRS kostenColl
appCleanRS rsFees
appCleanRS ssCont
appCleanRS cntOutp


lenReadSessionsFromXMLTables = True
Exit Function
fout:
If (Err = 3021) Then Resume Next
MsgBox Err & " " & Error$, 16
Exit Function

'debug
On Error GoTo 0
Resume

Exit Function
End Function







Private Function lenAppendAgeGroup(ByRef outpAG As Recordset, ByVal lenID As Long, ByVal agID As Long, ByVal progID As Long, ByRef catInfo As CAT_INFO) As Boolean
On Error GoTo fout
lenAppendAgeGroup = True

outpAG.AddNew
  outpAG("LF_PR_ID") = progID
  outpAG("LF_ID") = agID
  outpAG("INT_LEN_ID") = lenID
  
  If (Not lenWriteCatInfo(outpAG, "LF_", True, catInfo)) Then
    lenAppendAgeGroup = False
  End If
  
  
outpAG.Update
  


lenAppendAgeGroup = True
Exit Function
fout:
MsgBox Err & " " & Error$, 16

Exit Function

'debug
On Error GoTo 0
Resume


Exit Function

End Function

Private Function lenAppendContact(ByRef outpCont As Recordset, ByVal contID As Long, ByRef cntInf As CONTACT_INFO) As Boolean
On Error GoTo fout
lenAppendContact = False


outpCont.AddNew
  outpCont("CT_ID") = contID
  If Not lenWriteContactInfo(outpCont, "CT_", cntInf) Then
    Exit Function
  End If
outpCont.Update

lenAppendContact = True
Exit Function
fout:
MsgBox Err & " " & Error$, 16
Exit Function
End Function

Private Function lenIsValidCatDescription(descr As String) As Boolean
On Error GoTo fout
lenIsValidCatDescription = False


Dim ok As Boolean
ok = False
If descr Like "jon*" Or descr Like "j. *" Then
  ok = True
ElseIf descr Like "heren*" Then
  ok = True
ElseIf descr Like "mei*" Or descr Like "m. *" Then
  ok = True
ElseIf descr Like "dames*" Then
  ok = True
ElseIf descr Like "m./j.*" Then
  ok = True
ElseIf descr Like "mix*" Then
  ok = True
End If

If (ok) Then
  lenIsValidCatDescription = True
End If


Exit Function
fout:
MsgBox Err & " " & Error$, 16
End Function


Public Function lenDetermineRecords(ByRef recs As Recordset, ByVal Afstand As String, ByVal slag As String, ByVal baan As Integer, ByVal recAgeMode As String, ByVal wedAgeDate As Date, ByVal lftBep As String, ByRef catInf As CAT_INFO) As Boolean
On Error GoTo fout
lenDetermineRecords = False

Dim cat As String
cat = Trim(catInf.cat)

Dim ges As String
Dim maxRecAge As Integer


'need to determine record.
  maxRecAge = catGetMaxAllowedAgeTranslated(cat, wedAgeDate, lftBep, recAgeMode)
  
  ges = m_of_v(cat)
  
  
  Dim findStr As String
  findStr = "INT_MaxAge >= " & maxRecAge & "REC_Afstand=""" & Afstand & """ and REC_SLAG=""" & slag & """ and REC_baan = " & baan & " And INT_geslacht = """ & ges & """"
  
  Dim tpMaxAge As Integer
  
  Dim maxRecMaxAge As Integer
  maxRecMaxAge = CAT_MAX_AGE
  
  
  recs.FindFirst findStr
  If (Not recs.NoMatch) Then
    tpMaxAge = Nz(recs("INT_MAX_AGE"))
    If (Nz(recs("REC_Tijd")) > 0.01) Then
    
      If (tpMaxAge <= maxRecMaxAge) Then
        maxRecMaxAge = tpMaxAge
    
        catInf.rec.datum = Nz(recs("REC_Datum"), #1/10/1900#)
        If Not (Nz(recs("REC_IsEstaf"))) Then
          catInf.rec.naam = Nz(recs("ZWNAAM"))
        End If
        catInf.rec.Plaats = Nz(recs("REC_PLaats"))
        catInf.rec.recType = Nz(recs("REC_TYPE"))
        catInf.rec.tijd = Nz(recs("REC_TIJD"))
        catInf.rec.tussentijden = Nz(recs("REC_TUSSENTIJDEN"))
      End If
      
    End If
  End If
  


lenDetermineRecords = True
Exit Function
fout:
MsgBox Err & " " & Error$, 16
Exit Function
End Function



Public Function lenDetermineLimits(ByRef limS As Recordset, ByVal Afstand As String, ByVal slag As String, ByVal baan As Integer, ByVal wedDate As Date, ByVal lftBep As String, ByVal overwriteLim As Boolean, ByVal overwriteVVT As Boolean, ByRef catInf As CAT_INFO, _
  ByVal blRestrictTimeStdListIDs As Integer, ByVal nTimeStdListIDs As Integer, ByRef lTimeStdListIDs() As Long) As Boolean
On Error GoTo fout
lenDetermineLimits = False



Dim cat As String
  cat = Trim(catInf.cat)
  
  Dim maxRecAge As Integer
  maxRecAge = catGetMaxAllowedAge_bare(cat, wedDate, lftBep)
  
  Dim ges As String
  ges = m_of_v(cat)
  
  
  Dim findStr As String
  'We have thrown away BAAN string.
  findStr = "INT_Max_Age >= " & maxRecAge & " and LIM_Afstand=""" & Afstand & """ and LIM_SLAG=""" & slag & """  And int_geslacht = """ & ges & """"
  
  limS.FindFirst findStr
  If (Not limS.NoMatch) Then
    'process all valid limits.
    Dim done As Boolean
    done = limS.EOF
    
    Dim vvtDet As Boolean, minLim25Det As Boolean, minLim50Det, maxLim25Det As Boolean, maxLim50Det As Boolean
    Dim vvt As Double, minLim25 As Double, minLim50 As Double, maxLim25 As Double, maxLim50 As Double
    Dim vvtMaxAge As Integer, minLim25MaxAge As Integer, minLim50MaxAge As Integer, maxLim25MaxAge As Integer, maxLim50MaxAge As Integer
    
    vvtMaxAge = CAT_MAX_AGE
    minLim25MaxAge = CAT_MAX_AGE
    minLim50MaxAge = CAT_MAX_AGE
    maxLim25MaxAge = CAT_MAX_AGE
    maxLim50MaxAge = CAT_MAX_AGE
    
    While Not done
    
     Dim tpMaxAge As Integer
     tpMaxAge = Nz(limS("INT_MAX_AGE"))
    
      Dim tpTijd As Double
      tpTijd = Nz(limS("LIM_TIJD"))
      
      Dim tpBaan As Long
      tpBaan = Nz(limS("LIM_BAAN"))
      
      Dim tpListID As Long
      tpListID = Nz(limS("LIM_LEN_LIST_ID"))
      
      Dim blAllow As Boolean
      
      blAllow = True
      
      If (blRestrictTimeStdListIDs) Then
        If (bSearchLong(tpListID, nTimeStdListIDs, lTimeStdListIDs) < 0) Then
          blAllow = False
        End If
      End If
      
      If (tpTijd < 0.01) Then
        blAllow = False
      End If
      
      If (blAllow) Then
        If Nz(limS("LIM_ISVVT")) Then
          vvtDet = True
          If (tpMaxAge <= vvtMaxAge) Then
            vvt = tpTijd
            vvtMaxAge = tpMaxAge
          End If
        ElseIf Nz(limS("LIM_ISMINLIM")) Then
          If (tpBaan = 50) Then
             minLim50Det = True
             If (tpMaxAge <= minLim50MaxAge) Then
               minLim50 = tpTijd
               minLim50MaxAge = tpMaxAge
             End If
          Else
            minLim25Det = True
             If (tpMaxAge <= minLim25MaxAge) Then
               minLim25 = tpTijd
               minLim25MaxAge = tpMaxAge
             End If
          End If
        ElseIf Nz(limS("LIM_IsMaxLim")) Then
          If (tpBaan = 50) Then
            maxLim50Det = True
            If (tpMaxAge <= maxLim50MaxAge) Then
              maxLim50 = tpTijd
              maxLim50MaxAge = tpMaxAge
            End If
          Else
            maxLim25Det = True
            If (tpMaxAge <= maxLim25MaxAge) Then
              maxLim25 = tpTijd
              maxLim25MaxAge = tpMaxAge
            End If
          End If
        End If
      End If 'if blAllow
          
          
      limS.MoveNext
      If (limS.EOF) Then
        done = True
      Else
        'Removed "baan" comparison.
        If Nz(limS("LIM_Afstand")) <> Afstand Or Nz(limS("LIM_Slag")) <> slag Or Nz(limS("INT_Geslacht")) <> ges Then
          done = True
        End If
      End If
    Wend
    
    Dim blLimsDiffer As Boolean
    blLimsDiffer = False
    If (minLim25Det Or maxLim25Det) And ((minLim25Det = minLim50Det) And (maxLim25Det = maxLim50Det)) Then
      If (minLim25Det) Then
        If (Abs(minLim25 - minLim50) > 0.001) Then
          blLimsDiffer = True
        End If
      End If
      If (maxLim25Det) Then
        If (Abs(maxLim25 - maxLim50) > 0.001) Then
          blLimsDiffer = True
        End If
      End If
    Else
      blLimsDiffer = True
    End If
    
    If Not blLimsDiffer Then
      'discard 50m limits
      minLim50Det = False
      maxLim50Det = False
    End If
    
    
    If (overwriteLim Or (Trim(catInf.lim) = "")) Then
            
      Dim bl25Det As Boolean
      Dim bl50Det As Boolean
      
      bl25Det = minLim25Det Or maxLim25Det
      bl50Det = minLim50Det Or maxLim50Det
      
      Dim tpLim25 As String
      Dim tpLim50 As String
      tpLim25 = ""
      tpLim50 = ""
      
      Dim resLim25 As Double
      Dim resLim50 As Double
      
      resLim25 = 0
      resLim50 = 0
      
      If (bl25Det) Then
      
        'First check for reserve limits.
        If (minLim25Det And maxLim25Det) Then
          If maxLim25 < minLim25 Then
            resLim25 = minLim25 - maxLim25
            minLim25 = 0
            minLim25Det = False
          End If
        End If
      
      
        If (minLim25Det And maxLim25Det) Then
          tpLim25 = Trim(fmtSwimTime(minLim25)) & "-" & Trim(fmtSwimTime(maxLim25))
        ElseIf (minLim25Det) Then
          tpLim25 = Trim(fmtSwimTime(minLim25)) & "+"
        ElseIf (maxLim25Det) Then
          tpLim25 = Trim(fmtSwimTime(maxLim25))
        End If
      End If
      
      If (bl50Det) Then
        'First check for reserve limits.
        If (minLim50Det And maxLim50Det) Then
          If maxLim50 < minLim50 Then
            resLim50 = minLim50 - maxLim50
            minLim50 = 0
            minLim50Det = False
          End If
        End If

      
      
        If (minLim50Det And maxLim50Det) Then
          tpLim50 = Trim(fmtSwimTime(minLim50)) & "-" & Trim(fmtSwimTime(maxLim50))
        ElseIf (minLim50Det) Then
          tpLim50 = Trim(fmtSwimTime(minLim50)) & "+"
        ElseIf (maxLim50Det) Then
          tpLim50 = Trim(fmtSwimTime(maxLim50))
        End If
      End If
      
      Dim tpLim As String
      tpLim = ""
      
      If (bl25Det) And (bl50Det) Then
        tpLim = tpLim25 & " / " & tpLim50
      ElseIf (bl25Det) Then
        tpLim = tpLim25
      ElseIf (bl50Det) Then
        tpLim = tpLim50
      End If
      
      
      Dim tpResLim As String
      tpResLim = ""
      If (resLim25 > 0.1 And resLim50 > 0.1) Then
        tpResLim = lenFormatResLim(resLim25) & " / " & lenFormatResLim(resLim50)
      ElseIf (resLim25 > 0.1) Then
        If (bl50Det) Then
          tpResLim = lenFormatResLim(resLim25) & " / " & lenFormatResLim(0)
        Else
          tpResLim = lenFormatResLim(resLim25)
        End If
      ElseIf (resLim50 > 0.1) Then
        If (bl25Det) Then
          tpResLim = lenFormatResLim(0) & " / " & lenFormatResLim(resLim50)
        Else
          tpResLim = lenFormatResLim(resLim50)
        End If
                 
      End If
      
      If (tpLim <> "") Then
        catInf.lim = tpLim
        If (tpResLim <> "") Then
          catInf.resLim = tpResLim
        Else
          catInf.resLim = lenFormatResLim(0)
        End If
      End If
      
      
    End If
    
    If (overwriteVVT Or (catInf.vvt < 0.01)) And vvtDet Then
      catInf.vvt = vvt
    End If
    
  End If


lenDetermineLimits = True
Exit Function
fout:
MsgBox Err & " " & Error$, 16
Exit Function
End Function



Private Function lenDetermineEventDetails(ByRef eventDetails As Recordset, ByRef shRecords As Recordset, ByVal detLims As Boolean, ByRef limS As Recordset, _
  ByVal detRecs As Boolean, ByRef recs As Recordset, ByVal Afstand As String, ByVal slag As String, ByVal baan As Integer, _
  ByVal recAgeMode As String, ByVal eventDetailsID As Long, ByVal wedAgeDate As Date, ByVal lftBep As String, _
  ByVal gender As String, ByVal minAge As Integer, ByVal maxAge As Integer, ByVal isTotAge As Boolean, _
  ByVal name As String, ByVal auxCat As String, ByVal auxCatBes As String, ByRef catInf As CAT_INFO, _
  ByVal blRestrictTimeStdListIDs As Integer, ByVal nTimeStdListIDs As Integer, ByRef lTimeStdListIDs() As Long) As Boolean
On Error GoTo fout
lenDetermineEventDetails = False


If Not lenLoadLXEventDetails(eventDetails, shRecords, eventDetailsID, catInf) Then
  Exit Function
End If

If (Trim(catInf.cat) = "") Then
  'need to use ageMin / ageMax to determine category.
  If (auxCat <> "") Then
    catInf.cat = auxCat
  Else
    catInf.cat = lenParseAgeGroup(lftBep, wedAgeDate, gender, minAge, maxAge, isTotAge)
  End If
  If (auxCatBes <> "") Then
    catInf.bescat = auxCatBes
  ElseIf (name <> "") Then
    If (lenIsValidCatDescription(name)) Then
      catInf.bescat = name
    Else
      catInf.bescat = catBeschrijving(Trim(catInf.cat))
    End If
  Else
    catInf.bescat = catBeschrijving(Trim(catInf.cat))
  End If
End If




If ((Not catInf.blDetFromEvDetails) And detLims And (Trim(catInf.lim) = "" Or catInf.vvt < 0.01)) Then
  'try and determine limit...
  
  If Not lenDetermineLimits(limS, Afstand, slag, baan, wedAgeDate, lftBep, False, False, catInf, _
    blRestrictTimeStdListIDs, nTimeStdListIDs, lTimeStdListIDs) Then
    Exit Function
  End If
  
End If

If ((Not catInf.blDetFromEvDetails) And detRecs And catInf.rec.tijd < 0.01) Then
  
  If Not lenDetermineRecords(recs, Afstand, slag, baan, recAgeMode, wedAgeDate, lftBep, catInf) Then
    Exit Function
  End If
  
End If


lenDetermineEventDetails = True
Exit Function
fout:
MsgBox Err & " " & Error$, 16

Exit Function

'debug
On Error GoTo 0
Resume

Exit Function

End Function


Private Function lenLoadLXEventDetails(ByRef eventDetails As Recordset, ByRef shRecords As Recordset, ByVal eventDetailsID As Long, ByRef cat As CAT_INFO) As Boolean
On Error GoTo fout
lenLoadLXEventDetails = False


lenInitCat cat





If (eventDetailsID >= 0) Then
  eventDetails.Seek "=", eventDetailsID
  If (Not eventDetails.NoMatch) Then
  
    cat.cat = Nz(eventDetails("LEN_CATEGORY"))
    cat.bescat = Nz(eventDetails("LEN_CATEGORYDESCRIPTION"))
    cat.lim = Nz(eventDetails("LEN_LIMIT"))
    cat.resLim = Nz(eventDetails("LEN_RESMARGIN"))
    cat.vvt = lenParseSwimtime(Nz(eventDetails("LEN_REPLACETIME")))
    
    cat.Code = Nz(eventDetails("LEN_CATCODE"))
    
    cat.blDetFromEvDetails = True
  
    Dim shRecID As Long
    shRecID = Nz(eventDetails("SYS_REF_SHORTRECORD"), -1)

    If (shRecID >= 0) Then
      shRecords.Seek "=", shRecID
      If (Not shRecords.NoMatch) Then
        Dim datS As String
        datS = Nz(shRecords("LEN_DATE"))
        If datS <> "" Then
          cat.rec.datum = lenParseDate(datS)
        End If
        cat.rec.tijd = lenParseSwimtime(Nz(shRecords("LEN_TIME")))
        cat.rec.naam = Nz(shRecords("LEN_NAME"))
        cat.rec.Plaats = Nz(shRecords("LEN_CITY"))
        cat.rec.recType = Nz(shRecords("LEN_TYPE"))
        cat.rec.tussentijden = Nz(shRecords("LEN_SPLITS"))
      End If
    End If
  End If
End If






lenLoadLXEventDetails = True
Exit Function
fout:
MsgBox Err & " " & Error$, 16
Exit Function
End Function

Private Function lenAppendLXEventDetails(ByRef eventDetails As Recordset, ByRef shRec As Recordset, ByVal eventDetailsID As Long, ByRef maxUsedShRecID, ByRef cat As CAT_INFO) As Boolean
On Error GoTo fout
lenAppendLXEventDetails = False

eventDetails.AddNew
  
  eventDetails("ID_EVENTDETAILS") = eventDetailsID
  eventDetails("LEN_CATEGORY") = hzn(Trim(cat.cat))
  eventDetails("LEN_CATEGORYDESCRIPTION") = hzn(Trim(cat.bescat))
  eventDetails("LEN_LIMIT") = hzn(Trim(cat.lim))
  eventDetails("LEN_RESMARGIN") = hzn(Trim(cat.resLim))
  
  eventDetails("LEN_CATCODE") = hzn(Trim(cat.Code))
  
  If (cat.vvt > 1) Then
    eventDetails("LEN_REPLACETIME") = hzn(lenFormatSwimTime(cat.vvt))
  End If
  
  If (cat.rec.tijd > 1) Then
    shRec.AddNew
      shRec("ID_SHORTRECORD") = maxUsedShRecID + 1
      maxUsedShRecID = maxUsedShRecID + 1
      
     shRec("LEN_CITY") = hzn(Trim(cat.rec.Plaats))
     Dim dIsValid As Boolean
     dIsValid = lenDateIsValid(cat.rec.datum)
     If (dIsValid) Then
       shRec("LEN_DATE") = hzn(lenFormatDate(cat.rec.datum))
     End If
     shRec("LEN_NAME") = hzn(Trim(cat.rec.naam))
     shRec("LEN_SPLITS") = hzn(Trim(cat.rec.tussentijden))
     shRec("LEN_TIME") = hzn(lenFormatSwimTime(cat.rec.tijd))
     shRec("LEN_TYPE") = hzn(Trim(cat.rec.recType))

   shRec.Update
 End If
 
eventDetails.Update


lenAppendLXEventDetails = True
Exit Function
fout:
MsgBox Err & " " & Error$, 16
Exit Function
End Function


Private Function lenAppendLXAgeGroupBare(ByVal lxVersion As Long, ByRef ageGroup As Recordset, ByVal ageGroupID As Long, ByVal lenAgeGroupID, ByVal gender As String, ByVal ageMin As Integer, ByVal ageMax As Integer, ByVal isTotAge As Boolean, ByVal name As String, Optional ByVal evDetID As Long = -1, Optional skipGender As Boolean = False) As Boolean
On Error GoTo fout
lenAppendLXAgeGroupBare = False


ageGroup.AddNew
ageGroup("ID_AGEGROUP") = ageGroupID
If (lenAgeGroupID <> -1) Then
  ageGroup("LEN_AGEGROUPID") = lenAgeGroupID
Else
  ageGroup("LEN_AGEGROUPID") = Null
End If



If (lxVersion < LX_VERSION_3) Then
  If (isTotAge) Then
    ageGroup("LEN_TYPE") = "TOTAL"
  End If
Else
  If (isTotAge) Then
    ageGroup("LEN_CALCULATE") = "TOTAL"
  End If
End If
  
ageGroup("LEN_AGEMIN") = ageMin
ageGroup("LEN_AGEMAX") = ageMax
  
If (skipGender) Then
  ageGroup("LEN_GENDER") = Null
Else
  ageGroup("LEN_GENDER") = hzn(gender)
End If
ageGroup("LEN_NAME") = hzn(name)



If (evDetID <> -1) Then
  ageGroup("SYS_REF_EVENTDETAILS") = evDetID
End If

ageGroup.Update

lenAppendLXAgeGroupBare = True
Exit Function
fout:
MsgBox Err & " " & Error$, 16
Exit Function
End Function

Private Function lenAppendLXAgeGroup(ByVal lxVersion As Long, ByRef ageGroup As Recordset, ByRef eventDetails As Recordset, ByRef shRecs As Recordset, ByVal ageGroupID As Long, ByVal lenAgeGroupID As Long, ByRef maxUsedEventDetailsID As Long, ByRef maxUsedShRecID As Long, ByVal wedDate As Date, ByVal lftBep As String, ByRef catInf As CAT_INFO, ByVal blUseXForMixed As Boolean) As Boolean
On Error GoTo fout
lenAppendLXAgeGroup = False


Dim gender As String, ageMin As Integer, ageMax As Integer, isTotAge As Boolean, isMCat As Boolean

If Not lenFormatCategorie(Trim(catInf.cat), wedDate, lftBep, gender, ageMin, ageMax, isTotAge, isMCat, blUseXForMixed) Then
  Err.Raise 1, , "Ongeldige categorie: " + Trim(catInf.cat)
  Exit Function
End If


Dim eventDetailsID As Long
eventDetailsID = maxUsedEventDetailsID + 1
maxUsedEventDetailsID = maxUsedEventDetailsID + 1


If Not lenAppendLXAgeGroupBare(lxVersion, ageGroup, ageGroupID, lenAgeGroupID, gender, ageMin, ageMax, isTotAge, Trim(catInf.bescat), eventDetailsID) Then Exit Function

If Not (lenAppendLXEventDetails(eventDetails, shRecs, eventDetailsID, maxUsedShRecID, catInf)) Then
  Exit Function
End If


lenAppendLXAgeGroup = True
Exit Function
fout:
MsgBox Err & " " & Error$, 16

Exit Function

'debug
On Error GoTo 0
Resume

Exit Function
End Function


Private Sub lenInitCat(ByRef catInf As CAT_INFO)
On Error Resume Next
catInf.cat = ""
catInf.bescat = ""
catInf.lim = ""
catInf.resLim = ""
catInf.vvt = 0
catInf.Code = ""
catInf.rec.datum = #1/1/1900#
catInf.rec.tijd = 0
catInf.rec.naam = ""
catInf.rec.Plaats = ""
catInf.rec.recType = ""
catInf.rec.tussentijden = ""
catInf.blDetFromEvDetails = False
End Sub


Private Function lenLoadLXAgeGroup(ByVal lxVersion As Long, ByRef ageGroup As Recordset, ByRef eventDetails As Recordset, ByRef shRecs As Recordset, ByVal detLim As Boolean, ByRef limS As Recordset, ByVal detRec As Boolean, ByRef recs As Recordset, ByVal Afstand As String, ByVal slag As String, ByVal Baanlengte As Integer, ByVal recAgeMode As String, ByVal ageGroupID As Long, ByRef lenAgeGroupID As Long, ByVal wedAgeDate As Date, ByVal lftBep As String, ByVal progGender As String, ByRef catInf As CAT_INFO, _
  ByVal blRestrictTimeStdLists As Boolean, ByVal nTimeStdLists As Integer, lTimeStdListIDs() As Long) As Boolean
On Error GoTo fout
lenLoadLXAgeGroup = False

'First clear cat.
lenInitCat catInf

If (ageGroupID >= 0) Then
  ageGroup.Seek "=", ageGroupID
  If Not ageGroup.NoMatch Then
    Dim minAge As Integer, maxAge As Integer, gender As String, name As String, blIsTotalAge As Boolean
    
    
    minAge = Nz(ageGroup("LEN_AGEMIN"), -1)
    maxAge = Nz(ageGroup("LEN_AGEMAX"), -1)
    gender = Nz(ageGroup("LEN_GENDER"))
    
    If (lxVersion < LX_VERSION_3) Then
      blIsTotalAge = (Nz(ageGroup("LEN_TYPE")) = "TOTAL")
    Else
      blIsTotalAge = (Nz(ageGroup("LEN_CALCULATE")) = "TOTAL")
    End If
    
    
    If (gender = "") Then
      gender = progGender
    End If
    name = Nz(ageGroup("LEN_Name"))
    lenAgeGroupID = Nz(ageGroup("LEN_AGEGROUPID"))
    
    Dim eventDetailsID As Long
    eventDetailsID = Nz(ageGroup("SYS_REF_EVENTDETAILS"), -1)
    
    
    
    
    If Not lenDetermineEventDetails(eventDetails, shRecs, detLim, limS, detRec, recs, Afstand, slag, Baanlengte, recAgeMode, eventDetailsID, wedAgeDate, lftBep, gender, minAge, maxAge, blIsTotalAge, name, "", "", catInf, _
      blRestrictTimeStdLists, nTimeStdLists, lTimeStdListIDs) Then
      Exit Function
    End If
    
    

  End If
End If


lenLoadLXAgeGroup = True
Exit Function
fout:
MsgBox Err & " " & Error$, 16
Exit Function
End Function

Private Function lenAppendLXSwimStyle(ByRef sw As Recordset, ByVal swstID As Long, ByVal Afstand As String, ByVal slag As String, ByVal besAfw As String) As Boolean
On Error GoTo fout
lenAppendLXSwimStyle = False

sw.AddNew
  sw("ID_SWIMSTYLE") = swstID
  Dim dist As String, relCnt As Integer
  If (Afstand Like "*x*") Then
    dist = lenIndAfstand(Afstand)
    relCnt = lenAfNZwemmers(Afstand)
  Else
    relCnt = 1
    dist = Afstand
  End If
  sw("LEN_RELAYCOUNT") = relCnt
  sw("LEN_DISTANCE") = hzn(dist)
  sw("LEN_NAME") = hzn(besAfw)
  
  sw("LEN_STROKE") = hzn(lenFormatStroke(slag))

sw.Update

lenAppendLXSwimStyle = True
Exit Function
fout:
MsgBox Err & " " & Error$, 16
Exit Function
End Function

Private Function lenLoadLXSwimStyle(ByRef sw As Recordset, ByVal swstID As Long, ByRef Afstand As String, ByRef slag As String, ByRef besAfw As String) As Boolean
On Error GoTo fout
lenLoadLXSwimStyle = True

Afstand = ""
slag = ""
besAfw = ""

If (swstID >= 0) Then
  sw.Seek "=", swstID
  If (Not sw.NoMatch) Then
    Dim dist As String, relCnt As Integer
    Dim afst As String
    dist = Nz(sw("LEN_DISTANCE"))
    relCnt = CInt(val(Nz(sw("LEN_RELAYCOUNT"), 0)))
    If (relCnt = 1) Then
      Afstand = dist
    Else
      Afstand = relCnt & "x" & dist
    End If
    slag = lenParseStroke(Nz(sw("LEN_STROKE")))
    besAfw = Nz(sw("LEN_NAME"))
  End If
End If

lenLoadLXSwimStyle = True
Exit Function
fout:
MsgBox Err & " " & Error$, 16
Exit Function
End Function


Private Function lenCollPrepareIt(ByRef coll As Recordset, ByVal collID As Long, ByVal objTypeName As String, ByRef done As Boolean) As Boolean
On Error GoTo fout
lenCollPrepareIt = False

done = True

If (collID >= 0) Then
 coll.FindFirst "ID_" & objTypeName & "_COLL = " & collID
 If (Not coll.NoMatch) Then
    done = coll.EOF
 End If
End If

lenCollPrepareIt = True
Exit Function
fout:
MsgBox Err & " " & Error$, 16

Exit Function

'debug
On Error GoTo 0
Resume Next
Exit Function
End Function

Private Function lenCollGetNextID(ByRef coll As Recordset, ByVal collID As Long, ByVal objTypeName As String, ByRef nxtID As Long, ByRef done As Boolean) As Boolean
On Error GoTo fout
lenCollGetNextID = False

nxtID = Nz(coll("SYS_REF_CH_" & objTypeName), -1)

done = False

coll.MoveNext
If (coll.EOF) Then
  done = True
Else
  If (coll("ID_" & objTypeName & "_COLL") <> collID) Then
    done = True
  End If
End If


lenCollGetNextID = True
Exit Function
fout:
MsgBox Err & " " & Error$, 16
Exit Function
End Function


Private Function lenLoadLXContact(ByRef cnt As Recordset, ByVal cntID As Long, ByRef cont As CONTACT_INFO) As Boolean
On Error GoTo fout
lenLoadLXContact = False

'init contact
cont.adres = ""
cont.adres2 = ""
cont.sEmail = ""
cont.fax = ""
cont.internet = ""
cont.mobiel = ""
cont.naam = ""
cont.nation = ""
cont.sPlaats = ""
cont.sPostcode = ""
cont.state = ""
cont.tel = ""


If (cntID >= 0) Then
  cnt.Seek "=", cntID
  If (Not cnt.NoMatch) Then
    cont.adres = Nz(cnt("LEN_STREET"))
    cont.adres2 = Nz(cnt("LEN_STREET2"))
    cont.sEmail = Nz(cnt("LEN_EMAIL"))
    cont.fax = Nz(cnt("LEN_FAX"))
    cont.internet = Nz(cnt("LEN_INTERNET"))
    cont.mobiel = Nz(cnt("LEN_MOBILE"))
    cont.naam = Nz(cnt("LEN_NAME"))
    cont.nation = Nz(cnt("LEN_COUNTRY"))
    cont.sPlaats = Nz(cnt("LEN_CITY"))
    cont.sPostcode = Nz(cnt("LEN_ZIP"))
    cont.state = Nz(cnt("LEN_STATE"))
    cont.tel = Nz(cnt("LEN_PHONE"))
  End If
End If



lenLoadLXContact = True
Exit Function
fout:
MsgBox Err & " " & Error$, 16
Exit Function


End Function
Private Function lenAppendLXContact(ByRef cnt As Recordset, ByVal cntID As Long, ByRef cont As CONTACT_INFO) As Boolean
On Error GoTo fout
lenAppendLXContact = False

cnt.AddNew
  cnt("ID_CONTACT") = cntID
  cnt("LEN_CITY") = hzn(cont.sPlaats)
  cnt("LEN_COUNTRY") = hzn(cont.nation)
  cnt("LEN_EMAIL") = hzn(cont.sEmail)
  cnt("LEN_FAX") = hzn(cont.fax)
  cnt("LEN_INTERNET") = hzn(cont.internet)
  cnt("LEN_MOBILE") = hzn(cont.mobiel)
  cnt("LEN_NAME") = hzn(cont.naam)
  cnt("LEN_PHONE") = hzn(cont.tel)
  cnt("LEN_STATE") = hzn(cont.state)
  cnt("LEN_STREET") = hzn(cont.adres)
  cnt("LEN_STREET2") = hzn(cont.adres2)
  cnt("LEN_ZIP") = hzn(cont.sPostcode)
cnt.Update

lenAppendLXContact = True
Exit Function
fout:
MsgBox Err & " " & Error$, 16
Exit Function


End Function







Private Function lenReadProgrammaFromXMLTables(ByVal lxVersion As Long, ByVal wedAgeDate As Date, ByVal lftBep As String, ByVal recAgeMode As String, ByRef currencyStr As String, ByVal glbBaanLengte As Integer) As Boolean
On Error GoTo fout
lenReadProgrammaFromXMLTables = False




Dim limS As Recordset
Dim limsSQl As String
limsSQl = "SELECT gIMP_LEN_LIMIETEN.* " & _
          "FROM gIMP_LEN_LIMIETEN ORDER BY gIMP_LEN_LIMIETEN.LIM_Afstand, gIMP_LEN_LIMIETEN.LIM_Slag, gIMP_LEN_LIMIETEN.INT_Geslacht,gIMP_LEN_LIMIETEN.INT_Max_Age, gIMP_LEN_LIMIETEN.LIM_Baan ;"
          


Set limS = CurrentDb().OpenRecordset(limsSQl, dbOpenDynaset)


Dim recs As Recordset
Dim recsSQL As String
recsSQL = "SELECT fmtName(nz([ZW_Voornaam]),nz([zw_Voegsel]),nz([zw_achternaam])) AS ZWNAAM, gIMP_LEN_Records.* " & _
    "FROM gIMP_LEN_Records LEFT JOIN gIMP_LEN_Zwemmers ON gIMP_LEN_Records.REC_Zwemmer_ID = gIMP_LEN_Zwemmers.ZW_ID  " & _
 "ORDER BY gIMP_LEN_Records.Rec_Afstand, gIMP_LEN_Records.REC_Slag, gIMP_LEN_Records.REC_Baan, gIMP_LEN_Records.INT_MAX_AGE, gIMP_LEN_Records.INT_Geslacht; "


Set recs = CurrentDb().OpenRecordset(recsSQL, dbOpenDynaset)




Dim pr As Recordset
Dim prSQL As String
'modification nov 2006: remove order by ID_SESSION part, to ensure
'correct numbering of programmanummers.
prSQL = "SELECT LEN_EVENT.*, LEN_SESSION.ID_SESSION, LEN_SESSION.LEN_COURSE " & _
        "FROM ((LEN_EVENT INNER JOIN LEN_EVENT_COLL ON LEN_EVENT.ID_EVENT = LEN_EVENT_COLL.SYS_REF_CH_EVENT) INNER JOIN " & _
        "LEN_EVENTS ON LEN_EVENT_COLL.ID_EVENT_COLL = LEN_EVENTS.SYS_REF_EVENT_COLL) INNER JOIN LEN_SESSION ON LEN_EVENTS.ID_EVENTS = " & _
        "LEN_SESSION.SYS_REF_EVENTS order by  val(nz([LEN_EVENTID]));"
        '"LEN_SESSION.SYS_REF_EVENTS order by ID_SESSION, val(nz([LEN_EVENTID]));"



'To be obsoleted
'Dim maxUsedProgNumPart As Long
'Dim lenNrMaxUsedProg As Long
'lenNrMaxUsedProg = -1
'Dim maxUsedLetterPart As Integer
'maxUsedProgNumPart = 0
'End to be obsoleted




Dim maxUsedProgNr As Long
'Ordered ascendingly
Dim usePrLenNrs(0 To MAX_N_PROGS) As Long
Dim usePrNumPart(0 To MAX_N_PROGS) As Long
Dim usePrLetterPart(0 To MAX_N_PROGS) As Integer
Dim nUsedPrs As Integer

Dim prUsedNumParts(0 To MAX_N_PROGS) As Long
Dim nPrUsedNumParts As Integer

maxUsedProgNr = 0
nUsedPrs = 0
nPrUsedNumParts = 0


Dim blUsingSuppliedProgNr As Boolean
blUsingSuppliedProgNr = False


Set pr = CurrentDb().OpenRecordset(prSQL)

Dim swst As Recordset
Set swst = CurrentDb().OpenRecordset("LEN_SWIMSTYLE")
swst.Index = "P"

Dim Kosten As Recordset
Set Kosten = CurrentDb().OpenRecordset("LEN_FEE")
Kosten.Index = "P"

Dim prOutp As Recordset
Set prOutp = CurrentDb().OpenRecordset("gIMP_LEN_Programma")

Dim lftOutp As Recordset
Set lftOutp = CurrentDb().OpenRecordset("gIMP_LEN_Leeftijdsgroepen")

Dim ageGrpColl As Recordset
Set ageGrpColl = CurrentDb().OpenRecordset("Select * from LEN_AGEGROUP_COLL order by [ID_AGEGROUP_COLL];", dbOpenDynaset)

Dim ageGrp As Recordset
Set ageGrp = CurrentDb().OpenRecordset("LEN_AGEGROUP")
ageGrp.Index = "P"

Dim detls As Recordset
Set detls = CurrentDb().OpenRecordset("LEN_EVENTDETAILS")
detls.Index = "P"

Dim shRec As Recordset
Set shRec = CurrentDb().OpenRecordset("LEN_SHORTRECORD")
shRec.Index = "P"

Dim rsTimeStdRefColl As Recordset
Set rsTimeStdRefColl = CurrentDb().OpenRecordset("Select * from LEN_TIMESTANDARDREF_COLL order by [ID_TIMESTANDARDREF_COLL];", dbOpenDynaset)

Dim rsTimeStdRef As Recordset
Set rsTimeStdRef = CurrentDb().OpenRecordset("LEN_TIMESTANDARDREF")
rsTimeStdRef.Index = "P"



Dim blRestrictTimeStdLists As Boolean
blRestrictTimeStdLists = False

If (lxVersion >= LX_VERSION_3) Then
  If (Nz(DCount("ID_TIMESTANDARDREF", "LEN_TIMESTANDARDREF"), 0) > 0) Then
    blRestrictTimeStdLists = True
  End If
End If


pr.MoveFirst

Dim isFirst As Boolean
isFirst = True

Do Until pr.EOF
  prOutp.AddNew
  
    Dim curProgID As Long
  
    prOutp("PR_WED_ID") = pr("ID_SESSION")
    prOutp("PR_ID") = pr("ID_EVENT")
    curProgID = Nz(pr("ID_EVENT"), -1)
    
    Dim lenEventID As Long
    lenEventID = Nz(pr("LEN_EVENTID"))
    Dim lenNumber As Long
    lenNumber = Nz(pr("LEN_NUMBER"))
    
    
    
    prOutp("INT_LEN_ID") = lenEventID
    prOutp("INT_LEN_NR_ID") = lenNumber
    'TODO: something about pr_Programmanummer.
    
    Dim prognrIsFixed As Boolean
    
    Dim prognr As String
    
    prognr = Nz(pr("LEN_DISPLAYEVENTID"))
    prognrIsFixed = True
    If (prognr = "") Then
      'Here have to do something better.
      prognrIsFixed = False
    End If
    
    If (isFirst) Then
      If (prognrIsFixed) Then
        blUsingSuppliedProgNr = True
      Else
        blUsingSuppliedProgNr = False
      End If
      isFirst = False
    End If
    
    If (blUsingSuppliedProgNr And Not prognrIsFixed) Then
      Err.Raise 1, , "File did not contain <DisplayEventID> node for lenex prog id: " & lenEventID
    End If
    
    If (Not blUsingSuppliedProgNr) Then
    
      Dim usedLenNrIdx As Integer
      usedLenNrIdx = bSearchLong(lenNumber, nUsedPrs, usePrLenNrs)
      If (usedLenNrIdx <> -1) Then
              
        'The lenNumber was encountered previously. So use a new letter
        usePrLetterPart(usedLenNrIdx) = usePrLetterPart(usedLenNrIdx) + 1
        
        prognr = usePrNumPart(usedLenNrIdx) & Chr(Asc("a") + usePrLetterPart(usedLenNrIdx))
              
      Else
        'The lenNumber is as yet unused.
        
        Dim prNumIdx As Integer
        prNumIdx = bSearchLong(lenNumber, nPrUsedNumParts, prUsedNumParts)
        
        Dim newPrNr As Long
        
        If (prNumIdx = -1) Then
          'We can use lenNumber as the programmanumer
          newPrNr = lenNumber
        Else
          
          'Need to invent a new programmanummer.
          newPrNr = maxUsedProgNr + 1
          
          'Insert the new number into the used number list.
          insLong newPrNr, nPrUsedNumParts, prUsedNumParts
        End If
        
        If (newPrNr > maxUsedProgNr) Then
           maxUsedProgNr = newPrNr
        End If
        
        prognr = newPrNr
        
        
        
        'Insert the new lenNumber into data structures.
        Dim insLenIdx As Integer
        insLenIdx = insLong(lenNumber, nUsedPrs, usePrLenNrs)
        shiftRightLong insLenIdx, 1, nUsedPrs - 1, usePrNumPart
        shiftRightInt insLenIdx, 1, nUsedPrs - 1, usePrLetterPart
        
        usePrNumPart(insLenIdx) = newPrNr
        usePrLetterPart(insLenIdx) = -1
        
      End If
    

    End If
        
    
    
    
    
    
    
    
    
    prOutp("PR_ProgrammaNummer") = hzn(prognr)
    prOutp("PR_Programmanummer_Fixed") = prognrIsFixed
    
    Dim progGender As String
    progGender = Nz(pr("LEN_GENDER"))
    
    Dim swsID As Long
    swsID = Nz(pr("SYS_REF_SWIMSTYLE"), -1)
    Dim afst As String, slag As String, besAfw As String, Baanlengte As Integer
    
    Baanlengte = glbBaanLengte
    If (Nz(pr("LEN_COURSE")) <> "") Then
      Baanlengte = lenParseCourse(Nz(pr("LEN_COURSE")))
    End If
    
    If Not lenLoadLXSwimStyle(swst, swsID, afst, slag, besAfw) Then
      Exit Function
    End If
    prOutp("PR_Afstand") = hzn(afst)
    prOutp("PR_Slag") = hzn(slag)
    prOutp("PR_BeschrijvingAfwijkend") = hzn(besAfw)
        
    prOutp("PR_Opmerking") = pr("LEN_REMARK")
    
    
    Dim lenProgType As String
    lenProgType = Nz(pr("LEN_ROUND"))
    
    
    
    Dim finType As String
    finType = Nz(pr("LEN_FINALTYPE"))
    
    Dim progType As String
    progType = lenParseProgType(lenProgType, finType)
    
    prOutp("PR_Type") = hzn(progType)
    
    prOutp("INT_LEN_TYPE") = hzn(lenProgType)
    
    
    
    Dim ptOpen As Boolean
    ptOpen = ptOpenForEntry(progType)
    
    
    'Need to determine if TIMESTANDARDREF restrictions are in place
    Dim prTimeStdRefCollID As Long
    prTimeStdRefCollID = Nz(pr("SYS_REF_TIMESTANDARDREFS"), -1)
    
    Dim nTimeStdRefs As Integer
    nTimeStdRefs = 0
    
    Dim lTimeStdListIDs(0 To 1000) As Long
    
    Dim done As Boolean
    done = True
    If (Not lenCollPrepareIt(rsTimeStdRefColl, prTimeStdRefCollID, "TIMESTANDARDREF", done)) Then
      Exit Function
    End If
    Do Until done
      Dim prTimeStdRefID As Long
      If (Not lenCollGetNextID(rsTimeStdRefColl, prTimeStdRefCollID, "TIMESTANDARDREF", prTimeStdRefID, done)) Then
        Exit Function
      End If
      rsTimeStdRef.Seek "=", prTimeStdRefID
      If Not rsTimeStdRef.NoMatch Then
        Dim tpTimeStdListID As Long
        tpTimeStdListID = Nz(rsTimeStdRef("LEN_TIMESTANDARDLISTID"))
        insLong tpTimeStdListID, nTimeStdRefs, lTimeStdListIDs
      End If
    Loop
    
    
    
    
    

    Dim agID As Long
    Dim agLenID As Long
    Dim agCatInf As CAT_INFO
    Dim agCnt As Integer
    agCnt = 0
    
    
    'Have to go for agegroups.
    Dim prAGCollID As Long
    prAGCollID = Nz(pr("SYS_REF_AGEGROUPS"), -1)
    
    Dim blAllAGHaveLim As Boolean
    Dim blAllAGHaveVVT As Boolean
    Dim blAllAGHaveRec As Boolean
    
    blAllAGHaveLim = True
    blAllAGHaveVVT = True
    blAllAGHaveRec = True
    
    done = True
    If (Not lenCollPrepareIt(ageGrpColl, prAGCollID, "AGEGROUP", done)) Then
      Exit Function
    End If
    Do Until done
      Dim prAGID As Long
      If (Not lenCollGetNextID(ageGrpColl, prAGCollID, "AGEGROUP", prAGID, done)) Then
        Exit Function
      End If
      
      Dim curAGLXID As Long
      Dim curAGID As Long
      Dim curAGCatInf As CAT_INFO
      
      If (agCnt = 0) Then
        If (Not lenLoadLXAgeGroup(lxVersion, ageGrp, detls, shRec, ptOpen, limS, True, recs, afst, slag, Baanlengte, recAgeMode, prAGID, agLenID, wedAgeDate, lftBep, progGender, agCatInf, _
          blRestrictTimeStdLists, nTimeStdRefs, lTimeStdListIDs)) Then
          Exit Function
        End If
        agID = prAGID
        
        'Now determine the limit / vvt / rec status
        If (Trim(agCatInf.lim) = "") Then
          blAllAGHaveLim = False
        End If
        
        If (agCatInf.vvt < 1) Then
          blAllAGHaveVVT = False
        End If
        
        If (agCatInf.rec.tijd < 1) Then
          blAllAGHaveRec = False
        End If
        
      Else
        If (Not lenLoadLXAgeGroup(lxVersion, ageGrp, detls, shRec, ptOpen, limS, True, recs, afst, slag, Baanlengte, recAgeMode, prAGID, curAGLXID, wedAgeDate, lftBep, progGender, curAGCatInf, _
          blRestrictTimeStdLists, nTimeStdRefs, lTimeStdListIDs)) Then
          Exit Function
        End If
        curAGID = prAGID
        
        'Now determine the limit / vvt / rec status
        If (Trim(curAGCatInf.lim) = "") Then
          blAllAGHaveLim = False
        End If
        
        If (curAGCatInf.vvt < 1) Then
          blAllAGHaveVVT = False
        End If
        
        If (curAGCatInf.rec.tijd < 1) Then
          blAllAGHaveRec = False
        End If
        
      End If
                    
      
      If (agCnt > 0) Then
        If (agCnt = 1) Then
           'have to add first agegroup to agegroups table.
           If Not lenAppendAgeGroup(lftOutp, agLenID, agID, curProgID, agCatInf) Then
              Exit Function
            End If
        End If
        
        'add current agegroup to agegroups table.
    
        If (Not lenAppendAgeGroup(lftOutp, curAGLXID, curAGID, curProgID, curAGCatInf)) Then
          Exit Function
        End If
        
      End If
      agCnt = agCnt + 1
      
      
    Loop
    
    
    
    
    
    Dim detlsID As Long
    detlsID = Nz(pr("SYS_REF_EVENTDETAILS"), -1)
    
    Dim detCatInf As CAT_INFO
    
    Dim auxCat As String
    Dim auxCatBes As String
    
    Dim isMVarProg As Boolean
    isMVarProg = False
    
    'Need to determine the category based on information from the agegroups.
      If (agCnt = 0) Then
        'There were no agegroups.
        auxCat = lenParseAgeGroup(lftBep, wedAgeDate, progGender, -1, -1, False, False)
        auxCatBes = catBeschrijving(auxCat)
      ElseIf (agCnt = 1) Then
        auxCat = agCatInf.cat
        auxCatBes = agCatInf.bescat
      Else
        'This is a multiple category programmanummer.
        isMVarProg = True
        auxCat = lenParseAgeGroup(lftBep, wedAgeDate, progGender, -1, -1, False, True)
        auxCatBes = catBeschrijving(auxCat)
      End If
    
    
    
    
    
    
    
    If (Not lenDetermineEventDetails(detls, shRec, ptOpen, limS, True, recs, afst, slag, Baanlengte, recAgeMode, detlsID, wedAgeDate, lftBep, "", -1, -1, False, "", auxCat, auxCatBes, detCatInf, _
      blRestrictTimeStdLists, nTimeStdRefs, lTimeStdListIDs)) Then
      Exit Function
    End If
    
    
        
    'Now output detCatInf
    
    'Have to be careful here in case of MVarProg, in which we do not want to use
    'a global vvt if all individual subagegroups have vvt
    'and we do not want to use a global lim /reslim if all individual subagegroups have this feature.
    
    If (isMVarProg And Not detCatInf.blDetFromEvDetails) Then
      If (blAllAGHaveLim) Then
        detCatInf.lim = ""
        detCatInf.resLim = ""
      End If
      If (blAllAGHaveVVT) Then
        detCatInf.vvt = 0
      End If
      If (blAllAGHaveRec) Then
        detCatInf.rec.tijd = 0
      End If
    End If
    If (Not lenWriteCatInfo(prOutp, "PR_", False, detCatInf)) Then
      Exit Function
    End If
    
    Dim feeID As Long
    feeID = Nz(pr("SYS_REF_FEE"), -1)
    Dim kostenVal As Double
    Dim kostenCurrS As String
    Dim kostPC As Boolean, kostPZW As Boolean, kostPP As Boolean
    If Not (lenLoadLXFee(Kosten, feeID, kostenCurrS, kostenVal, kostPC, kostPZW, kostPP)) Then
      Exit Function
    End If
    
    If (kostenCurrS <> "") Then
      currencyStr = kostenCurrS
    End If
    
    If (kostenVal > 0.001) Then
      prOutp("PR_Kosten") = kostenVal
    End If
    
    
    
    
    Dim lenPrvEvID As Long
    lenPrvEvID = CLng(val(Nz(pr("LEN_PREVEVENTID"), -1)))
    
    If (lenPrvEvID >= 0) Then
      prOutp("INT_Vorig_Prog_LEN_ID") = lenPrvEvID
    Else
      prOutp("INT_VORIG_PROG_LEN_ID") = Null
    End If
    
    prOutp("PR_VORIG_PROG_ID") = Null
    
    Dim aanvS As String
    aanvS = Nz(pr("LEN_DAYTIME"))
    If (aanvS <> "") Then
      prOutp("PR_Aanvang") = lenParseDaytime(aanvS)
    End If
    
    
    'february 2007
    Dim isNonComp As Boolean
    isNonComp = lenParseBoolean(Nz(pr("LEN_NONCOMP")))
    If (isNonComp) Then
      prOutp("PR_BM") = "J"
    Else
      prOutp("PR_BM") = "N"
    End If
    prOutp("PR_AantMeetel") = Nz(pr("LEN_NRCNTPTC"), 0)
    'end addition.
    
    
    
    
    
      
    
    
  prOutp.Update
  pr.MoveNext
Loop



appCleanRS limS
appCleanRS recs
appCleanRS pr
appCleanRS swst
appCleanRS Kosten
appCleanRS prOutp
appCleanRS lftOutp
appCleanRS ageGrpColl
appCleanRS ageGrp
appCleanRS detls
appCleanRS shRec
appCleanRS rsTimeStdRef
appCleanRS rsTimeStdRefColl



'Now need to read PR_Vorig_Prog_ID from table.
Dim updPrIDSQL As String
updPrIDSQL = "UPDATE gIMP_LEN_Programma INNER JOIN gIMP_LEN_Programma AS gIMP_LEN_Programma_1 ON " & _
"gIMP_LEN_Programma.INT_Vorig_Prog_LEN_ID = gIMP_LEN_Programma_1.INT_LEN_ID SET gIMP_LEN_Programma.PR_Vorig_Prog_ID = " & _
"[gIMP_LEN_PROGRAMMA_1].[PR_ID], [gIMP_LEN_PROGRAMMA].INT_LEN_TYPE = lenQRYReformatProgType(nz([gIMP_LEN_PROGRAMMA].INT_LEN_TYPE),nz([gIMP_LEN_PROGRAMMA_1].INT_LEN_TYPE)) ;"
DoCmd.SetWarnings False
DoCmd.RunSQL updPrIDSQL
DoCmd.SetWarnings True

Dim updPrvLenTypeSQL As String
updPrvLenTypeSQL = "UPDATE gIMP_LEN_Programma INNER JOIN gIMP_LEN_Programma AS gIMP_LEN_Programma_1 ON gIMP_LEN_Programma.PR_Vorig_Prog_ID = " & _
      "gIMP_LEN_Programma_1.PR_ID SET gIMP_LEN_Programma_1.INT_LEN_Type = lenQRYReformatPrvProgType(nz([gIMP_LEN_Programma_1].[INT_LEN_TYPE]), " & _
      "nz([gIMP_LEN_Programma].[INT_LEN_TYPE]));"
      
DoCmd.SetWarnings False
DoCmd.RunSQL updPrvLenTypeSQL
DoCmd.SetWarnings True




lenReadProgrammaFromXMLTables = True
Exit Function
fout:
If (Err = 3021) Then Resume Next

DoCmd.SetWarnings True
MsgBox Err & " lenRedProgrammaFromXMLTables" & vbCrLf & Error$, 16
Exit Function
'debug
On Error GoTo 0
Resume
End Function

'Prerequisite for calling this function:
'lenReadClubsFromXMLTables should have been called
'This is necessary to ensure that ZW_PartOfRecord and ZW_PartOfTimeArchive are set correctly
Private Function lenReadAthletesFromXMLTables() As Boolean
On Error GoTo fout
lenReadAthletesFromXMLTables = False


Dim athlSQL As String
athlSQL = "SELECT LEN_ATHLETE.*, LEN_CLUB.ID_CLUB " & _
          "FROM ((LEN_ATHLETES LEFT JOIN LEN_CLUB ON LEN_ATHLETES.ID_ATHLETES = LEN_CLUB.SYS_REF_ATHLETES) " & _
          "RIGHT JOIN LEN_ATHLETE_COLL ON LEN_ATHLETES.SYS_REF_ATHLETE_COLL = LEN_ATHLETE_COLL.ID_ATHLETE_COLL) " & _
          "RIGHT JOIN LEN_ATHLETE ON LEN_ATHLETE_COLL.SYS_REF_CH_ATHLETE = LEN_ATHLETE.ID_ATHLETE;"
          
Dim ats As Recordset
Set ats = CurrentDb().OpenRecordset(athlSQL)


Dim skHnd As Recordset
Set skHnd = CurrentDb().OpenRecordset("LEN_HANDICAP")
skHnd.Index = "P"

Dim maxUsedExtAthID As Long
maxUsedExtAthID = -1

Dim zwOutp As Recordset
Set zwOutp = CurrentDb().OpenRecordset("gIMP_LEN_ZWEMMERS")


ats.MoveFirst
Do Until ats.EOF
  zwOutp.AddNew
  
    zwOutp("ZW_ID") = ats("ID_ATHLETE")
    
    zwOutp("INT_LEN_ID") = ats("LEN_ATHLETEID")
    
    'ZW_PartOfTimeArchive will be updated later.
    zwOutp("ZW_PartOfTimeArchive") = False
    
    Dim verID As Long
    
    verID = Nz(ats("ID_CLUB"), -1)
    If (verID <> -1) Then
      zwOutp("ZW_PartOfRecord") = False
      zwOutp("ZW_VER_ID") = verID
    Else
      zwOutp("ZW_PartOfRecord") = True
      verID = Nz(ats("SYS_REF_CLUB"), -1)
      zwOutp("ZW_VER_ID") = verID
    End If
    
    zwOutp("ZW_Voornaam") = ats("LEN_FIRSTNAME")
    zwOutp("ZW_MiddelNaam") = ats("LEN_MIDDLENAME")
    zwOutp("ZW_Voegsel") = ats("LEN_NAMEPREFIX")
    zwOutp("ZW_Achternaam") = ats("LEN_LASTNAME")
    zwOutp("ZW_Geslacht") = hzn(lenParseGender(Nz(ats("LEN_GENDER"))))
    
    zwOutp("ZW_FlatClubCode") = ats("LEN_Code")
    
    Dim gebDatS As String
    Dim gebDat As Date
    gebDatS = Nz(ats("LEN_BIRTHDATE"))
    If (gebDatS = "") Then
      gebDat = #1/1/1960#
    Else
      gebDat = lenParseDate(gebDatS)
    End If
    
    
    If Not lenDateIsValid(gebDat) Then
      'in practice, it is too harsh to just give a warning here.
      gebDat = #1/1/1900#
      'MsgBox "Illegal athlete: " & Nz(ats("LEN_FIRSTNAME")) & " " & Nz(ats("LEN_NAMEPREFIX")) & " " & Nz(ats("LEN_LASTNAME")) & Chr(13) & "Illegal birthdate: " & gebDatS, 16
      'Exit Function
    End If
        
    Dim yr As Long
    yr = CInt(val(Format(gebDat, "yyyy")))
    
    zwOutp("ZW_Jaartal") = yr
    zwOutp("ZW_GeboorteDatum") = gebDat
    
    Dim nation As String
    Dim Code As String
    
    nation = Nz(ats("LEN_NATION"))
    Code = Nz(ats("LEN_LICENSE"))
    
    Dim stnr As String
    Dim stnrValid As Boolean
    
    stnr = lenParseStartnr(Code, nation, gebDat, maxUsedExtAthID, stnrValid)
    
    zwOutp("ZW_Startnummer") = hzn(stnr)
    zwOutp("ZW_Startnummer_Fixed") = stnrValid
    
    zwOutp("ZW_ExternalLicenseCode") = hzn(Code)
    
    zwOutp("ZW_Nation") = hzn(nation)
    
    
    Dim tpHndID As Long
    tpHndID = Nz(ats("SYS_REF_HANDICAP"), -1)
    
    If (tpHndID >= 0) Then
      skHnd.Seek "=", tpHndID
      If Not skHnd.NoMatch Then
        Dim tpHndFree As String, tpHndBreast As String, tpHndMedley As String, tpHndException As String
        
        tpHndFree = lenParseHandicap(Nz(skHnd("LEN_free")))
        tpHndBreast = lenParseHandicap(Nz(skHnd("LEN_breast")))
        tpHndMedley = lenParseHandicap(Nz(skHnd("LEN_medley")))
        
        tpHndException = Nz(skHnd("LEN_exception"))
        
        zwOutp("ZW_HND_Free") = hzn(tpHndFree)
        zwOutp("ZW_HND_Breast") = hzn(tpHndBreast)
        zwOutp("ZW_HND_Medley") = hzn(tpHndMedley)
        zwOutp("ZW_HND_Exception") = hzn(tpHndException)
        
      End If
    End If
   
   
   
  zwOutp.Update
  ats.MoveNext
Loop

appCleanRS zwOutp
appCleanRS ats
appCleanRS skHnd


'Update ZW_PartOfTimeArchive
Dim sql As String
sql = "UPDATE gIMP_LEN_Zwemmers INNER JOIN gIMP_LEN_Ver ON gIMP_LEN_Zwemmers.ZW_VER_ID = " & _
  "gIMP_LEN_Ver.V_ID SET gIMP_LEN_Zwemmers.ZW_PartOfTimeArchive = [v_partOfTimeArchive];"


DoCmd.SetWarnings False
DoCmd.RunSQL sql
DoCmd.SetWarnings True



lenReadAthletesFromXMLTables = True
Exit Function
fout:
If (Err = 3021) Then Resume Next


DoCmd.SetWarnings True

MsgBox Err & " lenReadAthletesFromXMLTables" & Error$, 16

Exit Function

'debug
On Error GoTo 0
Resume

Exit Function
End Function


'Prerequisite: lenReadClubsFromXMLTables must have been called
Private Function lenReadRelayTeamsFromXMLTables() As Boolean
On Error GoTo fout
lenReadRelayTeamsFromXMLTables = False

Dim sql As String
sql = "SELECT LEN_RELAY.*, [len_club].ID_CLUB FROM ((LEN_CLUB RIGHT JOIN LEN_RELAYS ON LEN_CLUB.SYS_REF_RELAYS = LEN_RELAYS.ID_RELAYS) RIGHT JOIN LEN_RELAY_COLL ON " & _
      "LEN_RELAYS.SYS_REF_RELAY_COLL = LEN_RELAY_COLL.ID_RELAY_COLL) RIGHT JOIN LEN_RELAY ON LEN_RELAY_COLL.SYS_REF_CH_RELAY = LEN_RELAY.ID_RELAY;"
      
Dim pl As Recordset
Set pl = CurrentDb().OpenRecordset(sql)


Dim plOutp As Recordset
Set plOutp = CurrentDb().OpenRecordset("gIMP_LEN_PLOEG")

pl.MoveFirst
Do Until pl.EOF


  plOutp.AddNew
    plOutp("PL_ID") = pl("ID_RELAY")
    
    'PL_PartOfTimeArchive will be updated later.
    plOutp("PL_PartOfTimeArchive") = False
    
    Dim verID As Long
    Dim partOfRecord As Boolean
    partOfRecord = True
    verID = Nz(pl("SYS_REF_CLUB"), -1)
    If (verID = -1) Then
      partOfRecord = False
      verID = Nz(pl("ID_CLUB"))
    End If
    plOutp("PL_PartOfRecord") = partOfRecord
    plOutp("PL_VER_ID") = verID
    plOutp("PL_Geslacht") = hzn(lenParseGender(Nz(pl("LEN_GENDER"))))
    plOutp("PL_Naam") = pl("LEN_NAME")
    plOutp("PL_Nummer") = IIf(IsNull(pl("LEN_NUMBER")), Null, CInt(val(Nz(pl("LEN_NUMBER")))))
    plOutp("PL_MinTotAge") = IIf(IsNull(pl("LEN_AGETOTALMIN")), Null, CInt(val(Nz(pl("LEN_AGETOTALMIN")))))
    plOutp("PL_MaxTotAge") = IIf(IsNull(pl("LEN_AGETOTALMAX")), Null, CInt(val(Nz(pl("LEN_AGETOTALMAX")))))
    plOutp("PL_MinAge") = IIf(IsNull(pl("LEN_AGEMIN")), Null, CInt(val(Nz(pl("LEN_AGEMIN")))))
    plOutp("PL_MaxAge") = IIf(IsNull(pl("LEN_AGEMAX")), Null, CInt(val(Nz(pl("LEN_AGEMAX")))))
  plOutp.Update
  

  

  pl.MoveNext
Loop


appCleanRS pl
appCleanRS plOutp


'Update PL_PartOfTimeArchive
sql = "UPDATE gIMP_LEN_Ploeg INNER JOIN gIMP_LEN_Ver ON gIMP_LEN_Ploeg.PL_VER_ID = " & _
  "gIMP_LEN_Ver.V_ID SET gIMP_LEN_Ploeg.PL_PartOfTimeArchive = [v_partOfTimeArchive];"


DoCmd.SetWarnings False
DoCmd.RunSQL sql
DoCmd.SetWarnings True






lenReadRelayTeamsFromXMLTables = True
Exit Function
fout:
If (Err = 3021) Then Resume Next

DoCmd.SetWarnings True

MsgBox Err & " lenReadRelayTeamsFromXMLTables" & Error$, 16

Exit Function

'debug
On Error GoTo 0
Resume

Exit Function
End Function


Private Function lenReadRelaySwimmersFromRS(ByRef rs As Recordset, ByRef rsOutp As Recordset, ByRef skMtInfo As Recordset, ByVal isResult As Boolean, ByVal isEntry As Boolean, ByVal isRecord As Boolean, ByVal isArchivedTime As Boolean) As Boolean
On Error GoTo fout
lenReadRelaySwimmersFromRS = False

Dim curPloegID As Long
curPloegID = -1
Dim curPloegMaxVolg As Integer
curPloegMaxVolg = -1

rs.MoveFirst
Do Until rs.EOF

  If Nz(rs("ID_RELAY")) <> curPloegID Then
    curPloegID = Nz(rs("ID_RELAY"))
    curPloegMaxVolg = -1
  End If
    


  rsOutp.AddNew
  
  rsOutp("PLL_ID") = rs("ID_RELAYPOSITION")
  rsOutp("PLL_PLOEG_ID") = rs("ID_RELAY")
  
  If (isResult) Then
    rsOutp("PLL_Deelnemer_ID") = Null
    rsOutp("PLL_Record_ID") = Null
    rsOutp("PLL_TIJD_ID") = rs("ID_RESULT")
    rsOutp("PLL_TMA_Tijd_ID") = Null
    rsOutp("PLL_ZWEMMER_ID") = Null
    rsOutp("INT_ZWEMMER_LEN_ID") = rs("LEN_ATHLETEID")
  ElseIf (isRecord) Then
    rsOutp("PLL_TIJD_ID") = Null
    rsOutp("PLL_Deelnemer_ID") = Null
    rsOutp("PLL_RECORD_ID") = rs("ID_RECORD")
    rsOutp("PLL_TMA_Tijd_ID") = Null
    rsOutp("PLL_ZWEMMER_ID") = Nz(rs("SYS_REF_ATHLETE"), -1)
    rsOutp("INT_ZWEMMER_LEN_ID") = Null
  ElseIf (isEntry) Then
    rsOutp("PLL_RECORD_ID") = Null
    rsOutp("PLL_TIJD_ID") = Null
    rsOutp("PLL_Deelnemer_ID") = rs("ID_ENTRY")
    rsOutp("PLL_TMA_Tijd_ID") = Null
    rsOutp("PLL_ZWEMMER_ID") = Null
    rsOutp("INT_ZWEMMER_LEN_ID") = rs("LEN_ATHLETEID")
  ElseIf (isArchivedTime) Then
    rsOutp("PLL_RECORD_ID") = Null
    rsOutp("PLL_TIJD_ID") = Null
    rsOutp("PLL_Deelnemer_ID") = Null
    rsOutp("PLL_TMA_Tijd_ID") = rs("ID_ARCHIVEDTIME")
    rsOutp("PLL_ZWEMMER_ID") = Null
    rsOutp("INT_ZWEMMER_LEN_ID") = rs("LEN_ATHLETEID")
  End If
  
  Dim volg As Integer
  volg = CInt(val(Nz(rs("LEN_NUMBER"))))
  
  Dim isRes As Boolean
  isRes = False
  If (volg = -1) Then
    volg = curPloegMaxVolg + 1
    curPloegMaxVolg = volg
    isRes = True
  ElseIf (volg > curPloegMaxVolg) Then
    curPloegMaxVolg = volg
  End If
  
  rsOutp("PLL_Volgorde") = volg
  rsOutp("PLL_Reserve") = isRes
  
  
  Dim dis As String
  dis = Nz(rs("LEN_DSQCODE"))
  If (dis = "") Then
    dis = lenParseResultStatus(Nz(rs("LEN_STATUS")))
  End If
  
  If (Len(dis) > 10) Then
    dis = Left(dis, 10)
  End If
  
  rsOutp("PLL_DIS") = hzn(dis)
  
  
  Dim qlfTime As Double
  Dim qlfBaan As Integer
  Dim qlfDatum As Date
  Dim qlfPlaats As String
  Dim qlfNation As String
  Dim qlfWedName As String
  
  
  Dim tpMeetInfXID As Long
  tpMeetInfXID = Nz(rs("SYS_REF_MEETINFO"), -1)
  
  If (tpMeetInfXID > 0) Then
    If Not lenLoadLXMeetInfo(skMtInfo, tpMeetInfXID, qlfBaan, qlfPlaats, qlfNation, qlfDatum, qlfWedName, qlfTime) Then
      Exit Function
    End If
  Else
    qlfTime = lenParseSwimtime(Nz(rs("LEN_hup_entrytime")))
    qlfBaan = lenParseCourse(Nz(rs("LEN_hup_entrytimecourse")))
    qlfDatum = lenParseDate(Nz(rs("LEN_hup_entrytimedate")))
    qlfPlaats = Nz(rs("LEN_hup_entrytimecity"))
    qlfNation = Nz(rs("LEN_hup_entrytimenation"))
    qlfWedName = ""
  End If
  
  If (swtIsValid(qlfTime)) Then
    rsOutp("PLL_QLF_Tijd") = qlfTime
    If (lenDateIsValid(qlfDatum)) Then
      rsOutp("PLL_QLF_Datum") = qlfDatum
      rsOutp("PLL_QLF_Plaats") = hzn(qlfPlaats)
      rsOutp("PLL_QLF_Land") = hzn(qlfNation)
      rsOutp("PLL_QLF_Baan") = qlfBaan
      rsOutp("PLL_QLF_WedDescription") = hzn(qlfWedName)
    End If
  End If

  
  
  
  rsOutp.Update

  rs.MoveNext
Loop


lenReadRelaySwimmersFromRS = True
Exit Function
fout:
If (Err = 3021) Then Resume Next
MsgBox Err & " " & Error$, 16
Exit Function

'debug
On Error GoTo 0
Resume

End Function


Private Function lenReadRelaySwimmersFromXMLTables() As Boolean
On Error GoTo fout
lenReadRelaySwimmersFromXMLTables = False


Dim rs As Recordset
Dim sql As String




Dim skMtInf As Recordset
Set skMtInf = CurrentDb().OpenRecordset("LEN_MEETINFO")
skMtInf.Index = "P"



Dim rsOutp As Recordset
Set rsOutp = CurrentDb().OpenRecordset("gIMP_LEN_Ploegleden")


sql = "SELECT LEN_RELAYPOSITION.*, LEN_RELAY.ID_RELAY, LEN_RESULT.ID_RESULT " & _
      "FROM (((((LEN_RELAYPOSITION INNER JOIN LEN_RELAYPOSITION_COLL ON LEN_RELAYPOSITION.ID_RELAYPOSITION = " & _
      "LEN_RELAYPOSITION_COLL.SYS_REF_CH_RELAYPOSITION) INNER JOIN LEN_RELAYPOSITIONS ON LEN_RELAYPOSITION_COLL.ID_RELAYPOSITION_COLL = " & _
      "LEN_RELAYPOSITIONS.SYS_REF_RELAYPOSITION_COLL) INNER JOIN LEN_RESULT ON LEN_RELAYPOSITIONS.ID_RELAYPOSITIONS = " & _
      "LEN_RESULT.SYS_REF_RELAYPOSITIONS) INNER JOIN LEN_RESULT_COLL ON LEN_RESULT.ID_RESULT = LEN_RESULT_COLL.SYS_REF_CH_RESULT) " & _
      "INNER JOIN LEN_RESULTS ON LEN_RESULT_COLL.ID_RESULT_COLL = LEN_RESULTS.SYS_REF_RESULT_COLL) INNER JOIN " & _
      "LEN_RELAY ON LEN_RESULTS.ID_RESULTS = LEN_RELAY.SYS_REF_RESULTS ORDER BY LEN_RELAY.ID_RELAY, " & _
      "IIf(nz([LEN_RELAYPOSITION].[LEN_NUMBER])<0,100,nz([len_relayposition].[len_number]));"
      
      
Set rs = CurrentDb().OpenRecordset(sql)

If (Not lenReadRelaySwimmersFromRS(rs, rsOutp, skMtInf, True, False, False, False)) Then
  Exit Function
End If

appCleanRS rs

sql = "SELECT LEN_RELAYPOSITION.*, LEN_RELAY.ID_RELAY, LEN_RECORD.ID_RECORD " & _
      "FROM (((LEN_RELAYPOSITION INNER JOIN LEN_RELAYPOSITION_COLL ON LEN_RELAYPOSITION.ID_RELAYPOSITION = " & _
      "LEN_RELAYPOSITION_COLL.SYS_REF_CH_RELAYPOSITION) INNER JOIN LEN_RELAYPOSITIONS ON LEN_RELAYPOSITION_COLL.ID_RELAYPOSITION_COLL = " & _
      "LEN_RELAYPOSITIONS.SYS_REF_RELAYPOSITION_COLL) INNER JOIN LEN_RELAY ON LEN_RELAYPOSITIONS.ID_RELAYPOSITIONS = " & _
      "LEN_RELAY.SYS_REF_RELAYPOSITIONS) INNER JOIN LEN_RECORD ON LEN_RELAY.ID_RELAY = LEN_RECORD.SYS_REF_RELAY " & _
      "ORDER BY IIf(nz([LEN_RELAYPOSITION].[LEN_NUMBER])<0,100,nz([len_relayposition].[len_number]));"
      
Set rs = CurrentDb().OpenRecordset(sql)
      
If (Not lenReadRelaySwimmersFromRS(rs, rsOutp, skMtInf, False, False, True, False)) Then
  Exit Function
End If

appCleanRS rs


sql = "SELECT LEN_RELAYPOSITION.*, LEN_ENTRY.ID_ENTRY, LEN_RELAY.ID_RELAY " & _
     "FROM (((((LEN_RELAYPOSITION INNER JOIN LEN_RELAYPOSITION_COLL ON LEN_RELAYPOSITION.ID_RELAYPOSITION = " & _
     "LEN_RELAYPOSITION_COLL.SYS_REF_CH_RELAYPOSITION) INNER JOIN LEN_RELAYPOSITIONS ON LEN_RELAYPOSITION_COLL.ID_RELAYPOSITION_COLL = " & _
     "LEN_RELAYPOSITIONS.SYS_REF_RELAYPOSITION_COLL) INNER JOIN LEN_ENTRY ON LEN_RELAYPOSITIONS.ID_RELAYPOSITIONS = " & _
     "LEN_ENTRY.SYS_REF_RELAYPOSITIONS) INNER JOIN LEN_ENTRY_COLL ON LEN_ENTRY.ID_ENTRY = LEN_ENTRY_COLL.SYS_REF_CH_ENTRY) " & _
     "INNER JOIN LEN_ENTRIES ON LEN_ENTRY_COLL.ID_ENTRY_COLL = LEN_ENTRIES.SYS_REF_ENTRY_COLL) INNER JOIN LEN_RELAY ON " & _
     "LEN_ENTRIES.ID_ENTRIES = LEN_RELAY.SYS_REF_ENTRIES  " & _
     "ORDER BY IIf(nz([LEN_RELAYPOSITION].[LEN_NUMBER])<0,100,nz([len_relayposition].[len_number]));"
     
Set rs = CurrentDb().OpenRecordset(sql)
      
If (Not lenReadRelaySwimmersFromRS(rs, rsOutp, skMtInf, False, True, False, False)) Then
  Exit Function
End If


appCleanRS rs


sql = "SELECT LEN_RELAYPOSITION.*, LEN_RELAY.ID_RELAY, LEN_ARCHIVEDTIME.ID_ARCHIVEDTIME " & _
      "FROM (((((LEN_RELAYPOSITION INNER JOIN LEN_RELAYPOSITION_COLL ON LEN_RELAYPOSITION.ID_RELAYPOSITION = " & _
      "LEN_RELAYPOSITION_COLL.SYS_REF_CH_RELAYPOSITION) INNER JOIN LEN_RELAYPOSITIONS ON LEN_RELAYPOSITION_COLL.ID_RELAYPOSITION_COLL = " & _
      "LEN_RELAYPOSITIONS.SYS_REF_RELAYPOSITION_COLL) INNER JOIN LEN_ARCHIVEDTIME ON LEN_RELAYPOSITIONS.ID_RELAYPOSITIONS = " & _
      "LEN_ARCHIVEDTIME.SYS_REF_RELAYPOSITIONS) INNER JOIN LEN_ARCHIVEDTIME_COLL ON LEN_ARCHIVEDTIME.ID_ARCHIVEDTIME = LEN_ARCHIVEDTIME_COLL.SYS_REF_CH_ARCHIVEDTIME) " & _
      "INNER JOIN LEN_ARCHIVEDTIMES ON LEN_ARCHIVEDTIME_COLL.ID_ARCHIVEDTIME_COLL = LEN_ARCHIVEDTIMES.SYS_REF_ARCHIVEDTIME_COLL) INNER JOIN " & _
      "LEN_RELAY ON LEN_ARCHIVEDTIMES.ID_ARCHIVEDTIMES = LEN_RELAY.SYS_REF_ARCHIVEDTIMES ORDER BY LEN_RELAY.ID_RELAY, " & _
      "IIf(nz([LEN_RELAYPOSITION].[LEN_NUMBER])<0,100,nz([len_relayposition].[len_number]));"
      
      
Set rs = CurrentDb().OpenRecordset(sql)

If (Not lenReadRelaySwimmersFromRS(rs, rsOutp, skMtInf, False, False, False, True)) Then
  Exit Function
End If

appCleanRS rs


appCleanRS rsOutp
appCleanRS skMtInf
     
    
'Have to execute an sql statement to correct PLL_ZWEMMER_ID where necessary.
Dim updSQL As String
updSQL = "UPDATE gIMP_LEN_Ploegleden INNER JOIN gIMP_LEN_Zwemmers ON gIMP_LEN_Ploegleden.INT_Zwemmer_Len_ID = gIMP_LEN_Zwemmers.INT_LEN_ID SET gIMP_LEN_Ploegleden.PLL_Zwemmer_ID " & _
"= [zw_ID] WHERE (((gIMP_LEN_Ploegleden.PLL_Zwemmer_ID) Is Null));"

DoCmd.SetWarnings False
DoCmd.RunSQL updSQL
DoCmd.SetWarnings True





lenReadRelaySwimmersFromXMLTables = True
Exit Function

fout:
If (Err = 3021) Then Resume Next
MsgBox Err & " " & Error$, 16
Exit Function

End Function


Private Function lenReadClubsFromXMLTables(ByRef maxUsedContID As Long) As Boolean
On Error GoTo fout
lenReadClubsFromXMLTables = False



Dim maxUsedDepotNr As Long
maxUsedDepotNr = -1

Dim inp As Recordset
Set inp = CurrentDb().OpenRecordset("LEN_CLUB")

Dim verOutp As Recordset
Set verOutp = CurrentDb().OpenRecordset("gIMP_LEN_VER")

Dim cntOutp As Recordset
Dim cntInp As Recordset
Set cntInp = CurrentDb().OpenRecordset("LEN_CONTACT")
cntInp.Index = "P"

Set cntOutp = CurrentDb().OpenRecordset("gIMP_LEN_CONTACT")

inp.MoveFirst
Do Until inp.EOF
  
  verOutp.AddNew
   verOutp("V_ID") = inp("ID_CLUB")
   Dim nm As String
   nm = Nz(inp("LEN_SHORTNAME"))
   If (nm = "") Then
     nm = Nz(inp("LEN_NAME"))
   End If
   verOutp("V_Naam") = hzn(nm)
   verOutp("V_LangNaam") = inp("LEN_NAME")
   
   Dim nation As String
   nation = Nz(inp("LEN_NATION"))
   
   
   Dim athlID As Long, relID As Long
   athlID = Nz(inp("SYS_REF_ATHLETES"), -1)
   relID = Nz(inp("SYS_REF_RELAYS"), -1)
   
   
   'V_PartOfRecord and V_PartOfTimeArchive are set properly at the end of this procedure.
   'Initial values: V_PartOfRecord = true and V_PartOfTimeArchive = false
   
   verOutp("V_PartOfRecord") = True
   verOutp("V_PartOfTimeArchive") = False
   
   'Dim partOfRecord As Boolean
   'partOfRecord = False
   
   'If (athlID = -1 And relID = -1) Then
   '  partOfRecord = True
   'End If
   
   'verOutp("V_PartOfRecord") = partOfRecord
   
   
   
   Dim isDepValid As Boolean
   Dim depNr As String
   depNr = lenParseDepotnr(Nz(inp("LEN_CODE")), nation, maxUsedDepotNr, isDepValid)
   verOutp("V_Depot") = hzn(depNr)
   verOutp("V_DEPOT_FIXED") = isDepValid
   verOutp("V_Plaats") = inp("LEN_CITY")
   verOutp("V_Extern_Code") = inp("LEN_CODE")
   verOutp("V_Land") = hzn(nation)
   verOutp("V_LEN_TYPE") = inp("LEN_TYPE")
   verOutp("V_Region") = inp("LEN_Region")
   
   Dim contID As Long
   contID = Nz(inp("SYS_REF_CONTACT"), -1)
   
   Dim contInf As CONTACT_INFO
   If Not lenLoadLXContact(cntInp, contID, contInf) Then
     Exit Function
   End If
   If (contInf.naam <> "") Then
     maxUsedContID = maxUsedContID + 1
     If Not lenAppendContact(cntOutp, maxUsedContID, contInf) Then
       Exit Function
     End If
     
     verOutp("V_Contact_ID") = maxUsedContID
     
   End If
  
  
  verOutp.Update


  inp.MoveNext
Loop



appCleanRS verOutp
appCleanRS inp
appCleanRS cntOutp


'Need to correctly set V_PartOfRecord and V_PartOfTimeArchive

Dim sql As String

'Remember that V_PartOfRecord was automatically set to true and V_PartOfTimeArchive was automatically set to false

'Update V_PartOfRecord for MEET clubs
sql = "UPDATE gIMP_LEN_Ver INNER JOIN ((LEN_CLUB_COLL INNER JOIN LEN_CLUBS ON LEN_CLUB_COLL.ID_CLUB_COLL = " & _
  "LEN_CLUBS.SYS_REF_CLUB_COLL) INNER JOIN LEN_MEET ON LEN_CLUBS.ID_CLUBS = LEN_MEET.SYS_REF_CLUBS) ON " & _
  "gIMP_LEN_Ver.V_ID = LEN_CLUB_COLL.SYS_REF_CH_CLUB SET gIMP_LEN_Ver.V_PartOfRecord = False;"
  
DoCmd.SetWarnings False
DoCmd.RunSQL sql
DoCmd.SetWarnings True


'Update V_PartOfRecord and  V_PartOfTimeArchive for TIMEARCHIVE clubs
sql = "UPDATE (gIMP_LEN_Ver INNER JOIN (LEN_CLUB_COLL INNER JOIN LEN_CLUBS ON LEN_CLUB_COLL.ID_CLUB_COLL = " & _
  "LEN_CLUBS.SYS_REF_CLUB_COLL) ON gIMP_LEN_Ver.V_ID = LEN_CLUB_COLL.SYS_REF_CH_CLUB) INNER JOIN LEN_TIMEARCHIVE " & _
  "ON LEN_CLUBS.ID_CLUBS = LEN_TIMEARCHIVE.SYS_REF_CLUBS " & _
  "SET gIMP_LEN_Ver.V_PartOfRecord = False, gIMP_LEN_Ver.V_PartOfTimeArchive = True;"

DoCmd.SetWarnings False
DoCmd.RunSQL sql
DoCmd.SetWarnings True



lenReadClubsFromXMLTables = True
Exit Function
fout:
If (Err = 3021) Then Resume Next
DoCmd.SetWarnings True

MsgBox Err & " lenReadClubsFromXMLTables" & Error$, 16
Exit Function

End Function

Private Function lenLoadLXSplit(ByRef sp As Recordset, ByVal splitID As Long, ByRef afst As Long, ByRef tijd As Double) As Boolean
On Error GoTo fout
lenLoadLXSplit = False

afst = 0
tijd = 0

If splitID >= 0 Then
  sp.Seek "=", splitID
  If Not sp.NoMatch Then
    afst = CLng(val(Nz(sp("LEN_Distance"))))
    tijd = lenParseSwimtime(Nz(sp("LEN_Swimtime")))
  End If
End If


lenLoadLXSplit = True
Exit Function
fout:
MsgBox Err & " " & Error$, 16
Exit Function
End Function

Private Function lenAppendLXSplit(ByRef sp As Recordset, ByVal splitID As Long, ByVal afst As Integer, ByVal tijd As Double) As Boolean
On Error GoTo fout
lenAppendLXSplit = False

sp.AddNew
  sp("ID_Split") = splitID
  sp("LEN_Distance") = afst
  sp("LEN_Swimtime") = hzn(lenFormatSwimTime(tijd))
sp.Update

lenAppendLXSplit = True
Exit Function
fout:
MsgBox Err & " " & Error$, 16
Exit Function

End Function

Private Function lenTryExtractDisFromComment(ByVal comment As String) As String
On Error GoTo fout
lenTryExtractDisFromComment = ""

Dim fp As String
fp = extractToken(comment, " ")

If (Len(fp) = 2) Then
  lenTryExtractDisFromComment = fp
  Exit Function
ElseIf (Len(fp) = 3) Then
  If (Left(fp, 1) = ".") Then
    lenTryExtractDisFromComment = Right(fp, 2)
  End If
ElseIf (Len(fp) = 5) Then
  If (Mid(fp, 3, 1) = "/") Or (Mid(fp, 3, 1) = "+") Then
    lenTryExtractDisFromComment = fp
    Exit Function
  End If
ElseIf (Len(fp) = 6) Then
  If (Left(fp, 1) = ".") Then
    If (Mid(fp, 4, 1) = "/") Or (Mid(fp, 4, 1) = "+") Then
      lenTryExtractDisFromComment = Right(fp, 5)
      Exit Function
    End If
  End If
End If


Exit Function
fout:
MsgBox Err & " " & Error$, 16
Exit Function

End Function

Private Function lenReadTijdenFromRS(ByVal lxVersion As Long, ByRef skRnk As Recordset, ByRef skHeat As Recordset, ByRef td As Recordset, ByRef tdOutp As Recordset, ByRef spColl As Recordset, ByRef sp As Recordset, ByRef impProg As Recordset, ByRef impWed As Recordset, ByRef impPloegleden As Recordset, ByVal isEstaf As Boolean) As Boolean
On Error GoTo fout
lenReadTijdenFromRS = False

Dim curLenProgID As Long
curLenProgID = -1


td.MoveFirst
Do Until td.EOF

  Dim progFound As Boolean
  Dim af As String
  Dim sl As String
  Dim bn As Integer
  Dim progID As Long
  Dim wedID As Long
  
  Dim tsAf(0 To 3) As Long
  Dim extraTsAf(0 To MAX_N_TUSSENTIJDEN) As Integer
  Dim extraTsTd(0 To MAX_N_TUSSENTIJDEN) As Double
  Dim extraTsCnt As Integer
  extraTsCnt = 0


  Dim tpLenProgID As Long
  tpLenProgID = Nz(td("LEN_EVENTID"), 1)
  If (tpLenProgID <> curLenProgID) Then
  
    progFound = False
    impProg.Seek "=", tpLenProgID
    If (Not impProg.NoMatch) Then
      af = Nz(impProg("PR_Afstand"))
      sl = Nz(impProg("PR_Slag"))
      
      wedID = Nz(impProg("PR_WED_ID"), -1)
      impWed.Seek "=", wedID
      
      If Not impWed.NoMatch Then
        bn = Nz(impWed("WE_Baanlengte"))
        If Not tstLookupTussenAfstanden(af, sl, bn, tsAf) Then Exit Function
        progFound = True
      End If
    End If
    curLenProgID = tpLenProgID
  End If

  tdOutp.AddNew
  
  If (progFound) Then
    tdOutp("TY_PROG_ID") = impProg("PR_ID")
  End If
  
  
   
    tdOutp("TY_ID") = td("ID_RESULT")
    tdOutp("INT_PROG_LEN_ID") = td("LEN_EVENTID")
    tdOutp("TY_IsEstaf") = isEstaf
    If (isEstaf) Then
      tdOutp("TY_Zwemmer_ID") = Null
      tdOutp("TY_Ploeg_ID") = td("ID_RELAY")
    Else
      tdOutp("TY_Zwemmer_ID") = td("ID_ATHLETE")
      tdOutp("TY_Ploeg_ID") = Null
    End If
    
    tdOutp("TY_Serienummer") = Null
    tdOutp("TY_Baan") = Null
    
    

    
    If (lxVersion >= LX_VERSION_3) Then
      tdOutp("TY_Baan") = td("LEN_Lane")
      
      'lookup heat number
      Dim tpHtiPrLenID As Long
      Dim tpHtiHeatLenID As Long
      tpHtiPrLenID = Nz(td("LEN_EVENTID"))
      tpHtiHeatLenID = Nz(td("LEN_HeatID"))
      skHeat.Seek "=", tpHtiPrLenID, tpHtiHeatLenID
      If (Not skHeat.NoMatch) Then
        tdOutp("TY_serienummer") = skHeat("HTI_HT_Number")
      End If
      
    End If
    
    
    
    tdOutp("INT_Agegroup_LEN_ID") = td("LEN_AGEGROUPID")
    
    
    Dim eindtijd As Double
    eindtijd = lenParseSwimtime(Nz(td("LEN_SWIMTIME")))
    
    tdOutp("TY_Eindtijd") = eindtijd
    
    Dim dis As String
    dis = Nz(td("LEN_DSQCODE"))
    If (dis = "") Then
      dis = lenParseResultStatus(Nz(td("LEN_STATUS")))
    End If
    
    If dis = "DQ" Then
      Dim possDisCode As String
      possDisCode = lenTryExtractDisFromComment(Nz(td("LEN_COMMENT")))
      If (possDisCode <> "") Then
        dis = possDisCode
      Else
        tdOutp("TY_Opm") = td("LEN_COMMENT")
      End If
    Else
      tdOutp("TY_Opm") = td("LEN_COMMENT")
    End If
    
    If (Len(dis) > 10) Then
      dis = Left(dis, 10)
    End If
    
    tdOutp("TY_DIS") = hzn(dis)
    
    
    tdOutp("TY_AB") = hzn(Nz(td("LEN_TIMESUFFIX")))
    
    If (Nz(td("LEN_STATUS")) = LX_STATUS_EXH) Then
      tdOutp("TY_BM") = True
    ElseIf lenParseBoolean(Nz(td("LEN_NONCOMP"))) Then
      tdOutp("TY_BM") = True
    Else
      tdOutp("TY_BM") = False
    End If
    
    
    
    
    If (lxVersion < LX_VERSION_3) Then
      tdOutp("TY_Eindplaats") = CLng(val(Nz(td("LEN_PLACE"))))
    Else
      'Need to lookup place
      Dim tpRnkPrLenID As Long
      Dim tpRnkResLenID As Long
      tpRnkPrLenID = Nz(td("LEN_EVENTID"))
      tpRnkResLenID = Nz(td("LEN_ResultID"))
      skRnk.Seek "=", tpRnkPrLenID, tpRnkResLenID
      If (Not skRnk.NoMatch) Then
        tdOutp("TY_EindPlaats") = skRnk("RK_RES_Place")
      End If
    End If
    
    
    
    
    
    
      
        
        
    Dim startzwID As Long
    startzwID = -1
    Dim startZwPLLID As Long
    startZwPLLID = -1
    If (isEstaf) Then
      Dim plgID As Long
      plgID = td("ID_RELAY")
      
      Dim tdID As Long
      tdID = td("ID_RESULT")
      
      impPloegleden.FindFirst "[PLL_TIJD_ID] =" & tdID & " and [PLL_PLOEG_ID]= " & plgID & " and [PLL_VOLGORDE] = 1"
      If (Not impPloegleden.NoMatch) Then
        startzwID = Nz(impPloegleden("PLL_ZWEMMER_ID"), -1)
        startZwPLLID = Nz(impPloegleden("PLL_ID"), -1)
      End If
    End If
    
    If (startzwID <> -1) Then
      tdOutp("TY_Startzwemmer_ID") = startzwID
    Else
      tdOutp("TY_Startzwemmer_ID") = Null
    End If
    
    If (startZwPLLID <> -1) Then
      tdOutp("TY_Startzwemmer_PLL_ID") = startZwPLLID
    Else
      tdOutp("TY_Startzwemmer_PLL_ID") = Null
    End If
        
        
    Dim splitCollID As Long
    splitCollID = Nz(td("SYS_REF_SPLITS"), -1)
    
    'Nu tussentijden afhandelen.
    Dim done As Boolean
    If Not lenCollPrepareIt(spColl, splitCollID, "SPLIT", done) Then
      Exit Function
    End If
    
    Do Until done
      Dim splitID As Long
      If Not lenCollGetNextID(spColl, splitCollID, "SPLIT", splitID, done) Then
        Exit Function
      End If
      
      'load the split time.
      Dim spAf As Long, spTime As Double
      If Not lenLoadLXSplit(sp, splitID, spAf, spTime) Then
        Exit Function
      End If
      
      'check to see if this is a relevant tussentijd or just an extra one.
      If (spTime > 0.01 And Abs(spTime - eindtijd) > 0.01) Then
        Dim blFound As Boolean
        blFound = False
        Dim i As Integer
        For i = 0 To 3
          If spAf = tsAf(i) Then
            blFound = True
            'BINGO.
            'Now still need to determine tusSlag.
            Dim spSlag As String
            If (sl = "WISSEL") Then
              If (af Like "*x*") Then
                spSlag = "RUG"
              Else
                spSlag = "VLINDER"
              End If
            Else
              spSlag = sl
            End If
            
            tdOutp("TY_Afstand" & (i + 1)) = spAf
            tdOutp("TY_Slag" & (i + 1)) = spSlag
            tdOutp("TY_Tijd" & (i + 1)) = spTime
          End If
        Next i
        
        If (Not blFound) Then
          'Append as extra split time.
          If Not tstSetTussenTijd(spAf, spTime, extraTsCnt, extraTsAf, extraTsTd) Then
            Exit Function
          End If
        End If
        
        
      End If
      
      
    Loop
    
    Dim exTusStr As String
    
    exTusStr = tstReadTussentijdenArray(extraTsCnt, extraTsAf, extraTsTd)
    
    tdOutp("TY_ExtraTussentijden") = hzn(exTusStr)
        
    If (progFound) Then
      tdOutp("TY_Eindafstand") = hzn(af)
      tdOutp("TY_EIndslag") = hzn(sl)
    End If
        
      
    
    
  
  
  tdOutp.Update
  

  td.MoveNext
Loop


lenReadTijdenFromRS = True
Exit Function
fout:
If (Err = 3021) Then Resume Next
MsgBox Err & " " & Error$, 16

Exit Function

'debug
On Error GoTo 0
Resume

Exit Function
End Function


Private Function lenReadTijdenFromXMLTables_createTmpTable() As Boolean
On Error GoTo fout
lenReadTijdenFromXMLTables_createTmpTable = False

If Not lenReadTijdenFromXMLTables_cleanTmpTable() Then
  Exit Function
End If

Dim db As Database, tb As TableDef

Set db = CurrentDb()

Set tb = db.CreateTableDef("~len_read_tijden_rnk")

tb.Fields.Append tb.CreateField("RK_PR_LEN_ID", dbLong)
tb.Fields.Append tb.CreateField("RK_RES_LEN_ID", dbLong)
tb.Fields.Append tb.CreateField("RK_RES_Place", dbLong)

Dim idx As Index
Set idx = tb.CreateIndex("PrimaryKey")
idx.Fields.Append idx.CreateField("RK_PR_LEN_ID", dbLong)
idx.Fields.Append idx.CreateField("RK_RES_LEN_ID", dbLong)
tb.Indexes.Append idx

db.TableDefs.Append tb

Set idx = Nothing
Set tb = Nothing
Set db = Nothing

lenReadTijdenFromXMLTables_createTmpTable = True
Exit Function

fout:
MsgBox Err & " lenReadTijdenFromXMLTables_createTmpTable" & vbCrLf & Error$, 16
Exit Function
End Function
Private Function lenReadTijdenFromXMLTables_cleanTmpTable() As Boolean
On Error GoTo fout
lenReadTijdenFromXMLTables_cleanTmpTable = False

DoCmd.DeleteObject acTable, "~len_read_tijden_rnk"


lenReadTijdenFromXMLTables_cleanTmpTable = True
Exit Function

fout:
If (Err = 3011) Or (Err = 7874) Then Resume Next
MsgBox Err & " lenReadTijdenFromXMLTables_cleanTmpTable" & vbCrLf & Error$, 16
Exit Function
End Function


Private Function lenReadTijdenFromXMLTables_fillRnkTable() As Boolean
On Error GoTo fout
lenReadTijdenFromXMLTables_fillRnkTable = False

If Not lenReadTijdenFromXMLTables_createTmpTable() Then
  Exit Function
End If

Dim rsOut As Recordset
Set rsOut = CurrentDb().OpenRecordset("~len_read_tijden_rnk")
rsOut.Index = "PrimaryKey"


Dim sql As String
sql = "SELECT LEN_RANKING.LEN_place, LEN_RANKING.LEN_resultid, LEN_EVENT.LEN_eventid FROM (LEN_EVENT INNER JOIN " & _
"LEN_AGEGROUP_COLL ON LEN_EVENT.SYS_REF_AGEGROUPS = LEN_AGEGROUP_COLL.ID_AGEGROUP_COLL) " & _
"INNER JOIN ((LEN_AGEGROUP INNER JOIN LEN_RANKING_COLL ON LEN_AGEGROUP.SYS_REF_RANKINGS = " & _
"LEN_RANKING_COLL.ID_RANKING_COLL) INNER JOIN LEN_RANKING ON LEN_RANKING_COLL.SYS_REF_CH_RANKING = " & _
"LEN_RANKING.ID_RANKING) ON LEN_AGEGROUP_COLL.SYS_REF_CH_AGEGROUP = LEN_AGEGROUP.ID_AGEGROUP;"


Dim rs As Recordset
Set rs = CurrentDb().OpenRecordset(sql)

rs.MoveFirst
Do Until rs.EOF
  Dim tpPl As Long, tpResID As Long, tpEvID As Long
  
  tpEvID = Nz(rs("LEN_EventID"))
  tpResID = Nz(rs("LEN_ResultID"))
  tpPl = Nz(rs("LEN_Place"))
  
  'Only interested in one place per result; even though more are possible in the lenex file
  rsOut.Seek "=", tpEvID, tpResID
  If rsOut.NoMatch Then
    If (tpPl > 0) And (tpPl <= 10000) Then
      rsOut.AddNew
        rsOut("RK_PR_LEN_ID") = tpEvID
        rsOut("RK_RES_LEN_ID") = tpResID
        rsOut("RK_RES_Place") = tpPl
      rsOut.Update
    End If
  End If
  
  rs.MoveNext
Loop

appCleanRS rs
appCleanRS rsOut

lenReadTijdenFromXMLTables_fillRnkTable = True
Exit Function

fout:
If (Err = 3021) Then Resume Next
MsgBox Err & " lenReadTijdenFromXMLTables_fillRnkTable" & vbCrLf & Error$, 16
Exit Function
End Function



Private Function lenReadTijdenFromXMLTables(ByVal lxVersion As Long, ByRef skHeat As Recordset) As Boolean
On Error GoTo fout
lenReadTijdenFromXMLTables = False

Dim impWed As Recordset, impProg As Recordset, impPloegleden As Recordset

Set impWed = CurrentDb().OpenRecordset("gIMP_LEN_Wedstrijden")
impWed.Index = "PrimaryKey"

Set impProg = CurrentDb().OpenRecordset("gIMP_LEN_Programma")
impProg.Index = "LENPROGID" ' <- NOT A BUG, Q is LEN_PROG_ID index.

Set impPloegleden = CurrentDb().OpenRecordset("gIMP_LEN_Ploegleden", dbOpenDynaset)

Dim sp As Recordset, spColl As Recordset
Set sp = CurrentDb().OpenRecordset("LEN_SPLIT")
sp.Index = "P"
Set spColl = CurrentDb().OpenRecordset("select * from LEN_SPLIT_COLL order by [ID_SPLIT_COLL]", dbOpenDynaset)


Dim skRnk As Recordset
Set skRnk = Nothing
If (lxVersion >= LX_VERSION_3) Then
  If Not lenReadTijdenFromXMLTables_fillRnkTable() Then
    Exit Function
  End If
  Set skRnk = CurrentDb().OpenRecordset("~len_read_tijden_rnk")
  skRnk.Index = "PrimaryKey"
 
End If





Dim tdOutp As Recordset
Set tdOutp = CurrentDb().OpenRecordset("gIMP_LEN_TIJDEN")

Dim td As Recordset

Dim sql As String

sql = "SELECT LEN_RESULT.*, LEN_RELAY.ID_RELAY FROM ((LEN_RESULT INNER JOIN LEN_RESULT_COLL ON LEN_RESULT.ID_RESULT = " & _
"LEN_RESULT_COLL.SYS_REF_CH_RESULT) INNER JOIN LEN_RESULTS ON LEN_RESULT_COLL.ID_RESULT_COLL = LEN_RESULTS.SYS_REF_RESULT_COLL) " & _
"INNER JOIN LEN_RELAY ON LEN_RESULTS.ID_RESULTS = LEN_RELAY.SYS_REF_RESULTS order by LEN_EVENTID;"

Set td = CurrentDb().OpenRecordset(sql)

If Not lenReadTijdenFromRS(lxVersion, skRnk, skHeat, td, tdOutp, spColl, sp, impProg, impWed, impPloegleden, True) Then
  Exit Function
End If

appCleanRS td

sql = "SELECT LEN_RESULT.*, LEN_ATHLETE.ID_ATHLETE FROM ((LEN_RESULT INNER JOIN LEN_RESULT_COLL ON LEN_RESULT.ID_RESULT = " & _
"LEN_RESULT_COLL.SYS_REF_CH_RESULT) INNER JOIN LEN_RESULTS ON LEN_RESULT_COLL.ID_RESULT_COLL = LEN_RESULTS.SYS_REF_RESULT_COLL) " & _
"INNER JOIN LEN_ATHLETE ON LEN_RESULTS.ID_RESULTS = LEN_ATHLETE.SYS_REF_RESULTS order by LEN_EVENTID;"

Set td = CurrentDb().OpenRecordset(sql)

If Not lenReadTijdenFromRS(lxVersion, skRnk, skHeat, td, tdOutp, spColl, sp, impProg, impWed, impPloegleden, False) Then
  Exit Function
End If

appCleanRS td
appCleanRS skRnk
appCleanRS tdOutp
appCleanRS spColl
appCleanRS sp
appCleanRS impWed
appCleanRS impProg
appCleanRS impPloegleden


If Not lenReadTijdenFromXMLTables_cleanTmpTable() Then
  Exit Function
End If





'now have to update the following three fields.
'TY_VER_ID.
'TY_PROG_ID (ALREADY DONE)
'TY_AGEGROUP_ID


DoCmd.SetWarnings False

sql = "UPDATE gIMP_LEN_Tijden INNER JOIN gIMP_LEN_Zwemmers ON gIMP_LEN_Tijden.TY_Zwemmer_ID = gIMP_LEN_Zwemmers.ZW_ID SET gIMP_LEN_Tijden.TY_Ver_ID = [ZW_VER_ID];"
DoCmd.RunSQL sql

sql = "UPDATE gIMP_LEN_Tijden INNER JOIN gIMP_LEN_Ploeg ON gIMP_LEN_TIJDEN.TY_PLOEG_ID = gIMP_LEN_PLOEG.PL_ID SET gIMP_LEN_TIJDEN.TY_Ver_ID = [PL_VER_ID];"
DoCmd.RunSQL sql

sql = "UPDATE gIMP_LEN_TIJDEN INNER JOIN gIMP_LEN_Leeftijdsgroepen ON (gIMP_LEN_TIJDEN.INT_Agegroup_Len_ID = gIMP_LEN_Leeftijdsgroepen.INT_LEN_ID) AND (gIMP_LEN_TIJDEN.TY_PROG_ID = gIMP_LEN_Leeftijdsgroepen.LF_PR_ID) SET gIMP_LEN_TIJDEN.TY_Agegroup_ID = [LF_ID];"
DoCmd.RunSQL sql




DoCmd.SetWarnings True






lenReadTijdenFromXMLTables = True
Exit Function
fout:
If (Err = 3021) Then Resume Next

DoCmd.SetWarnings True
MsgBox Err & " " & Error$, 16
Exit Function

On Error GoTo 0
Resume


Exit Function
End Function

Private Function lenReadArchivedTimesFromRS(ByRef tma As Recordset, ByRef tmaOutp As Recordset, ByRef impWed As Recordset, ByRef skMtInfXIDConv As Recordset, ByRef mt As Recordset, ByRef swst As Recordset, ByVal isEstaf As Boolean) As Boolean
On Error GoTo fout
lenReadArchivedTimesFromRS = False


tma.MoveFirst
Do Until tma.EOF

    
  Dim blProcessTime As Boolean
  blProcessTime = True
  
  Dim sAf As String
  Dim sSl As String
    
    
  Dim lSwstXID As Long
  lSwstXID = Nz(tma("SYS_REF_SWIMSTYLE"), -1)
  
  
  
  If (lSwstXID < 0) Then
    blProcessTime = False
  Else
    Dim sDummy As String
    If Not lenLoadLXSwimStyle(swst, lSwstXID, sAf, sSl, sDummy) Then
      Exit Function
    End If
  End If
  
  
  Dim lWedID As Long
  lWedID = -1
  
  If blProcessTime Then
    Dim lMtInfXID As Long
    lMtInfXID = Nz(tma("SYS_REF_MEETINFO"), -1)
    If (lMtInfXID < 0) Then
      blProcessTime = False
    Else
    
      skMtInfXIDConv.Seek "=", lMtInfXID
      If skMtInfXIDConv.NoMatch Then
        Err.Raise 1, , "Internal error"
      End If
      
      lWedID = Nz(skMtInfXIDConv("CV_WED_ID"), -1)
      
      If (lWedID < 0) Then
        blProcessTime = False
      End If
    End If
  End If
  
  
  'Check to see if match has been added to gIMP_LEN_Wedstrijden table
  If (blProcessTime) Then
    impWed.Seek "=", lWedID
    
    If (impWed.NoMatch) Then
    
      Dim dDummy As Double
      Dim iWedBn As Integer, sWedPlaats As String, sWedNation As String, sWedDes As String, dWedDate As Date
      
      If Not lenLoadLXMeetInfo(mt, lMtInfXID, iWedBn, sWedPlaats, sWedNation, dWedDate, sWedDes, dDummy) Then
        Exit Function
      End If
      
      impWed.AddNew
        impWed("WE_ID") = lWedID
        If (lenDateIsValid(dWedDate)) Then
          impWed("WE_Datum") = dWedDate
        End If
        impWed("WE_Plaats") = hzn(sWedPlaats)
        impWed("WE_Beschrijving") = hzn(sWedDes)
        impWed("WE_Beschrijving_Extra") = hzn(sWedDes)
        impWed("WE_Baanlengte") = iWedBn
        impWed("WE_Nation") = hzn(sWedNation)
        
        impWed("WE_PartOfTimeArchive") = True
        
      impWed.Update
      
    
    End If
  End If
  
        
    
      
      
  If (blProcessTime) Then

  
    tmaOutp.AddNew
   
      tmaOutp("TD_ID") = tma("ID_ArchivedTime")
    
      tmaOutp("TD_IsEstaf") = isEstaf
    
      If (isEstaf) Then
        tmaOutp("TD_Zwemmer_ID") = Null
        tmaOutp("TD_Ploeg_ID") = tma("ID_RELAY")
      Else
        tmaOutp("TD_Zwemmer_ID") = tma("ID_ATHLETE")
        tmaOutp("TD_Ploeg_ID") = Null
      End If
    
      
    
      Dim swt As Double
      swt = lenParseSwimtime(Nz(tma("LEN_SWIMTIME")))
    
      tmaOutp("TD_tijd") = swt
      
      tmaOutp("TD_Afstand") = hzn(sAf)
      tmaOutp("TD_Slag") = hzn(sSl)
    
      Dim dis As String
      dis = Nz(tma("LEN_DSQCODE"))
                
      If (Len(dis) > 10) Then
        dis = lenParseResultStatus(dis)
        If (Len(dis) > 10) Then
          dis = Right(dis, 10)
        End If
      End If
      
      tmaOutp("TD_DIS") = hzn(dis)
    
      tmaOutp("TD_Opm") = hzn(Nz(tma("LEN_Comment")))
      
      tmaOutp("TD_IsTusTijd") = lenParseBoolean(Nz(tma("LEN_IsSplitTime")))
    
    
    
      tmaOutp("TD_WED_ID") = lWedID
    
    tmaOutp.Update
    
  End If 'if blProcessTime
  

  tma.MoveNext
Loop


lenReadArchivedTimesFromRS = True
Exit Function
fout:
If (Err = 3021) Then Resume Next
MsgBox Err & " lenReadArchivedTimesFromRS" & Error$, 16

Exit Function

'debug
On Error GoTo 0
Resume

Exit Function
End Function



Private Function lenReadArchivedTimesFromXMLTables_createTmpTable() As Boolean
On Error GoTo fout
lenReadArchivedTimesFromXMLTables_createTmpTable = False

If Not lenReadArchivedTimesFromXMLTables_cleanTmpTable() Then
  Exit Function
End If

Dim db As Database, tb As TableDef

Set db = CurrentDb()

Set tb = db.CreateTableDef("~len_read_archivedtimes_xid_conv")

tb.Fields.Append tb.CreateField("CV_MTINF_XID", dbLong)
tb.Fields.Append tb.CreateField("CV_WED_ID", dbLong)

Dim idx As Index
Set idx = tb.CreateIndex("PrimaryKey")
idx.Fields.Append idx.CreateField("CV_MTINF_XID", dbLong)
tb.Indexes.Append idx

db.TableDefs.Append tb

Set idx = Nothing
Set tb = Nothing
Set db = Nothing

lenReadArchivedTimesFromXMLTables_createTmpTable = True
Exit Function

fout:
MsgBox Err & " lenReadArchivedTimesFromXMLTables_createTmpTable" & vbCrLf & Error$, 16
Exit Function
End Function
Private Function lenReadArchivedTimesFromXMLTables_cleanTmpTable() As Boolean
On Error GoTo fout
lenReadArchivedTimesFromXMLTables_cleanTmpTable = False

DoCmd.DeleteObject acTable, "~len_read_archivedtimes_xid_conv"


lenReadArchivedTimesFromXMLTables_cleanTmpTable = True
Exit Function

fout:
If (Err = 3011) Or (Err = 7874) Then Resume Next
MsgBox Err & " lenReadArchivedTimesFromXMLTables_cleanTmpTable" & vbCrLf & Error$, 16
Exit Function
End Function


Private Function lenReadArchivedTimesFromXMLTables_fillConvTable(ByRef muWedID As Long) As Boolean
On Error GoTo fout
lenReadArchivedTimesFromXMLTables_fillConvTable = False

If Not lenReadArchivedTimesFromXMLTables_createTmpTable() Then
  Exit Function
End If

Dim rsOut As Recordset
Set rsOut = CurrentDb().OpenRecordset("~len_read_archivedtimes_xid_conv")
rsOut.Index = "PrimaryKey"


Dim rsMtInf As Recordset
Dim sql As String
sql = " SELECT LEN_MEETINFO.* FROM LEN_MEETINFO INNER JOIN LEN_ARCHIVEDTIME ON LEN_MEETINFO.ID_MEETINFO = LEN_ARCHIVEDTIME.SYS_REF_MEETINFO " & _
      "ORDER BY LEN_MEETINFO.LEN_date, LEN_MEETINFO.LEN_course, LEN_MEETINFO.LEN_city, LEN_MEETINFO.LEN_name, LEN_MEETINFO.LEN_nation;"

Set rsMtInf = CurrentDb().OpenRecordset(sql)

Dim curDateS As String, curCourseS As String, curCityS As String, curNameS As String, curNationS As String
Dim curWedID As Long

curDateS = ""
curCourseS = ""
curCityS = ""
curNameS = ""
curNationS = ""
curWedID = -1

rsMtInf.MoveFirst
Do Until rsMtInf.EOF
  Dim tpDateS As String, tpCourseS As String, tpCityS As String, tpNameS As String, tpNationS As String
  tpDateS = Nz(rsMtInf("LEN_Date"))
  tpCourseS = Nz(rsMtInf("LEN_Course"))
  tpCityS = Nz(rsMtInf("LEN_City"))
  tpNameS = Nz(rsMtInf("LEN_Name"))
  tpNationS = Nz(rsMtInf("LEN_Nation"))
  
  
  
  If (tpDateS <> curDateS) Or (tpCourseS <> curCourseS) Or (tpCityS <> curCityS) Or (tpNameS <> curNameS) Or (tpNationS <> curNationS) Then
    'new match encountered.
    curDateS = tpDateS
    curCourseS = tpCourseS
    curCityS = tpCityS
    curNameS = tpNameS
    curNationS = tpNationS
    
    curWedID = muWedID + 1
    muWedID = curWedID
    
  End If
  
  
  rsOut.AddNew
    rsOut("CV_MTINF_XID") = rsMtInf("ID_MEETINFO")
    rsOut("CV_WED_ID") = curWedID
  rsOut.Update
    
  
  rsMtInf.MoveNext
Loop

appCleanRS rsOut
appCleanRS rsMtInf




lenReadArchivedTimesFromXMLTables_fillConvTable = True
Exit Function

fout:
If (Err = 3021) Then Resume Next
MsgBox Err & " lenReadArchivedTimesFromXMLTables_fillConvTable" & vbCrLf & Error$, 16
Exit Function
End Function



Private Function lenReadArchivedTimesFromXMLTables(ByRef muWedID As Long) As Boolean
On Error GoTo fout
lenReadArchivedTimesFromXMLTables = False

Dim impWed As Recordset, impPloegleden As Recordset

Set impWed = CurrentDb().OpenRecordset("gIMP_LEN_Wedstrijden")
impWed.Index = "PrimaryKey"

Dim swst As Recordset
Set swst = CurrentDb().OpenRecordset("LEN_SWIMSTYLE")
swst.Index = "P"

Dim mtInf As Recordset
Set mtInf = CurrentDb().OpenRecordset("LEN_MEETINFO")
mtInf.Index = "P"


Dim tmaOutp As Recordset
Set tmaOutp = CurrentDb().OpenRecordset("gIMP_LEN_ArchiefTijden")



Dim skMtXIDConv As Recordset


If Not lenReadArchivedTimesFromXMLTables_fillConvTable(muWedID) Then
  Exit Function
End If
Set skMtXIDConv = CurrentDb().OpenRecordset("~len_read_archivedtimes_xid_conv")
skMtXIDConv.Index = "PrimaryKey"
 
 
Dim tma As Recordset

Dim sql As String

sql = "SELECT LEN_ARCHIVEDTIME.*, LEN_RELAY.ID_RELAY FROM ((LEN_ARCHIVEDTIME INNER JOIN LEN_ARCHIVEDTIME_COLL ON LEN_ARCHIVEDTIME.ID_ARCHIVEDTIME = " & _
"LEN_ARCHIVEDTIME_COLL.SYS_REF_CH_ARCHIVEDTIME) INNER JOIN LEN_ARCHIVEDTIMES ON LEN_ARCHIVEDTIME_COLL.ID_ARCHIVEDTIME_COLL = LEN_ARCHIVEDTIMES.SYS_REF_ARCHIVEDTIME_COLL) " & _
"INNER JOIN LEN_RELAY ON LEN_ARCHIVEDTIMES.ID_ARCHIVEDTIMES = LEN_RELAY.SYS_REF_ARCHIVEDTIMES; "

Set tma = CurrentDb().OpenRecordset(sql)

If Not lenReadArchivedTimesFromRS(tma, tmaOutp, impWed, skMtXIDConv, mtInf, swst, True) Then
  Exit Function
End If

appCleanRS tma

sql = "SELECT LEN_ARCHIVEDTIME.*, LEN_ATHLETE.ID_ATHLETE FROM ((LEN_ARCHIVEDTIME INNER JOIN LEN_ARCHIVEDTIME_COLL ON LEN_ARCHIVEDTIME.ID_ARCHIVEDTIME = " & _
"LEN_ARCHIVEDTIME_COLL.SYS_REF_CH_ARCHIVEDTIME) INNER JOIN LEN_ARCHIVEDTIMES ON LEN_ARCHIVEDTIME_COLL.ID_ARCHIVEDTIME_COLL = LEN_ARCHIVEDTIMES.SYS_REF_ARCHIVEDTIME_COLL) " & _
"INNER JOIN LEN_ATHLETE ON LEN_ARCHIVEDTIMES.ID_ARCHIVEDTIMES = LEN_ATHLETE.SYS_REF_ARCHIVEDTIMES ;"

Set tma = CurrentDb().OpenRecordset(sql)

If Not lenReadArchivedTimesFromRS(tma, tmaOutp, impWed, skMtXIDConv, mtInf, swst, False) Then
  Exit Function
End If

appCleanRS tma


appCleanRS skMtXIDConv
appCleanRS tmaOutp
appCleanRS swst
appCleanRS mtInf
appCleanRS impWed


If Not lenReadArchivedTimesFromXMLTables_cleanTmpTable() Then
  Exit Function
End If





'now have to update the following field:
'TD_VER_ID.



DoCmd.SetWarnings False

sql = "UPDATE gIMP_LEN_ArchiefTijden INNER JOIN gIMP_LEN_Zwemmers ON gIMP_LEN_ArchiefTijden.TD_Zwemmer_ID = gIMP_LEN_Zwemmers.ZW_ID SET gIMP_LEN_ArchiefTijden.TD_Ver_ID = [ZW_VER_ID];"
DoCmd.RunSQL sql

sql = "UPDATE gIMP_LEN_ArchiefTijden INNER JOIN gIMP_LEN_Ploeg ON gIMP_LEN_ArchiefTIJDEN.TD_PLOEG_ID = gIMP_LEN_PLOEG.PL_ID SET gIMP_LEN_ArchiefTIJDEN.TD_Ver_ID = [PL_VER_ID];"
DoCmd.RunSQL sql






DoCmd.SetWarnings True






lenReadArchivedTimesFromXMLTables = True
Exit Function
fout:
If (Err = 3021) Then Resume Next

DoCmd.SetWarnings True
MsgBox Err & " " & Error$, 16
Exit Function

On Error GoTo 0
Resume


Exit Function
End Function



Public Function lenCleanTransferTables() As Boolean
On Error GoTo fout
lenCleanTransferTables = False


DoCmd.SetWarnings False

DoCmd.RunSQL "delete * from gIMP_LEN_CONTACT;"
DoCmd.RunSQL "delete * from gIMP_LEN_Ver;"
DoCmd.RunSQL "Delete * from gIMP_LEN_Programma;"
DoCmd.RunSQL "Delete * from gIMP_LEN_Leeftijdsgroepen;"
DoCmd.RunSQL "Delete * from gIMP_LEN_wedstrijden;"
DoCmd.RunSQL "Delete * from gIMP_LEN_zwemmers;"
DoCmd.RunSQL "Delete * from gIMP_LEN_ploeg;"
DoCmd.RunSQL "delete * from gIMP_LEN_ploegleden;"
DoCmd.RunSQL "Delete * from gIMP_LEN_deelnemers;"
DoCmd.RunSQL "delete * from gIMP_LEN_tijden;"
DoCmd.RunSQL "Delete * from gIMP_LEN_limieten;"
DoCmd.RunSQL "delete * from gIMP_LEN_records;"
DoCmd.RunSQL "delete * from gIMP_LEN_Officials;"
DoCmd.RunSQL "delete * from gIMP_LEN_ArchiefTijden;"


DoCmd.SetWarnings True




lenCleanTransferTables = True
Exit Function
fout:
MsgBox Err & " " & Error$, 16
DoCmd.SetWarnings True
Exit Function
End Function


Private Function lenPrepareReadFromXMLTables() As Boolean
On Error GoTo fout
lenPrepareReadFromXMLTables = False

If Not lenCleanTransferTables() Then Exit Function


lenPrepareReadFromXMLTables = True
Exit Function
fout:
DoCmd.SetWarnings True
MsgBox Err & " " & Error$, 16

Exit Function

'debug
On Error GoTo 0
Resume
Exit Function
End Function

Private Function lenLoadLXMeetInfo(ByRef mt As Recordset, ByVal meetInfID As Long, ByRef baan As Integer, ByRef Plaats As String, ByRef nation As String, ByRef datum As Date, ByRef sWedName As String, ByRef qlfTime As Double) As Boolean
On Error GoTo fout
lenLoadLXMeetInfo = False

datum = #1/1/1900#
baan = 25
Plaats = ""
qlfTime = 0
nation = ""

If (meetInfID >= 0) Then
  mt.Seek "=", meetInfID
  If Not mt.NoMatch Then
    baan = lenParseCourse(Nz(mt("LEN_COURSE")))
    Plaats = Nz(mt("LEN_CITY"))
    datum = lenParseDate(Nz(mt("LEN_DATE")))
    nation = Nz(mt("LEN_NATION"))
    qlfTime = lenParseSwimtime(Nz(mt("LEN_QUALIFICATIONTIME")))
    sWedName = Nz(mt("LEN_Name"))
  End If
End If


lenLoadLXMeetInfo = True
Exit Function
fout:
MsgBox Err & " " & Error$, 16
Exit Function
End Function

Private Function lenAppendLXMeetInfo(ByRef mt As Recordset, ByVal meetInfID As Long, ByVal baan As Integer, ByVal Plaats As String, ByVal nation As String, ByVal datum As Date, ByVal sWedName As String, ByVal qlfTime As Double) As Boolean
On Error GoTo fout
lenAppendLXMeetInfo = False

mt.AddNew
  mt("ID_Meetinfo") = meetInfID
  mt("LEN_CITY") = hzn(Plaats)
  mt("LEN_COURSE") = lenFormatBaanlengte(baan)
  If (lenDateIsValid(datum)) Then
    mt("LEN_DATE") = hzn(lenFormatDate(datum))
  Else
    mt("LEN_DATE") = hzn(lenFormatDate(#1/1/1900#))
  End If
  mt("LEN_NATION") = hzn(nation)
  If (qlfTime > 0.01) Then
    mt("LEN_QUALIFICATIONTIME") = hzn(lenFormatSwimTime(qlfTime))
  End If
  mt("LEN_Name") = hzn(sWedName)
mt.Update


lenAppendLXMeetInfo = True
Exit Function
fout:
MsgBox Err & " " & Error$, 16
Exit Function
End Function



Private Function lenReadDeelnemersFromRS(lxVersion As Long, ByRef skHeat As Recordset, ByRef dln As Recordset, ByRef dlnOutp As Recordset, ByRef mtInf As Recordset, ByVal isEstaf As Boolean) As Boolean
On Error GoTo fout
lenReadDeelnemersFromRS = False

dln.MoveFirst

'later: DE_VER_ID.
'DE_PROG_ID
'DE_AGEGROUP_ID

'DE_serienummer (lenex 3.0)

Do Until dln.EOF
  dlnOutp.AddNew
  dlnOutp("DE_ID") = dln("ID_ENTRY")
  dlnOutp("INT_PROG_LEN_ID") = dln("LEN_EVENTID")
  'dlnOutp("DE_VER_ID") = dln("ID_CLUB")
  dlnOutp("DE_IsEstaf") = isEstaf
  If (isEstaf) Then
    dlnOutp("DE_Zwemmer_ID") = Null
    dlnOutp("DE_Ploeg_ID") = dln("ID_RELAY")
  Else
    dlnOutp("DE_Zwemmer_ID") = dln("ID_ATHLETE")
    dlnOutp("DE_PLOEG_ID") = Null
  End If
  
  dlnOutp("DE_Inschrijftijd") = lenParseSwimtime(Nz(dln("LEN_ENTRYTIME")))
  
  Dim meetInfID As Long
  meetInfID = Nz(dln("SYS_REF_MEETINFO"), -1)
  
  Dim qlfBn As Integer, qlfTime As Double, qlfPlaats As String, qlfLand As String, qlfDate As Date, qlfWedName As String
  If Not (lenLoadLXMeetInfo(mtInf, meetInfID, qlfBn, qlfPlaats, qlfLand, qlfDate, qlfWedName, qlfTime)) Then
    Exit Function
  End If
  
  If (qlfTime > 0.01) Then
    dlnOutp("DE_QLF_TIJD") = qlfTime
  Else
    dlnOutp("DE_QLF_TIJD") = Null
  End If
  
  dlnOutp("DE_QLF_BAAN") = qlfBn
  dlnOutp("DE_QLF_Plaats") = hzn(qlfPlaats)
  dlnOutp("DE_QLF_LAND") = hzn(qlfLand)
  dlnOutp("DE_QLF_WedDescription") = hzn(qlfWedName)
  If (lenDateIsValid(qlfDate)) Then
    dlnOutp("DE_QLF_Datum") = qlfDate
  End If
  
  
    
  If (lxVersion < LX_VERSION_3) Then
    dlnOutp("DE_Serienummer") = CInt(val(Nz(dln("LEN_HEAT"))))
  Else
    'lookup heat number
    Dim tpHtiPrLenID As Long
    Dim tpHtiHeatLenID As Long
    tpHtiPrLenID = Nz(dln("LEN_EVENTID"))
    tpHtiHeatLenID = Nz(dln("LEN_HeatID"))
    skHeat.Seek "=", tpHtiPrLenID, tpHtiHeatLenID
    If (Not skHeat.NoMatch) Then
      dlnOutp("DE_serienummer") = skHeat("HTI_HT_Number")
    End If
  End If
  dlnOutp("DE_Baan") = CInt(val(Nz(dln("LEN_LANE"))))
  dlnOutp("INT_Agegroup_LEN_ID") = CLng(val(Nz(dln("LEN_AGEGROUPID"))))
  
  Dim blRes As Boolean
  Dim abcCode As String
  Dim blBM As Boolean
  
  blRes = lenParseBoolean(Nz(dln("LEN_RESERVE")))
  blBM = lenParseBoolean(Nz(dln("LEN_NONCOMP")))
  abcCode = Left(Nz(dln("LEN_GRPCODE")), 1)
  
  If Not blBM Then
    If Nz(dln("LEN_STATUS")) = LX_STATUS_EXH Then
      blBM = True
    End If
  End If
  
  dlnOutp("DE_Reserve") = blRes
  dlnOutp("DE_BM") = blBM
  dlnOutp("DE_ABC") = hzn(abcCode)
  
  
  
  Dim tpCapkleur As String, tpCapNr As Long, tpEigenCapS As String
  tpCapkleur = Nz(dln("LEN_Capcolor"))
  tpCapNr = Nz(dln("LEN_Capnumber"), -1)
  tpEigenCapS = Nz(dln("LEN_OwnCap"))
  
  If (tpCapkleur <> "") And (tpCapNr <> -1) Then
    dlnOutp("DE_OW_Capkleur") = hzn(tpCapkleur)
    dlnOutp("DE_OW_Capnummer") = tpCapNr
    If (tpEigenCapS = "") Then
      dlnOutp("DE_OW_Eigencap") = True
    Else
      dlnOutp("DE_OW_Eigencap") = lenParseBoolean(tpEigenCapS)
    End If
  End If
  
  
  
  
  
  dlnOutp.Update
  
  
  
  
  
  

  dln.MoveNext
Loop


lenReadDeelnemersFromRS = True
Exit Function
fout:
If (Err = 3021) Then Resume Next
MsgBox Err & " " & Error$, 16

Exit Function

'debug
On Error GoTo 0
Resume


End Function




Private Function lenReadHeatsFromXMLTables_createTmpTable() As Boolean
On Error GoTo fout
lenReadHeatsFromXMLTables_createTmpTable = False

If Not lenReadHeatsFromXMLTables_cleanTmpTable() Then
  Exit Function
End If

Dim db As Database, tb As TableDef

Set db = CurrentDb()

Set tb = db.CreateTableDef("~len_read_heats_id")

tb.Fields.Append tb.CreateField("HTI_PR_LEN_ID", dbLong)
tb.Fields.Append tb.CreateField("HTI_HT_LEN_ID", dbLong)
tb.Fields.Append tb.CreateField("HTI_HT_Number", dbLong)

Dim idx As Index
Set idx = tb.CreateIndex("PrimaryKey")
idx.Fields.Append idx.CreateField("HTI_PR_LEN_ID", dbLong)
idx.Fields.Append idx.CreateField("HTI_HT_LEN_ID", dbLong)
tb.Indexes.Append idx

db.TableDefs.Append tb

Set idx = Nothing
Set tb = Nothing
Set db = Nothing

lenReadHeatsFromXMLTables_createTmpTable = True
Exit Function

fout:
MsgBox Err & " lenReadHeatsFromXMLTables_createTmpTable" & vbCrLf & Error$, 16
Exit Function
End Function
Private Function lenReadHeatsFromXMLTables_cleanTmpTable() As Boolean
On Error GoTo fout
lenReadHeatsFromXMLTables_cleanTmpTable = False

DoCmd.DeleteObject acTable, "~len_read_heats_id"


lenReadHeatsFromXMLTables_cleanTmpTable = True
Exit Function

fout:
If (Err = 3011) Or (Err = 7874) Then Resume Next
MsgBox Err & " lenReadHeatsFromXMLTables_cleanTmpTable" & vbCrLf & Error$, 16
Exit Function
End Function


Private Function lenReadHeatsFromXMLTables_fillIDTable() As Boolean
On Error GoTo fout
lenReadHeatsFromXMLTables_fillIDTable = False

If Not lenReadHeatsFromXMLTables_createTmpTable() Then
  Exit Function
End If

Dim rsOut As Recordset
Set rsOut = CurrentDb().OpenRecordset("~len_read_heats_id")
rsOut.Index = "PrimaryKey"


Dim sql As String
sql = "SELECT LEN_EVENT.LEN_eventid, LEN_HEAT.LEN_heatid, LEN_HEAT.LEN_number " & _
  "FROM LEN_EVENT INNER JOIN ((LEN_HEAT INNER JOIN LEN_HEAT_COLL ON LEN_HEAT.ID_HEAT = LEN_HEAT_COLL.SYS_REF_CH_HEAT) " & _
  "INNER JOIN LEN_HEATS ON LEN_HEAT_COLL.ID_HEAT_COLL = LEN_HEATS.SYS_REF_HEAT_COLL) " & _
  "ON LEN_EVENT.SYS_REF_HEATS = LEN_HEATS.ID_HEATS;"



Dim rs As Recordset
Set rs = CurrentDb().OpenRecordset(sql)

rs.MoveFirst
Do Until rs.EOF
  Dim tpNr As Long, tpHeatID As Long, tpEvID As Long
  
  tpEvID = Nz(rs("LEN_EventID"))
  tpHeatID = Nz(rs("LEN_HeatID"))
  tpNr = Nz(rs("LEN_Number"))
  
  'Only interested in one number per heat;
  rsOut.Seek "=", tpEvID, tpHeatID
  If rsOut.NoMatch Then
    If (tpNr > 0) And (tpNr <= 10000) Then
      rsOut.AddNew
        rsOut("HTI_PR_LEN_ID") = tpEvID
        rsOut("HTI_HT_LEN_ID") = tpHeatID
        rsOut("HTI_HT_Number") = tpNr
      rsOut.Update
    End If
  End If
  
  rs.MoveNext
Loop

appCleanRS rs
appCleanRS rsOut

lenReadHeatsFromXMLTables_fillIDTable = True
Exit Function

fout:
If (Err = 3021) Then Resume Next
MsgBox Err & " lenReadHeatnFromXMLTables_fillIDTable" & vbCrLf & Error$, 16
Exit Function
End Function










Private Function lenReadDeelnemersFromXMLTables(ByVal lxVersion As Long, ByRef skHeat As Recordset) As Boolean
On Error GoTo fout
lenReadDeelnemersFromXMLTables = False

Dim sql As String
Dim dln As Recordset

Dim dlnOutp As Recordset
Set dlnOutp = CurrentDb().OpenRecordset("gIMP_LEN_Deelnemers")

Dim mtInf As Recordset
Set mtInf = CurrentDb().OpenRecordset("LEN_MEETINFO")
mtInf.Index = "P"


sql = "SELECT LEN_ENTRY.*, LEN_ATHLETE.ID_ATHLETE FROM ((LEN_ENTRY INNER JOIN LEN_ENTRY_COLL ON LEN_ENTRY.ID_ENTRY = " & _
"LEN_ENTRY_COLL.SYS_REF_CH_ENTRY) INNER JOIN LEN_ENTRIES ON LEN_ENTRY_COLL.ID_ENTRY_COLL = LEN_ENTRIES.SYS_REF_ENTRY_COLL) " & _
"INNER JOIN LEN_ATHLETE ON LEN_ENTRIES.ID_ENTRIES = LEN_ATHLETE.SYS_REF_ENTRIES;"

Set dln = CurrentDb().OpenRecordset(sql)
If Not (lenReadDeelnemersFromRS(lxVersion, skHeat, dln, dlnOutp, mtInf, False)) Then
  Exit Function
End If

appCleanRS dln


sql = "SELECT LEN_ENTRY.*, LEN_RELAY.ID_RELAY FROM ((LEN_ENTRY INNER JOIN LEN_ENTRY_COLL ON LEN_ENTRY.ID_ENTRY = " & _
"LEN_ENTRY_COLL.SYS_REF_CH_ENTRY) INNER JOIN LEN_ENTRIES ON LEN_ENTRY_COLL.ID_ENTRY_COLL = LEN_ENTRIES.SYS_REF_ENTRY_COLL) " & _
"INNER JOIN LEN_RELAY ON LEN_ENTRIES.ID_ENTRIES = LEN_RELAY.SYS_REF_ENTRIES;"

Set dln = CurrentDb().OpenRecordset(sql)
If Not (lenReadDeelnemersFromRS(lxVersion, skHeat, dln, dlnOutp, mtInf, True)) Then
  Exit Function
End If

appCleanRS dln

appCleanRS dlnOutp
appCleanRS mtInf

'now have to update the following three fields.
'DE_VER_ID.
'DE_PROG_ID
'DE_AGEGROUP_ID


DoCmd.SetWarnings False

sql = "UPDATE gIMP_LEN_Deelnemers INNER JOIN gIMP_LEN_Zwemmers ON gIMP_LEN_Deelnemers.DE_Zwemmer_ID = gIMP_LEN_Zwemmers.ZW_ID SET gIMP_LEN_Deelnemers.DE_Ver_ID = [ZW_VER_ID];"
DoCmd.RunSQL sql

sql = "UPDATE gIMP_LEN_Deelnemers INNER JOIN gIMP_LEN_Ploeg ON gIMP_LEN_Deelnemers.DE_PLOEG_ID = gIMP_LEN_PLOEG.PL_ID SET gIMP_LEN_Deelnemers.DE_Ver_ID = [PL_VER_ID];"
DoCmd.RunSQL sql

sql = "UPDATE gIMP_LEN_Deelnemers INNER JOIN gIMP_LEN_Programma ON gIMP_LEN_Deelnemers.INT_PROG_LEN_ID = gIMP_LEN_Programma.INT_LEN_ID SET gIMP_LEN_Deelnemers.DE_PROG_ID = [PR_ID];"
DoCmd.RunSQL sql

sql = "UPDATE gIMP_LEN_Deelnemers INNER JOIN gIMP_LEN_Leeftijdsgroepen ON (gIMP_LEN_Deelnemers.INT_Agegroup_Len_ID = gIMP_LEN_Leeftijdsgroepen.INT_LEN_ID) AND (gIMP_LEN_Deelnemers.DE_PROG_ID = gIMP_LEN_Leeftijdsgroepen.LF_PR_ID) SET gIMP_LEN_Deelnemers.DE_Agegroup_ID = [LF_ID];"
DoCmd.RunSQL sql






DoCmd.SetWarnings True



lenReadDeelnemersFromXMLTables = True
Exit Function
fout:
If (Err = 3021) Then Resume Next
MsgBox Err & " " & Error$, 16

Exit Function

'debug
On Error GoTo 0
Resume

Exit Function

End Function




Private Function lenReadLimietenFromXMLTables(ByVal lxVersion As Long, ByVal wedAgeDate As Date, ByVal lftBep As String) As Boolean
On Error GoTo fout
lenReadLimietenFromXMLTables = False

Dim sql As String
sql = "SELECT LEN_TIMESTANDARD.*, LEN_TIMESTANDARDLIST.LEN_COURSE, LEN_TIMESTANDARDLIST.SYS_REF_AGEGROUP, " & _
      "LEN_TIMESTANDARDLIST.LEN_GENDER, LEN_TIMESTANDARDLIST.LEN_NAME, LEN_TIMESTANDARDLIST.LEN_QUALIFYFROM, " & _
      "LEN_TIMESTANDARDLIST.LEN_QUALIFYUNTIL, LEN_TIMESTANDARDLIST.LEN_TYPE, LEN_TIMESTANDARDLIST.LEN_CODE, LEN_TIMESTANDARDLIST.LEN_TIMESTANDARDLISTID " & _
      "FROM ((LEN_TIMESTANDARD INNER JOIN LEN_TIMESTANDARD_COLL ON LEN_TIMESTANDARD.ID_TIMESTANDARD = LEN_TIMESTANDARD_COLL.SYS_REF_CH_TIMESTANDARD) " & _
      "INNER JOIN LEN_TIMESTANDARDS ON LEN_TIMESTANDARD_COLL.ID_TIMESTANDARD_COLL = LEN_TIMESTANDARDS.SYS_REF_TIMESTANDARD_COLL) " & _
      "INNER JOIN LEN_TIMESTANDARDLIST ON LEN_TIMESTANDARDS.ID_TIMESTANDARDS = LEN_TIMESTANDARDLIST.SYS_REF_TIMESTANDARDS;"
      
Dim LM As Recordset
Set LM = CurrentDb().OpenRecordset(sql)

Dim lmOutp As Recordset
Set lmOutp = CurrentDb().OpenRecordset("gIMP_LEN_LIMIETEN")

Dim ag As Recordset
Set ag = CurrentDb().OpenRecordset("LEN_AGEGROUP")
ag.Index = "P"

Dim sw As Recordset
Set sw = CurrentDb().OpenRecordset("LEN_SWIMSTYLE")
sw.Index = "P"



LM.MoveFirst
Do Until LM.EOF

   lmOutp.AddNew


   Dim agID As Long
   agID = Nz(LM("SYS_REF_AGEGROUP"), -1)
   
   Dim agLenID As Long
   Dim catInf As CAT_INFO
   
   Dim limGender As String
   limGender = Nz(LM("LEN_GENDER"))
   
   Dim limListID As Long
   limListID = Nz(LM("LEN_TIMESTANDARDLISTID"), -1)
   
   Dim lDummy(0 To 0) As Long
   If Not (lenLoadLXAgeGroup(lxVersion, ag, Nothing, Nothing, False, Nothing, False, Nothing, "", "", 0, "", agID, agLenID, wedAgeDate, lftBep, limGender, catInf, _
     False, 0, lDummy)) Then
     Exit Function
   End If
   
   Dim swID As Long
   swID = Nz(LM("SYS_REF_SWIMSTYLE"))
   
   Dim Afstand As String, slag As String, besAfw As String
   
   
   If (Not lenLoadLXSwimStyle(sw, swID, Afstand, slag, besAfw)) Then
     Exit Function
   End If
   
   Dim cat As String
   cat = Trim(catInf.cat)
   cat = lenApplyGeslacht(cat, lenParseGender(limGender))
   
   lmOutp("LIM_ID") = LM("ID_TIMESTANDARD")
   
   Dim isVVT As Boolean, isMinLim As Boolean, isMaxLim As Boolean, isLevel As Boolean
   lenParseLimitType Nz(LM("LEN_TYPE")), isVVT, isMinLim, isMaxLim, isLevel
   
   If (Nz(LM("LEN_Code")) <> "") Then
     If Len(Nz(LM("LEN_Code"))) <= 2 Then
       isLevel = True
      End If
   End If
   
   'Specially handle level limits.
   If (isLevel) Then
     isMaxLim = True
     lmOutp("LIM_Name") = LM("LEN_CODE")
   Else
     lmOutp("LIM_Name") = LM("LEN_Name")
   End If
   
   lmOutp("LIM_IsVVT") = isVVT
   lmOutp("Lim_IsMinLim") = isMinLim
   lmOutp("LIM_IsMaxLim") = isMaxLim
   lmOutp("LIM_Baan") = lenParseCourse(Nz(LM("LEN_COURSE")))
   lmOutp("LIM_Categorie") = hzn(cat)
   
   lmOutp("INT_Max_Age") = catGetMaxAllowedAge_bare(cat, wedAgeDate, lftBep)
   lmOutp("INT_Geslacht") = hzn(m_of_v(cat))
   
   lmOutp("LIM_TIJD") = lenParseSwimtime(Nz(LM("LEN_Swimtime")))
   lmOutp("LIM_Afstand") = hzn(Afstand)
   lmOutp("LIM_Slag") = hzn(slag)
   
   
   Dim fromDate As Date
   Dim untilDate As Date
   fromDate = lenParseDate(Nz(LM("LEN_Qualifyfrom")))
   untilDate = lenParseDate(Nz(LM("LEN_QualifyUntil")))
   
   If (lenDateIsValid(fromDate)) Then
     lmOutp("LIM_QLF_FROM") = fromDate
   End If
   If (lenDateIsValid(untilDate)) Then
     lmOutp("LIM_QLF_UNTIL") = untilDate
   End If
   
   If (limListID <> -1) Then
     lmOutp("LIM_LEN_LIST_ID") = limListID
   Else
     lmOutp("LIM_LEN_LIST_ID") = Null
   End If
   
   lmOutp.Update


  LM.MoveNext
Loop


appCleanRS LM
appCleanRS lmOutp
appCleanRS ag
appCleanRS sw


lenReadLimietenFromXMLTables = True
Exit Function
fout:
If (Err = 3021) Then Resume Next
MsgBox Err & " " & Error$, 16

Exit Function

'debug
On Error GoTo 0
Resume
Exit Function
End Function

Private Function lenReadRecordsFromXMLTables(ByVal lxVersion As Long, ByVal wedAgeDate As Date, ByRef recAgeMode As String) As Boolean
On Error GoTo fout
lenReadRecordsFromXMLTables = False

Dim sql As String
sql = "SELECT LEN_RECORD.*, LEN_RECORDLIST.LEN_TYPE, LEN_RECORDLIST.LEN_NAME, LEN_RECORDLIST.LEN_GENDER, LEN_RECORDLIST.LEN_COURSE, LEN_RECORDLIST.SYS_REF_AGEGROUP, LEN_RECORDLIST.LEN_AGEDATETYPE " & _
      "FROM ((LEN_RECORD INNER JOIN LEN_RECORD_COLL ON LEN_RECORD.ID_RECORD = LEN_RECORD_COLL.SYS_REF_CH_RECORD) INNER JOIN LEN_RECORDS ON " & _
      "LEN_RECORD_COLL.ID_RECORD_COLL = LEN_RECORDS.SYS_REF_RECORD_COLL) INNER JOIN LEN_RECORDLIST ON LEN_RECORDS.ID_RECORDS = LEN_RECORDLIST.SYS_REF_RECORDS;"
      

      
Dim rec As Recordset
Set rec = CurrentDb().OpenRecordset(sql)

Dim recOutp As Recordset
Set recOutp = CurrentDb().OpenRecordset("gIMP_LEN_RECORDS")

Dim ag As Recordset
Set ag = CurrentDb().OpenRecordset("LEN_AGEGROUP")
ag.Index = "P"

Dim sw As Recordset
Set sw = CurrentDb().OpenRecordset("LEN_SWIMSTYLE")
sw.Index = "P"

Dim sp As Recordset, spColl As Recordset
Set sp = CurrentDb().OpenRecordset("LEN_SPLIT")
sp.Index = "P"
Set spColl = CurrentDb().OpenRecordset("select * from LEN_SPLIT_COLL order by [ID_SPLIT_COLL]", dbOpenDynaset)

Dim mt As Recordset
Set mt = CurrentDb().OpenRecordset("LEN_MEETINFO")
mt.Index = "P"




rec.MoveFirst
Do Until rec.EOF

   recOutp.AddNew


   Dim agID As Long
   agID = Nz(rec("SYS_REF_AGEGROUP"), -1)
   
   Dim agLenID As Long
   Dim catInf As CAT_INFO
   
   Dim ageMode As String
   
   
   
   
   
   ageMode = lenParseAgeDateType(Nz(rec("LEN_AGEDATETYPE")), LFT_MODE_WEDYR_END)
   recOutp("REC_AgeMode") = hzn(ageMode)
   
   recAgeMode = ageMode
   
   Dim recGender As String
   recGender = Nz(rec("LEN_GENDER"))
   
   Dim lDummy(0 To 0) As Long
   
   If Not (lenLoadLXAgeGroup(lxVersion, ag, Nothing, Nothing, False, Nothing, False, Nothing, "", "", 0, "", agID, agLenID, wedAgeDate, ageMode, recGender, catInf, _
     False, 0, lDummy)) Then
     Exit Function
   End If
   
   Dim swID As Long
   swID = Nz(rec("SYS_REF_SWIMSTYLE"))
   
   Dim Afstand As String, slag As String, besAfw As String
   
   
   If (Not lenLoadLXSwimStyle(sw, swID, Afstand, slag, besAfw)) Then
     Exit Function
   End If
   
   Dim cat As String
   cat = Trim(catInf.cat)
   cat = lenApplyGeslacht(cat, lenParseGender(recGender))
   
   recOutp("REC_ID") = rec("ID_RECORD")
   
   recOutp("REC_TYPE") = rec("LEN_TYPE")
   
   recOutp("REC_Baan") = lenParseCourse(Nz(rec("LEN_COURSE")))
   recOutp("REC_Categorie") = hzn(cat)
   
   recOutp("INT_MAX_AGE") = catGetMaxAllowedAge_bare(cat, wedAgeDate, ageMode)
   recOutp("INT_Geslacht") = hzn(m_of_v(cat))
   
   recOutp("REC_TIJD") = lenParseSwimtime(Nz(rec("LEN_Swimtime")))
   
   Dim tpNDecimals As Integer
   tpNDecimals = Nz(rec("LEN_HUP_NDECIMAls"), 0)
   
   If (tpNDecimals = 1) Or (tpNDecimals = 2) Then
     recOutp("REC_AantalDecimalen") = tpNDecimals
   End If
   
   recOutp("REC_Afstand") = hzn(Afstand)
   recOutp("REC_Slag") = hzn(slag)
   recOutp("REC_Name") = rec("LEN_Name")
   
   Dim isEstaf As Boolean
   isEstaf = Afstand Like "*x*"
   
   recOutp("REC_IsEstaf") = isEstaf
   
   If (isEstaf) Then
     recOutp("REC_Zwemmer_ID") = Null
     recOutp("REC_PLOEG_ID") = Nz(rec("SYS_REF_RELAY"), -1)
   Else
     recOutp("REC_PLOEG_ID") = Null
     recOutp("REC_Zwemmer_ID") = Nz(rec("SYS_REF_ATHLETE"), -1)
   End If
   
   recOutp("REC_Opm") = rec("LEN_COMMENT")
   
   
   Dim mtInfID As Long
   mtInfID = Nz(rec("SYS_REF_MEETINFO"), -1)
   Dim mtBaan As Integer, mtPlaats As String, mtNation As String, mtDate As Date, mtWedDes As String, dbDummy As Double
   If Not (lenLoadLXMeetInfo(mt, mtInfID, mtBaan, mtPlaats, mtNation, mtDate, mtWedDes, dbDummy)) Then
     Exit Function
   End If
   recOutp("REC_Plaats") = hzn(mtPlaats)
   recOutp("REC_Nation") = hzn(mtNation)
   If (lenDateIsValid(mtDate)) Then
     recOutp("REC_Datum") = mtDate
   End If
   recOutp("REC_WedDescription") = hzn(mtWedDes)
   
   
   
   
   Dim tsAf(0 To MAX_N_TUSSENTIJDEN) As Integer
   Dim tsTd(0 To MAX_N_TUSSENTIJDEN) As Double
   Dim tsCnt As Integer
   tsCnt = 0
   
   Dim splitCollID As Long
   splitCollID = Nz(rec("SYS_REF_SPLITS"))
   Dim done As Boolean
   If Not (lenCollPrepareIt(spColl, splitCollID, "SPLIT", done)) Then
     Exit Function
   End If
   Dim spID As Long
   Do Until done
     If Not (lenCollGetNextID(spColl, splitCollID, "SPLIT", spID, done)) Then
       Exit Function
     End If
     
     
     'load the split time.
     Dim spAf As Long, spTime As Double
     If Not lenLoadLXSplit(sp, spID, spAf, spTime) Then
       Exit Function
     End If
     
     If Not tstSetTussenTijd(spAf, spTime, tsCnt, tsAf, tsTd) Then
       Exit Function
     End If
   Loop
   
   Dim tstStr As String
   tstStr = tstReadTussentijdenArray(tsCnt, tsAf, tsTd)
   
   recOutp("REC_Tussentijden") = hzn(tstStr)
   
   
     
   
   

   
   recOutp.Update


  rec.MoveNext
Loop



appCleanRS rec
appCleanRS recOutp
appCleanRS ag
appCleanRS sw
appCleanRS sp
appCleanRS spColl
appCleanRS mt



lenReadRecordsFromXMLTables = True
Exit Function
fout:
If (Err = 3021) Then Resume Next
MsgBox Err & " " & Error$, 16

Exit Function

'debug
On Error GoTo fout
Resume

Exit Function
End Function



Private Function lenWriteProgrammaToXMLTables(ByVal lxVersion As Long, ByVal wedDate As Date, ByVal lftBep As String, ByVal currencyStr As String, ByRef maxUsedSwimStyleID As Long, ByRef maxUsedFeeID As Long) As Boolean
On Error GoTo fout
lenWriteProgrammaToXMLTables = False

Dim maxUsedShRecID As Long
Dim maxUsedEventDetailsID As Long
maxUsedEventDetailsID = 0
maxUsedShRecID = 0

Dim fee As Recordset
Set fee = CurrentDb().OpenRecordset("LEN_FEE")

Dim ag As Recordset
Set ag = CurrentDb().OpenRecordset("LEN_AGEGROUP")

Dim agColl As Recordset
Set agColl = CurrentDb().OpenRecordset("LEN_AGEGROUP_COLL")

Dim ags As Recordset
Set ags = CurrentDb().OpenRecordset("LEN_AGEGROUPS")

Dim evd As Recordset
Set evd = CurrentDb().OpenRecordset("LEN_EVENTDETAILS")

Dim sws As Recordset
Set sws = CurrentDb().OpenRecordset("LEN_SWIMSTYLE")


'modification nov 2006: change order of programmanummers, so that ones with lenex id come before ones without.
'modification jan 2008: modifed back to normal order
Dim prInp As Recordset
'Set prInp = CurrentDb().OpenRecordset("select * from gIMP_LEN_PROGRAMMA order by pr_wed_id, clng(nz([exp_len_id], 999999)),val(nz([pr_Programmanummer])), nz([pr_programmanummer]),pr_id")
Set prInp = CurrentDb().OpenRecordset("select * from gIMP_LEN_PROGRAMMA order by pr_wed_id,val(nz([pr_Programmanummer])), nz([pr_programmanummer]),pr_id")

Dim agInp As Recordset
Set agInp = CurrentDb().OpenRecordset("Select * from gIMP_LEN_leeftijdsgroepen order by lf_pr_id;")



Dim ev As Recordset
Set ev = CurrentDb().OpenRecordset("LEN_EVENT")

Dim evColl As Recordset
Set evColl = CurrentDb().OpenRecordset("LEN_EVENT_COLL")

Dim shRec As Recordset
Set shRec = CurrentDb().OpenRecordset("LEN_SHORTRECORD")





'first correct agegroup_len_ID in agegroups.


Dim updSQL As String
updSQL = "update gIMP_LEN_Leeftijdsgroepen set int_len_id = lf_id;"
DoCmd.SetWarnings False
DoCmd.RunSQL updSQL
DoCmd.SetWarnings True


'first correcly set lenTypes.
updSQL = "update gIMP_LEN_programma set int_len_type = lenQRYFormatProgType(nz([pr_Type]));"
DoCmd.SetWarnings False
DoCmd.RunSQL updSQL
DoCmd.SetWarnings True

'now correctly set len_id for progs that do not yet have a len_id.





Dim progIDS(0 To MAX_N_PROGS) As Long
Dim progLenNumbers(0 To MAX_N_PROGS) As Long
Dim progLenIDs(0 To MAX_N_PROGS) As Long
Dim progCnt As Integer
progCnt = 0

Dim lenNumbers(0 To MAX_N_PROGS) As Long
Dim lenNumberMaxUsedLenID(0 To MAX_N_PROGS) As Long
Dim lenNumbersCnt As Integer
lenNumbersCnt = 0

Dim lenUsedIDs(0 To MAX_N_PROGS) As Long
Dim lenUsedIDsCnt As Integer
lenUsedIDsCnt = 0

Dim lastUsedLenNr As Long
lastUsedLenNr = 0

Dim lastUsedLenID As Long
lastUsedLenID = 0

  
  
prInp.MoveFirst
Do Until prInp.EOF

  Dim progID As Long
  progID = Nz(prInp("PR_ID"))
  
  
  Dim prvProgID As Long
  prvProgID = Nz(prInp("PR_Vorig_Prog_ID"), -1)
  
  Dim genLenID As Long
  Dim genLenNr As Long
  
  
  'modification nov 2006. If a lenid or len_nr is already available,
  'try to use this number.
  
  Dim suppLenID As Long
  Dim suppLenNr As Long
  Dim suppAv As Boolean
  
  suppLenID = Nz(prInp("EXP_LEN_ID"), -1)
  suppLenNr = Nz(prInp("EXP_LEN_NR_ID"), -1)
  suppAv = (suppLenID > 0) And (suppLenNr > 0)
  
  Dim blUseSuppliedLenNr As Boolean
  Dim blUseSuppliedLenID As Boolean
  
  Dim lkpLenNrPos As Integer
  Dim lkpLenIDPos As Integer
  
  
  Dim actValProg As Long
  actValProg = CLng(val(Nz(prInp("PR_Programmanummer"))))
  
  Dim prvProgIdx As Integer
  prvProgIdx = -1
  If (prvProgID <> -1) Then
    prvProgIdx = bSearchLong(prvProgID, progCnt, progIDS)
  End If
  
  
  If (prvProgIdx <> -1) Then
  
    'A previous lenNumber is available. Use that
    genLenNr = progLenNumbers(prvProgIdx)
        
    Dim lenNumberIdx As Integer
    lenNumberIdx = bSearchLong(genLenNr, lenNumbersCnt, lenNumbers)
        
    If (lenNumberIdx = -1) Then
      Err.Raise 1, , , "Internal error."
    End If
        
        
        
    Dim minGenLenID As Long
    minGenLenID = lenNumberMaxUsedLenID(lenNumberIdx) + 1
        
    Dim reqGenLenID As Long
        
    Dim prType As String
    prType = Nz(prInp("PR_TYPE"))
        
    If prType = PROG_TYPE_SWOFF Then
        reqGenLenID = 100 * genLenNr + 3
    ElseIf prType = PROG_TYPE_FST Then
        reqGenLenID = 100 * genLenNr + 8
    ElseIf prType = PROG_TYPE_FIN Then
        reqGenLenID = 100 * genLenNr + 9
    End If
        
    'mod 2006.
    'Try to use supplied, if possible
    If (suppAv) And suppLenNr = genLenNr Then
        reqGenLenID = suppLenID
    End If
        
        
    genLenID = reqGenLenID
    If (minGenLenID > genLenID) Then
      genLenID = minGenLenID
    End If
        
    While (bSearchLong(genLenID, lenUsedIDsCnt, lenUsedIDs) >= 0)
      genLenID = genLenID + 1
    Wend
        
        
    lenNumberMaxUsedLenID(lenNumberIdx) = genLenID
        
        
        
      
    'insert the new genLenID
    insLong genLenID, lenUsedIDsCnt, lenUsedIDs
    If (genLenID > lastUsedLenID) Then
      lastUsedLenID = genLenID
    End If
  
  Else
    'prvProgIdx = -1
    
    
      'Need to generate a new number.
      'Try to use the supplied numbers.
      
      blUseSuppliedLenNr = False
      blUseSuppliedLenID = False
      
      If (suppAv) Then
        'see if the supplied number is used.
        lkpLenNrPos = bSearchLong(suppLenNr, lenNumbersCnt, lenNumbers)
        lkpLenIDPos = bSearchLong(suppLenID, lenUsedIDsCnt, lenUsedIDs)
        'We may only use the supplied number if it is not already in use.
        If (lkpLenNrPos = -1) Then
          blUseSuppliedLenNr = True
        End If
        
        If (blUseSuppliedLenNr) Then
          If (suppLenNr <> actValProg) Then
            If (bSearchLong(actValProg, lenNumbersCnt, lenNumbers) < 0) Then
              'actValProg is still available. This should have been used.
              'Reject the supplied len number.
              blUseSuppliedLenNr = False
            End If
          End If
        End If
        
        
        If (blUseSuppliedLenNr) Then
          If (lkpLenIDPos = -1) Then
            blUseSuppliedLenID = True
          End If
        End If
      End If
        
        
      If (blUseSuppliedLenNr) Then
        genLenNr = suppLenNr
      Else
        'check valProg
        If (bSearchLong(actValProg, lenNumbersCnt, lenNumbers) < 0) Then
          genLenNr = actValProg
        Else
          'Use new number
          genLenNr = lastUsedLenNr + 1
        End If
      End If
      
      If (blUseSuppliedLenID) Then
        'The suppLenId is available and valid
        genLenID = suppLenID
      Else
        'Need to look for a new lenID
        genLenID = genLenNr * 100
        While (bSearchLong(genLenID, lenUsedIDsCnt, lenUsedIDs) >= 0)
          genLenID = genLenID + 1
        Wend
      End If
      
      'End new code
      
      
      
      If (genLenNr > lastUsedLenNr) Then
        lastUsedLenNr = genLenNr
      End If
      
      
      'insert the new lenNumber.
      Dim insLenNrPos As Integer
      Dim curLenNmbCnt As Integer
      curLenNmbCnt = lenNumbersCnt
      insLenNrPos = insLong(genLenNr, lenNumbersCnt, lenNumbers)
      shiftRightLong insLenNrPos, 1, curLenNmbCnt, lenNumberMaxUsedLenID
      lenNumberMaxUsedLenID(insLenNrPos) = genLenID
      
      'insert the new lenId
      insLong genLenID, lenUsedIDsCnt, lenUsedIDs
      If (genLenID > lastUsedLenID) Then
        lastUsedLenID = genLenID
      End If
      
      
      If (prvProgID <> -1) Then
        'show warning
        MsgBox "Waarschuwing: finale prognr. " & Nz(prInp("PR_Programmanummer")) & " verwijst naar toekomstig of dubbel gedefinieerd programmanummer. ", vbExclamation
      End If
  
  End If
  
  'Now insert the information into the prog arrays


  Dim insIdx As Integer
  Dim curProgCnt As Long
  curProgCnt = progCnt
  insIdx = insLong(progID, progCnt, progIDS)
  shiftRightLong insIdx, 1, curProgCnt, progLenNumbers
  shiftRightLong insIdx, 1, curProgCnt, progLenIDs
  progLenNumbers(insIdx) = genLenNr
  progLenIDs(insIdx) = genLenID
  
  prInp.Edit
  prInp("INT_LEN_ID") = genLenID
  prInp("INT_LEN_NR_ID") = genLenNr
  prInp.Update


  prInp.MoveNext
Loop




'Now need to read PR_Vorig_Prog_LEN_ID from table.
Dim updPrIDSQL As String
updPrIDSQL = "UPDATE gIMP_LEN_Programma INNER JOIN gIMP_LEN_Programma AS gIMP_LEN_Programma_1 ON " & _
"gIMP_LEN_Programma.PR_Vorig_Prog_ID = gIMP_LEN_Programma_1.PR_ID SET gIMP_LEN_Programma.INT_Vorig_Prog_LEN_ID = " & _
"[gIMP_LEN_PROGRAMMA_1].[INT_LEN_ID], [gIMP_LEN_PROGRAMMA].INT_LEN_TYPE = lenQRYReformatProgType(nz([gIMP_LEN_PROGRAMMA].INT_LEN_TYPE),nz([gIMP_LEN_PROGRAMMA_1].INT_LEN_TYPE)) ;"
DoCmd.SetWarnings False
DoCmd.RunSQL updPrIDSQL
DoCmd.SetWarnings True

Dim updPrvLenTypeSQL As String
updPrvLenTypeSQL = "UPDATE gIMP_LEN_Programma INNER JOIN gIMP_LEN_Programma AS gIMP_LEN_Programma_1 ON gIMP_LEN_Programma.PR_Vorig_Prog_ID = " & _
      "gIMP_LEN_Programma_1.PR_ID SET gIMP_LEN_Programma_1.INT_LEN_Type = lenQRYReformatPrvProgType(nz([gIMP_LEN_Programma_1].[INT_LEN_TYPE]), " & _
      "nz([gIMP_LEN_Programma].[INT_LEN_TYPE]));"
      
DoCmd.SetWarnings False
DoCmd.RunSQL updPrvLenTypeSQL
DoCmd.SetWarnings True




'now start the final pass through the table.

prInp.MoveFirst


Do Until prInp.EOF
  
  
  progID = Nz(prInp("PR_ID"))
  

  
  ev.AddNew
    
    ev("ID_EVENT") = progID
    
    ev("SYS_REF_AGEGROUPS") = Null
    
    agInp.FindFirst "LF_PR_ID = " & progID
    
    
    Dim tpIsEstaf As Boolean
    tpIsEstaf = (Nz(prInp("PR_Afstand")) Like "*x*")
    
    Dim tpAllowMixedEstafs As Boolean
    tpAllowMixedEstafs = False
    
    Dim catInf As CAT_INFO
    
    
    'addition dd january 2007 ivm trouble when there were leeftijdscategorie groepen,
    'but the category had been changed to a non-mv category.
    
    Dim tpIsMVCat As Boolean
    tpIsMVCat = catIsMCat(Nz(prInp("PR_Categorie")))
    
    
    Dim blAgeGroupWritten As Boolean
    blAgeGroupWritten = False
    
    If tpIsMVCat And (Not agInp.NoMatch) Then
      blAgeGroupWritten = True
      ev("SYS_REF_AGEGROUPS") = progID
      If Not lenWriteSimpleCollection(ags, progID, "AGEGROUP") Then Exit Function
      Dim done As Boolean
      done = agInp.EOF
      Do Until done
        
          Dim lfLenID As Long
          lfLenID = Nz(agInp("INT_LEN_ID"))
          
          
          
          If Not lenReadCatInfo(agInp, "LF_", True, catInf) Then Exit Function
          
          If (tpIsEstaf) Then
            If (m_of_v(Trim(catInf.cat)) = "*") Then
              tpAllowMixedEstafs = True
            End If
          End If
          
                    
          Dim tpAGID As Long
          tpAGID = 3 * Nz(agInp("LF_ID")) + 1
          
          'Use X for mixed only if the current prog is an estafette.
          If Not lenAppendLXAgeGroup(lxVersion, ag, evd, shRec, tpAGID, lfLenID, maxUsedEventDetailsID, maxUsedShRecID, wedDate, lftBep, catInf, tpIsEstaf) Then Exit Function
          
          If Not lenAddToCollection(agColl, progID, tpAGID, "AGEGROUP") Then Exit Function
          
        
        agInp.MoveNext
        If (agInp.EOF) Then
          done = True
        ElseIf (Nz(agInp("LF_PR_ID")) <> progID) Then
          done = True
        End If
      Loop
    End If
    
    
    'now parse agegroup of programma
    
    If Not lenReadCatInfo(prInp, "PR_", False, catInf) Then Exit Function
    
    If (tpIsEstaf) Then
      If Not tpIsMVCat Then
        If m_of_v(Trim(catInf.cat)) = "*" Then
          tpAllowMixedEstafs = True
        End If
      End If
    End If
    
    
    Dim gender As String, minAge As Integer, maxAge As Integer, isTotAge As Boolean, name As String, isMCat As Boolean
    'Use X in gender only if the prog is an estafette prog and mixed estafs are allowed; otherwise use blank if both boys and girls can swim.
    If Not lenFormatCategorie(Trim(catInf.cat), wedDate, lftBep, gender, minAge, maxAge, isTotAge, isMCat, tpAllowMixedEstafs) Then
      Err.Raise 1, , "Ongeldige categorie: " + Trim(catInf.cat)
      Exit Function
    End If
    
    
     
    
    ev("LEN_GENDER") = hzn(gender)
    
    Dim blNeedsAG As Boolean
    blNeedsAG = Not blAgeGroupWritten
    
    If (blNeedsAG) Then
      'if lxVersion >= LX_VERSION_3, then we always need to output at least one age group
      'otherwise, it may be possible to get away without any age groups
      If (lxVersion < LX_VERSION_3) Then
        If (isMCat) Or (minAge = -1 And maxAge = -1) Then
          blNeedsAG = False
        End If
      End If
    End If
    
    
    If (blNeedsAG) Then
    
      ev("SYS_REF_AGEGROUPS") = progID
      If Not lenWriteSimpleCollection(ags, progID, "AGEGROUP") Then Exit Function
      
      Dim catInfSimple As CAT_INFO
      lenInitCat catInfSimple
      catInfSimple.cat = catInf.cat
      catInfSimple.bescat = catInf.bescat
      
      lfLenID = 1
      
      
      tpAGID = 3 * progID
      
      'Use X for mixed only if the current prog is an estafette that allows mixed estafs
      If Not lenAppendLXAgeGroup(lxVersion, ag, evd, shRec, tpAGID, lfLenID, maxUsedEventDetailsID, maxUsedShRecID, wedDate, lftBep, catInfSimple, tpAllowMixedEstafs) Then Exit Function
          
      If Not lenAddToCollection(agColl, progID, tpAGID, "AGEGROUP") Then Exit Function
      
    End If
    
    maxUsedEventDetailsID = maxUsedEventDetailsID + 1
    
    'output event details.
    If Not lenAppendLXEventDetails(evd, shRec, maxUsedEventDetailsID, maxUsedShRecID, catInf) Then Exit Function
    
    ev("SYS_REF_EVENTDETAILS") = maxUsedEventDetailsID
    
    
    If (Not IsNull(prInp("PR_Aanvang"))) Then
      ev("LEN_DAYTIME") = lenFormatTime(Nz(prInp("PR_Aanvang"), #12:00:00 AM#))
    End If
    
    
    ev("LEN_DISPLAYEVENTID") = prInp("PR_Programmanummer")
    
    ev("LEN_EVENTID") = prInp("INT_LEN_ID")
    ev("LEN_NUMBER") = prInp("INT_LEN_NR_ID")

    Dim progType As String
    progType = Nz(prInp("PR_Type"))
    
    ev("LEN_FINALTYPE") = hzn(lenFormatFinalType(progType))
    
    ev("LEN_PREVEVENTID") = prInp("INT_Vorig_Prog_LEN_ID")
    ev("LEN_REMARK") = prInp("PR_Opmerking")
    ev("LEN_ROUND") = prInp("INT_LEN_TYPE")
    
    maxUsedSwimStyleID = maxUsedSwimStyleID + 1
    ev("SYS_REF_SWIMSTYLE") = maxUsedSwimStyleID
    
    Dim af As String, sl As String, besAfw As String
    af = Nz(prInp("PR_AFstand"))
    sl = Nz(prInp("PR_Slag"))
    besAfw = Nz(prInp("PR_BeschrijvingAfwijkend"))
    
    If Not lenAppendLXSwimStyle(sws, maxUsedSwimStyleID, af, sl, besAfw) Then Exit Function
    
    'february 2007
    Dim isNonComp As Boolean
    isNonComp = Nz(prInp("PR_BM")) = "J"
    ev("LEN_NONCOMP") = lenFormatBoolean(isNonComp)
    ev("LEN_NRCNTPTC") = Nz(prInp("PR_AantMeetel"), 0)
    'end addition.
    
    
    
    Dim kostenVal As Double
    kostenVal = Nz(prInp("PR_Kosten"), 0)
    If kostenVal > 0.01 Then
      maxUsedFeeID = maxUsedFeeID + 1
      ev("SYS_REF_FEE") = maxUsedFeeID
      If Not lenAppendLXFee(fee, maxUsedFeeID, currencyStr, kostenVal, False, True, False, False) Then Exit Function
    Else
      ev("SYS_REF_FEE") = Null
    End If
    
    Dim collID As Long
    collID = Nz(prInp("PR_WED_ID"))
    If Not lenAddToCollection(evColl, collID, progID, "EVENT") Then Exit Function
    
    
   ev.Update
    
  prInp.MoveNext
Loop


appCleanRS fee
appCleanRS ag
appCleanRS agColl
appCleanRS ags
appCleanRS evd
appCleanRS sws
appCleanRS prInp
appCleanRS agInp
appCleanRS ev
appCleanRS evColl
appCleanRS shRec


lenWriteProgrammaToXMLTables = True
Exit Function
fout:
If (Err = 3021) Then Resume Next
MsgBox Err & " " & Error$, 16

Exit Function

'debug
On Error GoTo 0
Resume

Exit Function
End Function

Private Function lenWriteContactsToXMLTables(ByRef constructorContactID As Long) As Boolean
On Error GoTo fout
lenWriteContactsToXMLTables = False

Dim ctOutp As Recordset
Set ctOutp = CurrentDb().OpenRecordset("LEN_CONTACT")

Dim ctInp As Recordset
Set ctInp = CurrentDb().OpenRecordset("gIMP_LEN_CONTACT")

Dim maxUsedContID As Long
maxUsedContID = 0

Dim contact As CONTACT_INFO

ctInp.MoveFirst
Dim ctID As Long
Do Until ctInp.EOF
  
  ctID = Nz(ctInp("CT_ID"))
  If (ctID > maxUsedContID) Then
    maxUsedContID = ctID
  End If
  
  If Not lenReadContactInfo(ctInp, "CT_", contact) Then Exit Function
  
  If Not lenAppendLXContact(ctOutp, ctID, contact) Then Exit Function

  ctInp.MoveNext
Loop

'Now output construct contact.
constructorContactID = maxUsedContID + 1

contact.adres = "Kon. Emmaplantsoen 4"
contact.adres2 = ""
contact.sEmail = "hjhupkes@gmail.com"
contact.fax = ""
contact.internet = "http://home.kpn.nl/wimhupke/hupsoft"
contact.mobiel = ""
contact.naam = "Hermen Jan Hupkes"
contact.nation = "NL"
contact.sPlaats = "Rijnsburg"
contact.sPostcode = "2231 TZ"
contact.state = ""
contact.tel = "071-5801854"

If Not lenAppendLXContact(ctOutp, constructorContactID, contact) Then Exit Function


appCleanRS ctOutp
appCleanRS ctInp





lenWriteContactsToXMLTables = True
Exit Function
fout:
If (Err = 3021) Then Resume Next
MsgBox Err & " " & Error$, 16
Exit Function
End Function

Private Function lenWriteClubsToXMLTables() As Boolean
On Error GoTo fout
lenWriteClubsToXMLTables = False


Dim clInp As Recordset
Set clInp = CurrentDb().OpenRecordset("gIMP_LEN_VER")

Dim clOutp As Recordset
Set clOutp = CurrentDb().OpenRecordset("LEN_CLUB")

Dim clColl As Recordset
Set clColl = CurrentDb().OpenRecordset("LEN_CLUB_COLL")


Dim athletes As Recordset
Set athletes = CurrentDb().OpenRecordset("LEN_ATHLETES")

Dim relays As Recordset
Set relays = CurrentDb().OpenRecordset("LEN_RELAYS")




'first need to correct
'INT_HAS_ATHLETES and INT_HAS_RELAYS
Dim updSQL As String
DoCmd.SetWarnings False
updSQL = "update gIMP_LEN_VER set int_has_athletes = false, int_has_relays = false;"
DoCmd.RunSQL updSQL

updSQL = "UPDATE gIMP_LEN_Zwemmers INNER JOIN gIMP_LEN_Ver ON gIMP_LEN_Zwemmers.ZW_VER_ID = gIMP_LEN_Ver.V_ID SET gIMP_LEN_Ver.INT_HAS_ATHLETES = True;"
DoCmd.RunSQL updSQL

updSQL = "UPDATE gIMP_LEN_Ploeg INNER JOIN gIMP_LEN_Ver ON gIMP_LEN_Ploeg.PL_VER_ID = gIMP_LEN_Ver.V_ID SET gIMP_LEN_Ver.INT_HAS_RELAYS = True;"
DoCmd.RunSQL updSQL



DoCmd.SetWarnings True


Dim firstMeetClubEnc As Boolean
firstMeetClubEnc = False

Dim firstTimeArchiveClubEnc As Boolean
firstTimeArchiveClubEnc = False


clInp.MoveFirst

If Not clInp.EOF Then
  
End If

Do Until clInp.EOF

  Dim partOfRec As Boolean, partOfTimeArchive As Boolean
  partOfRec = Nz(clInp("V_PartOfRecord"))
  partOfTimeArchive = Nz(clInp("V_PartOfTimeArchive"))
  
  
  Dim rsClubs As Recordset
  
  If (partOfRec) Then
  
    'don't need to build collection
  
  ElseIf (partOfTimeArchive) Then
  
    If (Not firstTimeArchiveClubEnc) Then
      firstTimeArchiveClubEnc = True
      
      Set rsClubs = CurrentDb().OpenRecordset("LEN_CLUBS")
      If Not lenWriteSimpleCollection(rsClubs, 2, "CLUB") Then Exit Function
      appCleanRS rsClubs
      
    End If
  
  Else
  
    'partOfMeet
  
    If (Not firstMeetClubEnc) Then
      firstMeetClubEnc = True
      
      Set rsClubs = CurrentDb().OpenRecordset("LEN_CLUBS")
      If Not lenWriteSimpleCollection(rsClubs, 1, "CLUB") Then Exit Function
      appCleanRS rsClubs
      
    End If
  
  End If
  
  
  clOutp.AddNew
  Dim clubID As Long
  clubID = Nz(clInp("V_ID"), -1)
  clOutp("ID_CLUB") = clubID
  
  If (Not partOfRec) Then
    If (Nz(clInp("INT_HAS_ATHLETES"))) Then
      clOutp("SYS_REF_ATHLETES") = clubID
      If Not lenWriteSimpleCollection(athletes, clubID, "ATHLETE") Then Exit Function
    End If
  End If

  
  clOutp("LEN_CITY") = clInp("V_PLAATS")
  
  
  'modification jan 2015: only use external code if depot nr is generated
  Dim extCode As String
  extCode = Nz(clInp("V_Extern_Code"))
  
  If (Nz(clInp("V_Depot_Fixed"))) Then
    extCode = Nz(clInp("V_Depot"))
  End If
    
  
  clOutp("LEN_CODE") = hzn(extCode)
  
  clOutp("LEN_Region") = clInp("V_Region")
  
  
  If Not partOfRec Then
    clOutp("SYS_REF_CONTACT") = clInp("V_CONTACT_ID")
  Else
    clOutp("SYS_REF_CONTACT") = Null
  End If
  
  Dim langNaam As String
  langNaam = Nz(clInp("V_Langnaam"))
  If (langNaam = "") Then
    langNaam = Nz(clInp("V_Naam"))
  End If
  clOutp("LEN_NAME") = hzn(langNaam)
  clOutp("LEN_NATION") = clInp("V_LAND")
  clOutp("SYS_REF_OFFICIALS") = Null
    
  
  If (Not partOfRec) Then
    If (Nz(clInp("INT_HAS_RELAYS"))) Then
      clOutp("SYS_REF_RELAYS") = clubID
      If Not lenWriteSimpleCollection(relays, clubID, "RELAY") Then Exit Function
    End If
  End If
  
  clOutp("LEN_SHORTNAME") = clInp("V_Naam")
  clOutp("LEN_TYPE") = Null
  
  clOutp.Update
  
  If (partOfRec) Then
  ElseIf (partOfTimeArchive) Then
    If Not lenAddToCollection(clColl, 2, clubID, "CLUB") Then Exit Function
  Else
    If Not lenAddToCollection(clColl, 1, clubID, "CLUB") Then Exit Function
  End If
  
  
  clInp.MoveNext
Loop


appCleanRS clInp
appCleanRS clOutp
appCleanRS clColl
appCleanRS athletes
appCleanRS relays


lenWriteClubsToXMLTables = True
Exit Function
fout:
If (Err = 3021) Then Resume Next
MsgBox Err & " " & Error$, 16

Exit Function

'debug
On Error GoTo 0
Resume

Exit Function

End Function
Private Function lenWriteAthletesToXMLTables() As Boolean
On Error GoTo fout
lenWriteAthletesToXMLTables = False

Dim atInp As Recordset
Set atInp = CurrentDb().OpenRecordset("gIMP_LEN_Zwemmers")

Dim atOutp As Recordset
Set atOutp = CurrentDb().OpenRecordset("LEN_ATHLETE")

Dim atColl As Recordset
Set atColl = CurrentDb().OpenRecordset("LEN_ATHLETE_COLL")

Dim entries As Recordset
Set entries = CurrentDb().OpenRecordset("LEN_ENTRIES")
Dim results As Recordset
Set results = CurrentDb().OpenRecordset("LEN_RESULTS")
Dim archivedTimes As Recordset
Set archivedTimes = CurrentDb().OpenRecordset("LEN_ARCHIVEDTIMES")

Dim rsHnd As Recordset
Set rsHnd = CurrentDb().OpenRecordset("LEN_HANDICAP")

'first need to set INT_LEN_ID,
'INT_HAS_RESULTS and INT_HAS_ENTRIES
'for each swimmer.


DoCmd.SetWarnings False
Dim updSQL As String
updSQL = "update gIMP_LEN_zwemmers set int_has_results= false, int_has_entries = false, int_has_archivedtimes = false,  int_len_id = zw_id;"
DoCmd.RunSQL updSQL




updSQL = "UPDATE gIMP_LEN_Deelnemers INNER JOIN gIMP_LEN_Zwemmers ON gIMP_LEN_Deelnemers.DE_Zwemmer_ID = gIMP_LEN_Zwemmers.ZW_ID SET gIMP_LEN_Zwemmers.INT_HAS_ENTRIES = True;"
DoCmd.RunSQL updSQL
updSQL = "UPDATE gIMP_LEN_Tijden INNER JOIN gIMP_LEN_Zwemmers ON gIMP_LEN_Tijden.TY_Zwemmer_ID = gIMP_LEN_Zwemmers.ZW_ID SET gIMP_LEN_Zwemmers.INT_HAS_RESULTS = True;"
DoCmd.RunSQL updSQL
updSQL = "UPDATE gIMP_LEN_ArchiefTijden INNER JOIN gIMP_LEN_Zwemmers ON gIMP_LEN_ArchiefTijden.TD_Zwemmer_ID = gIMP_LEN_Zwemmers.ZW_ID SET gIMP_LEN_Zwemmers.INT_HAS_ARCHIVEDTIMES = True;"
DoCmd.RunSQL updSQL

DoCmd.SetWarnings True




atInp.MoveFirst
Do Until atInp.EOF
  Dim athID As Long
  'athlete ids will be even, relay ids will be odd.
  athID = 2 * Nz(atInp("ZW_ID"))
  
  atOutp.AddNew
  
    Dim clubID As Long
    clubID = Nz(atInp("ZW_VER_ID"), -1)
  
    atOutp("ID_ATHLETE") = athID
    
    
    Dim gebDate As Date
    gebDate = Nz(atInp("ZW_Geboortedatum"), #1/1/1900#)
    
    Dim jaartal As Long
    jaartal = Nz(atInp("ZW_Jaartal"))
    
    If (jaartal < 1900) Then
      Err.Raise 1, , "De zwemmer: " & Nz(atInp("ZW_Voornaam")) & " " & Nz(atInp("ZW_Voegsel")) & " " & Nz(atInp("ZW_Achternaam")) & vbCrLf & "met startnumer: " & Nz(atInp("ZW_Startnummer")) & vbCrLf & "heeft een ongeldig geboortejaar. Controleer of het startnummer juist is ingevoerd."
    End If
    
    atOutp("LEN_BIRTHDATE") = lenFormatBirthDate(gebDate, Nz(atInp("ZW_Jaartal")))
    
    Dim partOfRecord As Boolean
    partOfRecord = Nz(atInp("ZW_PartOfRecord"))
    
    If (partOfRecord) Then
      atOutp("LEN_ATHLETEID") = Null
      If (clubID <> -1) Then
        atOutp("SYS_REF_CLUB") = clubID
      Else
        atOutp("SYS_REF_CLUB") = Null
      End If
      atOutp("SYS_REF_ENTRIES") = Null
      atOutp("SYS_REF_RESULTS") = Null
      atOutp("SYS_REF_ARCHIVEDTIMES") = Null
    Else
      atOutp("LEN_ATHLETEID") = atInp("INT_LEN_ID")
      atOutp("SYS_REF_CLUB") = Null
      
      If (Nz(atInp("INT_HAS_RESULTS"))) Then
        atOutp("SYS_REF_RESULTS") = athID
        If Not lenWriteSimpleCollection(results, athID, "RESULT") Then Exit Function
      Else
        atOutp("SYS_REF_RESULTS") = Null
      End If
      
      If (Nz(atInp("INT_HAS_ENTRIES"))) Then
        atOutp("Sys_ref_Entries") = athID
        If Not lenWriteSimpleCollection(entries, athID, "ENTRY", "ENTRIES") Then Exit Function
      Else
        atOutp("Sys_ref_Entries") = Null
      End If
      
      If (Nz(atInp("INT_HAS_ARCHIVEDTIMES"))) Then
        atOutp("Sys_ref_ArchivedTimes") = athID
        If Not lenWriteSimpleCollection(archivedTimes, athID, "ARCHIVEDTIME") Then Exit Function
      Else
        atOutp("Sys_ref_ArchivedTimes") = Null
      End If
      
      
      
      If Not lenAddToCollection(atColl, clubID, athID, "ATHLETE") Then Exit Function
      
    End If
    
    atOutp("LEN_FIRSTNAME") = atInp("ZW_Voornaam")
    atOutp("LEN_GENDER") = hzn(lenFormatGeslacht(Nz(atInp("ZW_Geslacht")), True))
    atOutp("LEN_LASTNAME") = atInp("ZW_Achternaam")
    
    Dim licCode As String
    licCode = Nz(atInp("ZW_ExternalLicenseCode"))
    Dim startnr As String
    startnr = Nz(atInp("ZW_Startnummer"))
    'If (licCode = "" Or (licCode = startnr)) And Nz(atInp("ZW_Startnummer_Fixed")) Then
    If (Nz(atInp("ZW_Startnummer_Fixed"))) Then
      'Only allow startnummer if startnummer is fixed.
      licCode = lenFormatStartnummer(startnr, jaartal)
    End If
    
    atOutp("LEN_LICENSE") = hzn(licCode)
    atOutp("LEN_MIDDLENAME") = atInp("ZW_Middelnaam")
    atOutp("LEN_NAMEPREFIX") = atInp("ZW_Voegsel")
    
    'Dim nation As String
    'nation = Nz(atInp("ZW_Nation"))
    'If (nation = "") Then nation = "NED"
    
    atOutp("LEN_NATION") = atInp("ZW_Nation")
    
    atOutp("LEN_PASSPORT") = Null
    
    
    
    Dim sHndFree As String, sHndBreast As String, sHndMedley As String, sHndException As String
    sHndFree = Nz(atInp("ZW_HND_Free"))
    sHndBreast = Nz(atInp("ZW_HND_Breast"))
    sHndMedley = Nz(atInp("ZW_HND_Medley"))
    sHndException = Nz(atInp("ZW_HND_Exception"))
    
    Dim blIsHandicap As Boolean
    blIsHandicap = False
    
    If (sHndFree <> "") Or (sHndBreast <> "") Or (sHndMedley <> "") Or (sHndException <> "") Then
      blIsHandicap = True
    End If
    
    If Not blIsHandicap Then
      atOutp("SYS_REF_HANDICAP") = Null
    Else
      atOutp("SYS_REF_HANDICAP") = athID
      
      rsHnd.AddNew
        
        rsHnd("ID_HANDICAP") = athID
        
        rsHnd("LEN_breast") = hzn(lenFormatHandicap(sHndBreast))
        rsHnd("LEN_free") = hzn(lenFormatHandicap(sHndFree))
        rsHnd("LEN_medley") = hzn(lenFormatHandicap(sHndMedley))
        
        rsHnd("LEN_exception") = hzn(sHndException)
        
      rsHnd.Update
      
    End If 'if not blIsHandicap
    
    
    
    
  atOutp.Update
  



  atInp.MoveNext
Loop


appCleanRS atInp
appCleanRS atOutp
appCleanRS atColl
appCleanRS entries
appCleanRS results
appCleanRS archivedTimes
appCleanRS rsHnd

lenWriteAthletesToXMLTables = True
Exit Function
fout:
If (Err = 3021) Then Resume Next
MsgBox Err & " " & Error$, 16

Exit Function


'debug
On Error GoTo 0
Resume

Exit Function


End Function

Private Function lenAppendHeat(ByRef skHeats As Recordset, ByRef skPrWithHeats As Recordset, ByRef rsHeat As Recordset, ByRef rsHeatColl As Recordset, ByRef muHeatID As Long, ByVal lPRXId As Long, lSerie As Long, ByRef lLenHeatID As Long) As Boolean
On Error GoTo fout
lenAppendHeat = False

skHeats.Seek "=", lPRXId, lSerie

If skHeats.NoMatch Then

  muHeatID = muHeatID + 1
  
  Dim heatCollID As Long
  heatCollID = lPRXId

    
  rsHeat.AddNew
    rsHeat("ID_HEAT") = muHeatID
    
    rsHeat("LEN_HeatID") = muHeatID
    lLenHeatID = muHeatID
    
    rsHeat("LEN_Number") = lSerie
  rsHeat.Update
  
  
  skHeats.AddNew
    skHeats("HT_PR_ID") = lPRXId
    skHeats("HT_Serie") = lSerie
    skHeats("HT_HT_Len_ID") = lLenHeatID
  skHeats.Update
  
  
  If Not lenAddToCollection(rsHeatColl, heatCollID, muHeatID, "HEAT") Then
    Exit Function
  End If
  
  skPrWithHeats.Seek "=", lPRXId
  If skPrWithHeats.NoMatch Then
    skPrWithHeats.AddNew
      skPrWithHeats("PWH_PR_XID") = lPRXId
    skPrWithHeats.Update
  End If
  
Else

  lLenHeatID = Nz(skHeats("HT_HT_LEN_ID"))
  
End If


lenAppendHeat = True
Exit Function
fout:
MsgBox Err & " lenAppendHeat" & vbCrLf & Error$, 16

Exit Function

'debug
On Error GoTo 0
Resume

End Function

Private Function lenAppendTStdRef(ByRef skTStdRefs As Recordset, ByRef skPrWithTStdRefs As Recordset, ByRef rsTStdRef As Recordset, ByRef rsTStdRefColl As Recordset, ByRef muTStdRefXID As Long, ByVal lPRXId As Long, ByVal lLenListID As Long) As Boolean
On Error GoTo fout
lenAppendTStdRef = False

skTStdRefs.Seek "=", lPRXId, lLenListID

If skTStdRefs.NoMatch Then

  muTStdRefXID = muTStdRefXID + 1
  
  Dim lTStdRefCollID As Long
  lTStdRefCollID = lPRXId

    
  rsTStdRef.AddNew
    rsTStdRef("ID_TIMESTANDARDREF") = muTStdRefXID
    rsTStdRef("LEN_timestandardlistid") = lLenListID
  rsTStdRef.Update
  
  
  skTStdRefs.AddNew
    skTStdRefs("TSR_PR_XID") = lPRXId
    skTStdRefs("TSR_LIST_LEN_ID") = lLenListID
  skTStdRefs.Update
  
  
  If Not lenAddToCollection(rsTStdRefColl, lTStdRefCollID, muTStdRefXID, "TIMESTANDARDREF") Then
    Exit Function
  End If
  
  skPrWithTStdRefs.Seek "=", lPRXId
  If skPrWithTStdRefs.NoMatch Then
    skPrWithTStdRefs.AddNew
      skPrWithTStdRefs("PWTS_PR_XID") = lPRXId
    skPrWithTStdRefs.Update
  End If
  
End If


lenAppendTStdRef = True
Exit Function
fout:
MsgBox Err & " lenAppendTStdRef" & vbCrLf & Error$, 16

Exit Function

'debug
On Error GoTo 0
Resume

End Function



Private Function lenWriteDeelnemersToXMLTables(ByVal lxVersion As Long, ByRef maxUsedMeetInfoID As Long, ByRef maxUsedHeatID As Long) As Boolean
On Error GoTo fout
lenWriteDeelnemersToXMLTables = False

Dim dlnInp As Recordset
Set dlnInp = CurrentDb().OpenRecordset("gIMP_LEN_Deelnemers")

Dim etColl As Recordset
Set etColl = CurrentDb().OpenRecordset("LEN_ENTRY_COLL")


Dim et As Recordset
Set et = CurrentDb().OpenRecordset("LEN_ENTRY")

Dim mtInf As Recordset
Set mtInf = CurrentDb().OpenRecordset("LEN_MEETINFO")

Dim relaypos As Recordset
Set relaypos = CurrentDb().OpenRecordset("LEN_RELAYPOSITIONS")


Dim skHeats As Recordset
Set skHeats = Nothing

If (lxVersion >= LX_VERSION_3) Then
  Set skHeats = CurrentDb().OpenRecordset("~len_write_heats")
  skHeats.Index = "PrimaryKey"
End If

Dim skPrWithHeat As Recordset
Set skPrWithHeat = Nothing

If (lxVersion >= LX_VERSION_3) Then
  Set skPrWithHeat = CurrentDb().OpenRecordset("~len_progs_with_heats")
  skPrWithHeat.Index = "PrimaryKey"
End If

Dim rsHeat As Recordset
Set rsHeat = CurrentDb().OpenRecordset("LEN_HEAT")


Dim rsHeatColl As Recordset
Set rsHeatColl = CurrentDb().OpenRecordset("LEN_HEAT_COLL")




'Have to update INT_PROG_LEN_ID, INT_HAS_Ploegleden and INT_AGEGROUP_LEN_ID
'We do not need to update INT_HEAT_LEN_ID, as this will simply be equal to the serie number.

DoCmd.SetWarnings False
Dim updSQL As String
updSQL = "update gIMP_LEN_Deelnemers set int_has_ploegleden = false"
DoCmd.RunSQL updSQL

updSQL = "UPDATE gIMP_LEN_Deelnemers INNER JOIN gIMP_LEN_Programma ON gIMP_LEN_Deelnemers.DE_PROG_ID = gIMP_LEN_Programma.PR_ID SET " & _
"gIMP_LEN_Deelnemers.INT_PROG_LEN_ID = [INT_len_id];"
DoCmd.RunSQL updSQL

updSQL = "UPDATE gIMP_LEN_Deelnemers INNER JOIN gIMP_LEN_Leeftijdsgroepen ON gIMP_LEN_Deelnemers.DE_Agegroup_ID = " & _
"gIMP_LEN_Leeftijdsgroepen.LF_ID SET gIMP_LEN_Deelnemers.INT_Agegroup_LEN_ID = [INT_len_id];"
DoCmd.RunSQL updSQL



updSQL = "UPDATE gIMP_LEN_Ploegleden INNER JOIN gIMP_LEN_Deelnemers ON gIMP_LEN_Ploegleden.PLL_Deelnemer_ID = " & _
"gIMP_LEN_Deelnemers.DE_ID SET gIMP_LEN_Deelnemers.INT_HAS_Ploegleden = True;"
DoCmd.RunSQL updSQL

DoCmd.SetWarnings True


dlnInp.MoveFirst
Do Until dlnInp.EOF
  et.AddNew
    Dim entryID As Long
    Dim clubID As Long
    ' all entrries are 0 mod 7, in order to account for relay positions.
    entryID = 7 * Nz(dlnInp("DE_ID"))
    clubID = Nz(dlnInp("DE_VER_ID"))
    et("ID_Entry") = entryID
    et("LEN_AGEGROUPID") = dlnInp("INT_AGEGROUP_LEN_ID")
    et("LEN_EntryTime") = lenFormatSwimTime(Nz(dlnInp("DE_Inschrijftijd")))
    et("LEN_EVENTID") = dlnInp("INT_PROG_LEN_ID")
    et("LEN_GRPCODE") = dlnInp("DE_ABC")
    Dim sr As Long, bn As Integer
    sr = Nz(dlnInp("DE_Serienummer"))
    bn = Nz(dlnInp("DE_Baan"))
    
    
    et("LEN_HEAT") = IIf(sr = 0, Null, sr)
    
    If (lxVersion >= LX_VERSION_3) Then
      et("LEN_HeatID") = Null
      If (sr > 0) Then
        Dim lHtLenID As Long
        
        If Not lenAppendHeat(skHeats, skPrWithHeat, rsHeat, rsHeatColl, maxUsedHeatID, Nz(dlnInp("DE_PROG_ID")), sr, lHtLenID) Then
          Exit Function
        End If
        If (lHtLenID > 0) Then
          et("LEN_HEATID") = lHtLenID
        End If
      End If
    End If
    
    et("LEN_LANE") = IIf(bn = 0, Null, bn)
    
    Dim isBM As Boolean, isRes As Boolean
    isBM = (Nz(dlnInp("DE_BM"), False))
    isRes = (Nz(dlnInp("DE_Reserve"), False))
    
    
    et("LEN_NONCOMP") = lenFormatBoolean(isBM)
    et("LEN_RESERVE") = lenFormatBoolean(isRes)
    
    If (isBM) Then
      et("LEN_STATUS") = hzn(LX_STATUS_EXH)
    Else
      et("LEN_STATUS") = Null
    End If
    
    
    
    Dim tpCapkleur As String, tpCapNr As Long, tpEigenCap As Boolean
    tpCapkleur = Nz(dlnInp("DE_OW_Capkleur"))
    tpCapNr = Nz(dlnInp("DE_OW_Capnummer"), -1)
    tpEigenCap = Nz(dlnInp("DE_OW_Eigencap"))
    
    If (tpCapkleur <> "") And (tpCapNr <> -1) Then
      et("LEN_Capcolor") = hzn(tpCapkleur)
      et("LEN_Capnumber") = tpCapNr
      et("LEN_OwnCap") = lenFormatBoolean(tpEigenCap)
    End If
    
    
    
    
    Dim qlfTime As Double
    Dim qlfBaan As Integer
    Dim qlfPlaats As String, qlfNation As String, qlfDatum As Date, qlfWedName As String
    qlfTime = Nz(dlnInp("DE_QLF_Tijd"))
    qlfBaan = Nz(dlnInp("DE_QLF_Baan"))
    qlfPlaats = Nz(dlnInp("DE_QLF_Plaats"))
    qlfNation = Nz(dlnInp("DE_QLF_Land"))
    qlfDatum = Nz(dlnInp("DE_QLF_Datum"), #1/1/1900#)
    qlfWedName = Nz(dlnInp("DE_QLF_WedDescription"))
    
    
    If (lenDateIsValid(qlfDatum)) And Nz(qlfPlaats <> "") Then
      maxUsedMeetInfoID = maxUsedMeetInfoID + 1
      If Not lenAppendLXMeetInfo(mtInf, maxUsedMeetInfoID, qlfBaan, qlfPlaats, qlfNation, qlfDatum, qlfWedName, qlfTime) Then Exit Function
      et("SYS_REF_MEETINFO") = maxUsedMeetInfoID
    End If
    
    
    If (dlnInp("INT_HAS_PLoegleden")) Then
      et("SYS_REF_RELAYPOSITIONS") = entryID
      If Not lenWriteSimpleCollection(relaypos, entryID, "RELAYPOSITION") Then Exit Function
    End If
      
    
    Dim collID As Long
    If (Nz(dlnInp("DE_IsEstaf"))) Then
      collID = 14 * Nz(dlnInp("DE_Ploeg_ID")) + 9
    Else
      collID = (2 * Nz(dlnInp("DE_Zwemmer_ID")))
    End If
    
    
    
    If Not lenAddToCollection(etColl, collID, entryID, "ENTRY") Then Exit Function
    
    
  
  et.Update


  dlnInp.MoveNext
Loop


appCleanRS dlnInp
appCleanRS etColl
appCleanRS et
appCleanRS mtInf
appCleanRS relaypos
appCleanRS skHeats
appCleanRS skPrWithHeat
appCleanRS rsHeat
appCleanRS rsHeatColl



lenWriteDeelnemersToXMLTables = True
Exit Function
fout:
If (Err = 3021) Then Resume Next
MsgBox Err & " " & Error$, 16

Exit Function

'debug
On Error GoTo 0
Resume


End Function

Private Function lenWritePloegenToXMLTables(ByVal wedDate As Date, ByVal lftBep As String) As Boolean
On Error GoTo fout
lenWritePloegenToXMLTables = False

Dim plInp As Recordset
Set plInp = CurrentDb().OpenRecordset("gIMP_LEN_PLOEG")

Dim rl As Recordset
Set rl = CurrentDb().OpenRecordset("LEN_RELAY")

Dim rlColl As Recordset
Set rlColl = CurrentDb().OpenRecordset("LEN_RELAY_COLL")

Dim results As Recordset
Set results = CurrentDb().OpenRecordset("LEN_RESULTS")
Dim entries As Recordset
Set entries = CurrentDb().OpenRecordset("LEN_ENTRIES")
Dim relaypos As Recordset
Set relaypos = CurrentDb().OpenRecordset("LEN_RELAYPOSITIONS")
Dim archivedTimes As Recordset
Set archivedTimes = CurrentDb().OpenRecordset("LEN_ARCHIVEDTIMES")


'have to set INT_HAS_ENTRIES and INT_HAS_RESULTS and INT_HAS_RELAYPOS and INT_HAS_ARCHIVEDTIMES
Dim updSQL As String
DoCmd.SetWarnings False


updSQL = "Update gIMP_LEN_ploeg set int_has_entries = false, int_has_results = false,  int_has_relaypos = false, int_has_archivedtimes = false"
DoCmd.RunSQL updSQL

updSQL = "UPDATE gIMP_LEN_Deelnemers INNER JOIN gIMP_LEN_Ploeg ON gIMP_LEN_Deelnemers.DE_Ploeg_ID = gIMP_LEN_Ploeg.PL_ID SET gIMP_LEN_Ploeg.INT_HAS_ENTRIES = True;"
DoCmd.RunSQL updSQL

updSQL = "UPDATE gIMP_LEN_Tijden INNER JOIN gIMP_LEN_Ploeg ON gIMP_LEN_Tijden.TY_Ploeg_ID = gIMP_LEN_Ploeg.PL_ID SET gIMP_LEN_Ploeg.INT_HAS_RESULTS = True;"
DoCmd.RunSQL updSQL

updSQL = "UPDATE gIMP_LEN_ArchiefTijden INNER JOIN gIMP_LEN_Ploeg ON gIMP_LEN_ArchiefTijden.TD_Ploeg_ID = gIMP_LEN_Ploeg.PL_ID SET gIMP_LEN_Ploeg.INT_HAS_ArchivedTimes = True;"
DoCmd.RunSQL updSQL

updSQL = "UPDATE gIMP_LEN_Ploegleden INNER JOIN gIMP_LEN_Ploeg ON gIMP_LEN_Ploegleden.PLL_Ploeg_ID = gIMP_LEN_Ploeg.PL_ID SET gIMP_LEN_Ploeg.INT_HAS_RELAYPOS = True;"
DoCmd.RunSQL updSQL






DoCmd.SetWarnings True



plInp.MoveFirst
Do Until plInp.EOF

  Dim plID As Long
  'ploeg ids are always UNEVEN and 2 mod 7
  plID = 14 * Nz(plInp("PL_ID")) + 9
  
  rl.AddNew
    rl("ID_RELAY") = plID
    
    
    Dim partOfRec As Boolean, partOfTimeArchive As Boolean
    partOfRec = Nz(plInp("PL_PartOfRecord"))
    partOfTimeArchive = Nz(plInp("PL_PartOfTimeArchive"))
    If (partOfRec) Then
      rl("SYS_REF_CLUB") = plInp("PL_VER_ID")
      If Nz(plInp("INT_HAS_RELAYPOS")) Then
        If Not lenWriteSimpleCollection(relaypos, plID, "RELAYPOSITION") Then Exit Function
        rl("SYS_REF_RELAYPOSITIONS") = plID
      Else
        rl("SYS_REF_RELAYPOSITIONS") = Null
      End If
      rl("SYS_REF_RESULTS") = Null
      rl("SYS_REF_ENTRIES") = Null
      rl("SYS_REF_ARCHIVEDTIMES") = Null
    Else
    
      'modification jan 2008: moved age processing part to here.
    
      If (Not partOfTimeArchive) Then
        Dim plSatCat As String
        Dim gender As String, minAge As Integer, maxAge As Integer, isTotAge As Boolean, name As String, isMCat As Boolean
      
        plSatCat = Nz(plInp("PL_SatisfiedCategorie"))
        If Not lenFormatCategorie(plSatCat, wedDate, lftBep, gender, minAge, maxAge, isTotAge, isMCat, True) Then
          Err.Raise 1, , "Ongeldige categorie: " + Trim(plSatCat)
          Exit Function
        End If
      
      
        If (isTotAge) Then
          rl("LEN_AGETOTALMAX") = hzn(lenFormatAge(maxAge))
          rl("LEN_AGETOTALMIN") = hzn(lenFormatAge(minAge))
          rl("LEN_AGEMIN") = hzn(lenFormatAge(-1))
          rl("LEN_AGEMAX") = hzn(lenFormatAge(-1))
        Else
          rl("LEN_AGEMIN") = hzn(lenFormatAge(minAge))
          rl("LEN_AGEMAX") = hzn(lenFormatAge(maxAge))
          rl("LEN_AGETOTALMAX") = hzn(lenFormatAge(-1))
          rl("LEN_AGETOTALMIN") = hzn(lenFormatAge(-1))
        End If
      End If
    
    
      Dim verID As Long
      verID = plInp("PL_VER_ID")
      
      If Not lenAddToCollection(rlColl, verID, plID, "RELAY") Then Exit Function
    
      rl("SYS_REF_CLUB") = Null
      
      
      rl("SYS_REF_RELAYPOSITIONS") = Null
      
      
      
      
      If (Nz(plInp("INT_HAS_RESULTS"))) Then
        If Not lenWriteSimpleCollection(results, plID, "RESULT") Then Exit Function
        rl("SYS_REF_RESULTS") = plID
      Else
        rl("SYS_REF_RESULTS") = Null
      End If
      If (Nz(plInp("INT_HAS_ENTRIES"))) Then
        If Not lenWriteSimpleCollection(entries, plID, "ENTRY", "ENTRIES") Then Exit Function
        rl("SYS_REF_ENTRIES") = plID
      Else
        rl("SYS_REF_ENTRIES") = Null
      End If
      
      
      If (Nz(plInp("INT_HAS_ARCHIVEDTIMES"))) Then
        If Not lenWriteSimpleCollection(archivedTimes, plID, "ARCHIVEDTIME") Then Exit Function
        rl("SYS_REF_ARCHIVEDTIMES") = plID
      Else
        rl("SYS_REF_ARCHIVEDTIMES") = Null
      End If
      
      'The following two are only allowed in MEET context
      If (Not partOfTimeArchive) Then
        rl("LEN_GENDER") = hzn(lenFormatGeslacht(Nz(plInp("PL_Geslacht")), True))
        rl("LEN_Number") = plInp("PL_Nummer")
      End If
    End If
    
    
    rl("LEN_Name") = plInp("PL_Naam")
    
    
    
  rl.Update
  

  plInp.MoveNext
Loop


appCleanRS plInp
appCleanRS rl
appCleanRS rlColl
appCleanRS results
appCleanRS entries
appCleanRS relaypos
appCleanRS archivedTimes



lenWritePloegenToXMLTables = True
Exit Function
fout:
If (Err = 3021) Then Resume Next
MsgBox Err & " " & Error$, 16

Exit Function

'debug
On Error GoTo 0
Resume

Exit Function
End Function

Private Function lenWritePloegledenToXMLTables(ByRef maxUsedMeetInfoXID As Long) As Boolean
On Error GoTo fout
lenWritePloegledenToXMLTables = False

Dim pllInp As Recordset
Set pllInp = CurrentDb().OpenRecordset("gIMP_LEN_Ploegleden")

Dim rp As Recordset
Set rp = CurrentDb().OpenRecordset("LEN_RELAYPOSITION")

Dim rpColl As Recordset
Set rpColl = CurrentDb().OpenRecordset("LEN_RELAYPOSITION_COLL")

Dim mtInf As Recordset
Set mtInf = CurrentDb().OpenRecordset("LEN_MEETINFO")



'Have to determine INT_ZWEMMER_LEN_ID from PLL_ZWEMMER_ID.
Dim updSQL As String

DoCmd.SetWarnings False

updSQL = "UPDATE gIMP_LEN_Ploegleden INNER JOIN gIMP_LEN_Zwemmers ON gIMP_LEN_Ploegleden.PLL_Zwemmer_ID = gIMP_LEN_Zwemmers.ZW_ID SET gIMP_LEN_Ploegleden.INT_Zwemmer_Len_ID = [int_len_id];"
DoCmd.RunSQL updSQL

DoCmd.SetWarnings True

pllInp.MoveFirst
Do Until pllInp.EOF
  rp.AddNew
  
    Dim recID As Long
    Dim tdID As Long
    Dim dlnID As Long
    Dim tmaID As Long
    
    recID = Nz(pllInp("PLL_Record_ID"), -1)
    tdID = Nz(pllInp("PLL_TIJD_ID"), -1)
    dlnID = Nz(pllInp("PLL_Deelnemer_ID"), -1)
    tmaID = Nz(pllInp("PLL_TMA_TIJD_ID"), -1)
       
    Dim pllID As Long
    pllID = Nz(pllInp("PLL_ID"), -1)
    
    
    Dim plID As Long
    plID = Nz(pllInp("PLL_Ploeg_ID"))
    
    rp("ID_RelayPosition") = pllID
    
    Dim isRec As Boolean, isTd As Boolean, isDln As Boolean, isTMA As Boolean
    isRec = recID <> -1
    isTd = tdID <> -1
    isDln = dlnID <> -1
    isTMA = tmaID <> -1
    
    
    Dim collID As Long
    
    
    If (isRec) Then
       'remember that athlete id's are always even.
       rp("SYS_REF_ATHLETE") = 2 * Nz(pllInp("PLL_Zwemmer_ID"))
       collID = 14 * plID + 9
    Else
       rp("SYS_REF_ATHLETE") = Null
       rp("LEN_ATHLETEID") = Nz(pllInp("INT_ZWEMMER_LEN_ID"))
       If (isTd) Then
         collID = 7 * tdID + 1
       ElseIf (isDln) Then
         collID = 7 * dlnID
       ElseIf (isTMA) Then
          collID = 7 * tmaID + 3
       End If
    End If
    
    If (Not lenAddToCollection(rpColl, collID, pllID, "RELAYPOSITION")) Then Exit Function
        
    
    Dim isRes As Boolean
    isRes = Nz(pllInp("PLL_Reserve"))
    
    rp("LEN_DSQCODE") = pllInp("PLL_DIS")
    rp("LEN_NUMBER") = IIf(isRes, -1, pllInp("PLL_Volgorde"))
    
    Dim sStatus As String
    sStatus = lenFormatDiscode(Nz(pllInp("PLL_DIS")))
    If (sStatus <> "DSQ" And sStatus <> "DNF") Then
      sStatus = ""
    End If
    
    rp("LEN_STATUS") = hzn(sStatus)
        
    
    Dim qlfTime As Double
    Dim qlfBaan As Integer
    Dim qlfDatum As Date
    Dim qlfPlaats As String
    Dim qlfNation As String
    Dim qlfWedName As String
    
    qlfTime = Nz(pllInp("PLL_QLF_Tijd"))
    qlfBaan = Nz(pllInp("PLL_QLF_Baan"))
    qlfDatum = Nz(pllInp("PLL_QLF_Datum"), #1/1/1900#)
    qlfPlaats = Nz(pllInp("PLL_QLF_Plaats"))
    qlfNation = Nz(pllInp("PLL_QLF_Land"))
    qlfWedName = Nz(pllInp("PLL_QLF_WedDescription"))
    
    If (swtIsValid(qlfTime)) Then
    
    
    
      If (lenDateIsValid(qlfDatum)) And Nz(qlfPlaats <> "") Then
        maxUsedMeetInfoXID = maxUsedMeetInfoXID + 1
        If Not lenAppendLXMeetInfo(mtInf, maxUsedMeetInfoXID, qlfBaan, qlfPlaats, qlfNation, qlfDatum, qlfWedName, qlfTime) Then
          Exit Function
        End If
        rp("SYS_REF_MEETINFO") = maxUsedMeetInfoXID
      End If
      
      
      'Do not use this hup_* fields anymore
      'rp("LEN_hup_entrytime") = hzn(lenFormatSwimTime(qlfTime))
      'If lenDateIsValid(qlfDatum) Then
      '  rp("LEN_hup_entrytimedate") = hzn(lenFormatDate(qlfDatum))
      '  rp("LEN_hup_entrytimecity") = hzn(qlfPlaats)
      '  rp("LEN_hup_entrytimecourse") = hzn(lenFormatBaanlengte(qlfBaan))
      '  rp("LEN_hup_entrytimenation") = hzn(qlfLand)
      'End If
    End If

  
  rp.Update


  pllInp.MoveNext
Loop


appCleanRS pllInp
appCleanRS rp
appCleanRS rpColl
appCleanRS mtInf


lenWritePloegledenToXMLTables = True
Exit Function
fout:
If (Err = 3021) Then Resume Next

MsgBox Err & " " & Error$, 16

Exit Function

'debug
On Error GoTo 0
Resume

Exit Function

End Function


Private Function lenWriteArchivedTimesToXMLTables(ByRef maxUsedMeetInfoXID As Long, ByRef maxUsedSwimstyleXID As Long) As Boolean
On Error GoTo fout
lenWriteArchivedTimesToXMLTables = False

Dim atmInp As Recordset
Set atmInp = CurrentDb().OpenRecordset("gIMP_LEN_ArchiefTijden")

Dim atmColl As Recordset
Set atmColl = CurrentDb().OpenRecordset("LEN_ARCHIVEDTIME_COLL")


Dim atm As Recordset
Set atm = CurrentDb().OpenRecordset("LEN_ARCHIVEDTIME")

Dim mtInf As Recordset
Set mtInf = CurrentDb().OpenRecordset("LEN_MEETINFO")

Dim swst As Recordset
Set swst = CurrentDb().OpenRecordset("LEN_SWIMSTYLE")

Dim relaypos As Recordset
Set relaypos = CurrentDb().OpenRecordset("LEN_RELAYPOSITIONS")


Dim skWed As Recordset
Set skWed = CurrentDb().OpenRecordset("gIMP_LEN_Wedstrijden")
skWed.Index = "PrimaryKey"

'Have to update INT_HAS_Ploegleden
DoCmd.SetWarnings False

Dim updSQL As String
updSQL = "update gIMP_LEN_ArchiefTijden set int_has_ploegleden = false"
DoCmd.RunSQL updSQL

updSQL = "UPDATE gIMP_LEN_Ploegleden INNER JOIN gIMP_LEN_ArchiefTijden ON gIMP_LEN_Ploegleden.PLL_TMA_Tijd_ID = " & _
"gIMP_LEN_ArchiefTijden.TD_ID SET gIMP_LEN_ArchiefTijden.INT_HAS_Ploegleden = True;"
DoCmd.RunSQL updSQL

DoCmd.SetWarnings True




atmInp.MoveFirst
Do Until atmInp.EOF
  atm.AddNew
    Dim atmXID As Long
    
    ' all tam xids are 3 mod 7 , in order to account for relay positions.
    atmXID = 7 * Nz(atmInp("TD_ID")) + 3
    
    atm("ID_ArchivedTime") = atmXID
    
    atm("LEN_Swimtime") = hzn(lenFormatSwimTime(Nz(atmInp("TD_Tijd"))))
    atm("LEN_dsqcode") = atmInp("TD_Dis")
    
    atm("LEN_IsSplitTime") = lenFormatBoolean(Nz(atmInp("TD_IsTusTijd"), False))
    
    atm("LEN_Comment") = atmInp("TD_Opm")
    
    Dim tpSlag As String, tpAf As String
    tpSlag = Nz(atmInp("TD_Slag"))
    tpAf = Nz(atmInp("TD_Afstand"))
    
    Dim tpSwstXID As Long
    maxUsedSwimstyleXID = maxUsedSwimstyleXID + 1
    tpSwstXID = maxUsedSwimstyleXID
    
    If Not lenAppendLXSwimStyle(swst, tpSwstXID, tpAf, tpSlag, "") Then
      Exit Function
    End If
    
    atm("SYS_REF_SWIMSTYLE") = tpSwstXID
    
    
    
    
    Dim tpWedID As Long
    tpWedID = Nz(atmInp("TD_WED_ID"))
    
    Dim tpTdBaan As Integer, tpTdPlaats As String, tpTdNation As String, tpTdDatum As Date, tpTdWedDes As String
    tpTdBaan = 25
    tpTdPlaats = ""
    tpTdNation = "NED"
    tpTdDatum = #1/1/1900#
    
    skWed.Seek "=", tpWedID
    If Not skWed.NoMatch Then
      tpTdBaan = Nz(skWed("WE_Baanlengte"), 25)
      tpTdPlaats = Nz(skWed("WE_Plaats"))
      tpTdDatum = Nz(skWed("WE_Datum"), #1/1/1900#)
      tpTdWedDes = Nz(skWed("WE_Beschrijving"))
      tpTdNation = Nz(skWed("WE_Nation"))
    End If
    
    
    If (lenDateIsValid(tpTdDatum)) And (tpTdPlaats <> "") Then
      Dim tpMtInfXID As Long
      maxUsedMeetInfoXID = maxUsedMeetInfoXID + 1
      tpMtInfXID = maxUsedMeetInfoXID
       
      If Not lenAppendLXMeetInfo(mtInf, tpMtInfXID, tpTdBaan, tpTdPlaats, tpTdNation, tpTdDatum, tpTdWedDes, 0) Then Exit Function
      atm("SYS_REF_MEETINFO") = tpMtInfXID
    End If
    
    
    atm("SYS_REF_RELAYPOSITIONS") = Null
   
   
    Dim collID As Long
    If (Nz(atmInp("TD_IsEstaf"))) Then
      collID = 14 * Nz(atmInp("TD_Ploeg_ID")) + 9
      If Nz(atmInp("INT_HAS_PLOEGLEDEN")) Then
        atm("SYS_REF_RELAYPOSITIONS") = atmXID
        If Not lenWriteSimpleCollection(relaypos, atmXID, "RELAYPOSITION") Then Exit Function
      End If
    Else
      collID = (2 * Nz(atmInp("TD_Zwemmer_ID")))
    End If
    
    
    
    If Not lenAddToCollection(atmColl, collID, atmXID, "ARCHIVEDTIME") Then Exit Function
    
    
  
  atm.Update


  atmInp.MoveNext
Loop


appCleanRS atmInp
appCleanRS atmColl
appCleanRS atm
appCleanRS mtInf
appCleanRS swst
appCleanRS skWed
appCleanRS relaypos


lenWriteArchivedTimesToXMLTables = True
Exit Function
fout:
If (Err = 3021) Then Resume Next

DoCmd.SetWarnings True
MsgBox Err & " lenWriteArchivedTimesToXMLTables" & vbCrLf & Error$, 16

Exit Function

'debug
On Error GoTo 0
Resume


End Function





Private Function lenAppendRanking(ByRef skAgWithRnk As Recordset, ByRef rsRanking As Recordset, ByRef rsRankColl As Recordset, ByVal agXID As Long, ByVal lLenResultID As Long, ByVal lPlace As Long, ByRef maxUsedRankingXID As Long) As Boolean
On Error GoTo fout
lenAppendRanking = False

'output the fact that agXID has a ranking to rsRnkTpInf and output the ranking.
skAgWithRnk.Seek "=", agXID

If (skAgWithRnk.NoMatch) Then
  skAgWithRnk.AddNew
    skAgWithRnk("AWR_AG_XID") = agXID
  skAgWithRnk.Update
End If

maxUsedRankingXID = maxUsedRankingXID + 1
rsRanking.AddNew
  rsRanking("ID_Ranking") = maxUsedRankingXID
  rsRanking("LEN_Place") = lPlace
  rsRanking("LEN_ResultID") = lLenResultID
rsRanking.Update

If Not lenAddToCollection(rsRankColl, agXID, maxUsedRankingXID, "RANKING") Then
  Exit Function
End If


lenAppendRanking = True
Exit Function
fout:
MsgBox Err & " lenAppendRanking" & vbCrLf & Error$, 16
Exit Function
End Function

Private Function lenWriteTijdenToXMLTables(ByVal lxVersion As Long, ByRef maxUsedSplitXID As Long, ByRef maxUsedHeatXID As Long) As Boolean
On Error GoTo fout
lenWriteTijdenToXMLTables = True

Dim tdInp As Recordset
Set tdInp = CurrentDb().OpenRecordset("gIMP_LEN_TIJDEN")

Dim rs As Recordset
Set rs = CurrentDb().OpenRecordset("LEN_RESULT")

Dim relaypos As Recordset
Set relaypos = CurrentDb().OpenRecordset("LEN_RELAYPOSITIONS")

Dim rsColl As Recordset
Set rsColl = CurrentDb().OpenRecordset("LEN_RESULT_COLL")

Dim sp As Recordset
Set sp = CurrentDb().OpenRecordset("LEN_SPLIT")

Dim spColl As Recordset
Set spColl = CurrentDb().OpenRecordset("LEN_SPLIT_COLL")

Dim sps As Recordset
Set sps = CurrentDb().OpenRecordset("LEN_SPLITS")



Dim skHeats As Recordset
Set skHeats = Nothing

If (lxVersion >= LX_VERSION_3) Then
  Set skHeats = CurrentDb().OpenRecordset("~len_write_heats")
  skHeats.Index = "PrimaryKey"
End If

Dim skPrWithHeat As Recordset
Set skPrWithHeat = Nothing

If (lxVersion >= LX_VERSION_3) Then
  Set skPrWithHeat = CurrentDb().OpenRecordset("~len_progs_with_heats")
  skPrWithHeat.Index = "PrimaryKey"
End If

Dim rsHeat As Recordset
Set rsHeat = CurrentDb().OpenRecordset("LEN_HEAT")


Dim rsHeatColl As Recordset
Set rsHeatColl = CurrentDb().OpenRecordset("LEN_HEAT_COLL")



Dim skAgWithRnk As Recordset
Set skAgWithRnk = Nothing

If (lxVersion >= LX_VERSION_3) Then
  Set skAgWithRnk = CurrentDb().OpenRecordset("~len_ag_with_rankings")
  skAgWithRnk.Index = "PrimaryKey"
End If

Dim rsRnk As Recordset
Set rsRnk = CurrentDb().OpenRecordset("LEN_Ranking")

Dim rsRnkColl As Recordset
Set rsRnkColl = CurrentDb().OpenRecordset("LEN_RANKING_COLL")



Dim maxUsedRnkXID As Long
maxUsedRnkXID = 0




'Have to update INT_PROG_LEN_ID, INT_HAS_Ploegleden and INT_AGEGROUP_LEN_ID

DoCmd.SetWarnings False
Dim updSQL As String
updSQL = "update gIMP_LEN_tijden set int_has_ploegleden = false"
DoCmd.RunSQL updSQL

updSQL = "UPDATE gIMP_LEN_tijden INNER JOIN gIMP_LEN_Programma ON gIMP_LEN_tijden.TY_PROG_ID = gIMP_LEN_Programma.PR_ID SET " & _
"gIMP_LEN_Tijden.INT_PROG_LEN_ID = [INT_len_id];"
DoCmd.RunSQL updSQL

updSQL = "UPDATE gIMP_LEN_TIJDEN INNER JOIN gIMP_LEN_Leeftijdsgroepen ON gIMP_LEN_TIJDEN.TY_Agegroup_ID = " & _
"gIMP_LEN_Leeftijdsgroepen.LF_ID SET gIMP_LEN_TIJDEN.INT_Agegroup_LEN_ID = [INT_len_id];"
DoCmd.RunSQL updSQL



updSQL = "UPDATE gIMP_LEN_Ploegleden INNER JOIN gIMP_LEN_TIJDEN ON gIMP_LEN_Ploegleden.PLL_Tijd_ID = " & _
"gIMP_LEN_Tijden.TY_ID SET gIMP_LEN_TIJDEN.INT_HAS_Ploegleden = True;"
DoCmd.RunSQL updSQL

DoCmd.SetWarnings True

tdInp.MoveFirst
Do Until tdInp.EOF

  Dim tdXID As Long
  'Time ids are always 1 mod 7, so as to avoid confusions with relaypositions sub object.
  tdXID = 7 * Nz(tdInp("TY_ID")) + 1
  
  rs.AddNew
  
    rs("ID_Result") = tdXID
    rs("LEN_ResultID") = tdXID
    rs("LEN_AGEGROUPID") = tdInp("INT_AGEGROUP_LEN_ID")
    rs("LEN_COMMENT") = tdInp("TY_Opm")
    rs("LEN_DSQCODE") = tdInp("TY_DIS")
    
    
    rs("LEN_STATUS") = Null
    rs("LEN_NONCOMP") = Null
    
    If (Nz(tdInp("TY_DIS")) <> "") Then
      rs("LEN_STATUS") = hzn(lenFormatDiscode(Nz(tdInp("TY_DIS"))))
    ElseIf Nz(tdInp("TY_BM"), False) Then
      rs("LEN_STATUS") = hzn(LX_STATUS_EXH)
    End If
    
    If Nz(tdInp("TY_BM"), False) Then
      rs("LEN_NONCOMP") = hzn(lenFormatBoolean(True))
    End If
   
    rs("LEN_EventID") = tdInp("INT_PROG_LEN_ID")
   
   
   
   
    Dim sr As Long, bn As Integer
    sr = Nz(tdInp("TY_Serienummer"))
    bn = Nz(tdInp("TY_Baan"))
    
    
    
    If (lxVersion >= LX_VERSION_3) Then
      rs("LEN_HEATID") = Null
      If (sr > 0) Then
        Dim lHtLenID As Long
        rs("LEN_HEATID") = sr
        If Not lenAppendHeat(skHeats, skPrWithHeat, rsHeat, rsHeatColl, maxUsedHeatXID, Nz(tdInp("TY_PROG_ID")), sr, lHtLenID) Then
          Exit Function
        End If
        If (lHtLenID > 0) Then
          rs("LEN_HeatID") = lHtLenID
        End If
      End If
      rs("LEN_LANE") = IIf(bn = 0, Null, bn)
    End If
   
   
       
   
   
   
   
   
   Dim pl As Long
   pl = Nz(tdInp("TY_Eindplaats"))
   
   Dim blIsPlValid As Boolean
   blIsPlValid = False
   
     
   If (pl <= 0) Or (pl > 10000) Then
     rs("LEN_Place") = "-1"
   Else
     rs("LEN_PLACE") = pl
     blIsPlValid = True
   End If
   
   If blIsPlValid And (lxVersion >= LX_VERSION_3) Then
     'need to add separate object for ranking
     Dim tpAgeGroupID As Long
     tpAgeGroupID = Nz(tdInp("TY_Agegroup_ID"), -1)
     
     Dim tpCorrAgXID As Long
     tpCorrAgXID = 3 * Nz(tdInp("TY_PROG_ID"))
     
     'Need to determine the actual id of the agegroup
     If (tpAgeGroupID <> -1) Then
       tpCorrAgXID = 3 * tpAgeGroupID + 1
     End If
     
     
     
     If Not lenAppendRanking(skAgWithRnk, rsRnk, rsRnkColl, tpCorrAgXID, tdXID, pl, maxUsedRnkXID) Then
       Exit Function
     End If
     
     
     
   End If
   

  
   
   Dim isEstaf As Boolean
   isEstaf = Nz(tdInp("TY_IsEstaf"))
   rs("SYS_REF_RELAYPOSITIONS") = Null
   
   
   Dim collID As Long
   If (isEstaf) Then
     collID = 14 * Nz(tdInp("TY_Ploeg_ID")) + 9
     If Nz(tdInp("INT_HAS_PLOEGLEDEN")) Then
       rs("SYS_REF_RELAYPOSITIONS") = tdXID
       If Not lenWriteSimpleCollection(relaypos, tdXID, "RELAYPOSITION") Then Exit Function
     End If
   Else
     collID = 2 * Nz(tdInp("TY_Zwemmer_ID"))
   End If
   
   If Not lenAddToCollection(rsColl, collID, tdXID, "RESULT") Then Exit Function
   
   rs("LEN_SWIMTIME") = hzn(lenFormatSwimTime(Nz(tdInp("TY_Eindtijd"))))
   rs("LEN_TIMESUFFIX") = tdInp("TY_AB")
   
   'Nu tussentijden afhandelen.
   
   
   Dim tstAf(0 To MAX_N_TUSSENTIJDEN) As Integer
   Dim tstTd(0 To MAX_N_TUSSENTIJDEN) As Double
   Dim tstCnt As Integer
   
   tstCnt = 0
   If Not (tstExtractTussenTijden(Nz(tdInp("TY_ExtraTussentijden")), tstCnt, tstAf, tstTd)) Then
      Exit Function
   End If
   
   'have to add main tussentijden.
   Dim tpTstI As Integer
   For tpTstI = 1 To 4
     Dim tpTstAf As Integer
     Dim tpTstTd As Double
     tpTstAf = CInt(val(Nz(tdInp("TY_Afstand" & tpTstI))))
     tpTstTd = Nz(tdInp("TY_Tijd" & tpTstI))
     If (tpTstTd > 0.01) Then
       If (tpTstAf > 0) Then
         If Not tstSetTussenTijd(tpTstAf, tpTstTd, tstCnt, tstAf, tstTd) Then
           Exit Function
         End If
       End If
     End If
   Next tpTstI
   
   If tstCnt > 0 Then
     'need to append splits
     If (Not lenWriteSimpleCollection(sps, tdXID, "SPLIT")) Then Exit Function
     rs("SYS_REF_SPLITS") = tdXID
     
     For tpTstI = 0 To tstCnt - 1
       maxUsedSplitXID = maxUsedSplitXID + 1
       If Not lenAppendLXSplit(sp, maxUsedSplitXID, tstAf(tpTstI), tstTd(tpTstI)) Then Exit Function
       If Not lenAddToCollection(spColl, tdXID, maxUsedSplitXID, "SPLIT") Then Exit Function
     Next tpTstI
     
    End If
   
   
     
  
  rs.Update
  



  tdInp.MoveNext
Loop




appCleanRS tdInp
appCleanRS rs
appCleanRS relaypos
appCleanRS rsColl
appCleanRS sp
appCleanRS spColl
appCleanRS sps
appCleanRS skHeats
appCleanRS skPrWithHeat
appCleanRS rsHeat
appCleanRS rsHeatColl
appCleanRS skAgWithRnk
appCleanRS rsRnk
appCleanRS rsRnkColl

lenWriteTijdenToXMLTables = True
Exit Function
fout:
If (Err = 3021) Then Resume Next
MsgBox Err & " " & Error$, 16

Exit Function

'debug
On Error GoTo 0
Resume

Exit Function


End Function


Private Function lenExtractInitials(ByVal firstName As String) As String
lenExtractInitials = ""

While Len(firstName) > 0
  Dim tokPoint As String
  tokPoint = extractToken(firstName, ".")
  
  While (Len(tokPoint) > 0)
    Dim tokSpace As String
    tokSpace = extractToken(tokPoint, " ")
    If (Len(tokSpace) > 0) Then
      lenExtractInitials = lenExtractInitials & Left(tokSpace, 1) & "."
    End If
  Wend
Wend


Exit Function
End Function



Private Function lenReadOfficialsFromXMLTables(ByRef maxUsedContID As Long) As Boolean
On Error GoTo fout
lenReadOfficialsFromXMLTables = False


Dim offSQL As String
offSQL = "SELECT LEN_OFFICIAL.*, LEN_CLUB.ID_CLUB " & _
          "FROM ((LEN_OFFICIALS LEFT JOIN LEN_CLUB ON LEN_OFFICIALS.ID_OFFICIALS = LEN_CLUB.SYS_REF_OFFICIALS) " & _
          "RIGHT JOIN LEN_OFFICIAL_COLL ON LEN_OFFICIALS.SYS_REF_OFFICIAL_COLL = LEN_OFFICIAL_COLL.ID_OFFICIAL_COLL) " & _
          "RIGHT JOIN LEN_OFFICIAL ON LEN_OFFICIAL_COLL.SYS_REF_CH_OFFICIAL = LEN_OFFICIAL.ID_OFFICIAL;"
          
Dim offs As Recordset
Set offs = CurrentDb().OpenRecordset(offSQL)


Dim ssCont As Recordset
Set ssCont = CurrentDb().OpenRecordset("LEN_CONTACT")
ssCont.Index = "P"

Dim cntOutp As Recordset
Set cntOutp = CurrentDb().OpenRecordset("gIMP_LEN_CONTACT")





Dim offOutp As Recordset
Set offOutp = CurrentDb().OpenRecordset("gIMP_LEN_OFFICIALS")


offs.MoveFirst
Do Until offs.EOF
  offOutp.AddNew
  
    offOutp("OFF_ID") = offs("ID_OFFICIAL")
    
    offOutp("OFF_LEN_ID") = offs("LEN_OFFICIALID")
    
    offOutp("OFF_SPORTLINK_ID") = offs("LEN_SPORTLINKID")
    
    Dim verID As Long
    
    verID = Nz(offs("ID_CLUB"), -1)
    If (verID <> -1) Then
      offOutp("OFF_VER_ID") = verID
    End If
    
    
    
    
    Dim tpContID As Long
    tpContID = Nz(offs("SYS_REF_CONTACT"), -1)
       
    If (tpContID >= 0) Then
      Dim contInf As CONTACT_INFO
       
      If Not lenLoadLXContact(ssCont, tpContID, contInf) Then
        Exit Function
      End If
     
     
      maxUsedContID = maxUsedContID + 1
      If Not lenAppendContact(cntOutp, maxUsedContID, contInf) Then
        Exit Function
      End If
      
      offOutp("OFF_Contact_ID") = maxUsedContID
   
    End If
     
     
    
    
    Dim firstName As String
    firstName = Nz(offs("LEN_FIRSTNAME"))
    
    Dim initials As String
    initials = lenExtractInitials(firstName)
    
    offOutp("OFF_Voorletters") = hzn(initials)
    
    offOutp("OFF_Voorvoegsel") = offs("LEN_NAMEPREFIX")
    offOutp("OFF_Achternaam") = offs("LEN_LASTNAME")
    
    Dim ges As String
    ges = lenParseGender(Nz(offs("LEN_GENDER")))
    
    Dim hrMw As String
    
    If (ges = "M") Then
      hrMw = "Hr"
    Else
      hrMw = "Mw"
    End If
    
    offOutp("OFF_Hr/Mw") = hrMw
    
    offOutp("OFF_FlatClubCode") = offs("LEN_Code")
    
    offOutp("OFF_Bevoegdheid") = offs("LEN_GRADE")
    
    
    
   
  offOutp.Update
  offs.MoveNext
Loop


appCleanRS offs
appCleanRS ssCont
appCleanRS cntOutp
appCleanRS offOutp



lenReadOfficialsFromXMLTables = True
Exit Function
fout:
If (Err = 3021) Then Resume Next

MsgBox Err & " lenReadOfficialsFromXMLTables" & vbCrLf & Error$, 16

Exit Function

'debug
On Error GoTo 0
Resume

End Function






Private Function lenReadFromXMLTables(blReadOfficials As Boolean) As Boolean
On Error GoTo fout

lenReadFromXMLTables = False




Dim lftBep As String
Dim wedDate As Date
Dim wedAgeDate As Date

Dim glbBaanLengte As Integer

If Not lenPrepareReadFromXMLTables() Then
  Exit Function
End If

Dim sLenexVersion As String
sLenexVersion = Nz(DLookup("LEN_VERSION", "LEN_LENEX"))

Dim lxVersion As Long

Select Case sLenexVersion
  Case "3.0"
    lxVersion = LX_VERSION_3
  Case Else
    lxVersion = LX_VERSION_2
End Select




Dim maxUsedContID As Long
maxUsedContID = 0

Dim maxUsedWedID As Long
maxUsedWedID = 0

If Not lenReadSessionsFromXMLTables(lxVersion, wedDate, wedAgeDate, lftBep, glbBaanLengte, maxUsedWedID, maxUsedContID) Then
  Exit Function
End If

Dim currencyStr As String



If Not lenReadLimietenFromXMLTables(lxVersion, wedAgeDate, lftBep) Then
  Exit Function
End If




'lenReadClubsFromXMLTables must be called  before lenReadAthletesFromXMLTables and lenReadRelayTeamsFromXMLTables
If Not lenReadClubsFromXMLTables(maxUsedContID) Then
  Exit Function
End If

If Not lenReadAthletesFromXMLTables() Then
  Exit Function
End If

If Not lenReadRelayTeamsFromXMLTables() Then
  Exit Function
End If

Dim recAgeMode As String
recAgeMode = ""

If Not lenReadRecordsFromXMLTables(lxVersion, wedAgeDate, recAgeMode) Then
  Exit Function
End If


If Not lenReadProgrammaFromXMLTables(lxVersion, wedAgeDate, lftBep, recAgeMode, currencyStr, glbBaanLengte) Then
  Exit Function
End If

If Not lenReadRelaySwimmersFromXMLTables() Then
  Exit Function
End If

Dim skHeat As Recordset
Set skHeat = Nothing
If (lxVersion >= LX_VERSION_3) Then
  If Not lenReadHeatsFromXMLTables_fillIDTable() Then
    Exit Function
  End If
  Set skHeat = CurrentDb().OpenRecordset("~len_read_heats_id")
  skHeat.Index = "PrimaryKey"
 
End If


If Not lenReadDeelnemersFromXMLTables(lxVersion, skHeat) Then
  Exit Function
End If

If Not lenReadTijdenFromXMLTables(lxVersion, skHeat) Then
  Exit Function
End If


If (blReadOfficials) Then
  If Not lenReadOfficialsFromXMLTables(maxUsedContID) Then
    Exit Function
  End If
End If

If Not lenReadArchivedTimesFromXMLTables(maxUsedWedID) Then
  Exit Function
End If


appCleanRS skHeat
If Not lenReadHeatsFromXMLTables_cleanTmpTable() Then
  Exit Function
End If
  


lenReadFromXMLTables = True
Exit Function
fout:
MsgBox Err & " lenReadFromXMLTables" & vbCrLf & Error$, 16
Exit Function
End Function


Private Function lenWriteLenexHeader(ByVal lxVersion As Long, ByVal constructorContID As Long) As Boolean
On Error GoTo fout
lenWriteLenexHeader = False


Dim hasMeets As Boolean
Dim hasRecordLists As Boolean
Dim hasTimeStandardLists As Boolean
Dim hasTimeArchive As Boolean

Dim mts As Recordset
Set mts = CurrentDb().OpenRecordset("LEN_MEETS")

Dim recs As Recordset
Set recs = CurrentDb().OpenRecordset("LEN_RECORDLISTS")

Dim limS As Recordset
Set limS = CurrentDb().OpenRecordset("LEN_TIMESTANDARDLISTS")

Dim cst As Recordset
Set cst = CurrentDb().OpenRecordset("LEN_CONSTRUCTOR")



hasMeets = (Nz(DCount("WE_ID", "gIMP_LEN_WEDSTRIJDEN", "(not nz([we_partOfTimeArchive], false))")) > 0)
hasRecordLists = (Nz(DCount("REC_ID", "gIMP_LEN_RECORDS")) > 0)
hasTimeStandardLists = (Nz(DCount("LIM_ID", "gIMP_LEN_LIMIETEN")) > 0)
hasTimeArchive = (Nz(DCount("V_ID", "gIMP_LEN_Ver", "nz([v_partOfTimeArchive],false)")) > 0)


Dim lx As Recordset
Set lx = CurrentDb().OpenRecordset("LEN_LENEX")

lx.AddNew
  If (hasMeets) Then
    lx("SYS_REF_MEETS") = 1
    If Not lenWriteSimpleCollection(mts, 1, "MEET") Then Exit Function
  Else
    lx("SYS_REF_MEETS") = Null
  End If
  
  If (hasRecordLists) Then
    lx("SYS_REF_RECORDLISTS") = 1
    If Not lenWriteSimpleCollection(recs, 1, "RECORDLIST") Then Exit Function
  Else
    lx("SYS_REF_RECORDLISTS") = Null
  End If
  
  If (hasTimeStandardLists) Then
    If Not lenWriteSimpleCollection(limS, 1, "TIMESTANDARDLIST") Then Exit Function
    lx("SYS_REF_TIMESTANDARDLISTS") = 1
  Else
    lx("SYS_REF_TIMESTANDARDLISTS") = Null
  End If
  
  If (hasTimeArchive) Then
    lx("SYS_REF_TIMEARCHIVE") = 1
    Dim rsTMA As Recordset
    Set rsTMA = CurrentDb().OpenRecordset("LEN_TIMEARCHIVE")
    rsTMA.AddNew
      rsTMA("ID_TIMEARCHIVE") = 1
      rsTMA("SYS_REF_CLUBS") = 2
    rsTMA.Update
    appCleanRS rsTMA
  Else
    lx("SYS_REF_TIMEARCHIVE") = Null
  End If
  
  lx("SYS_REF_CONSTRUCTOR") = 1
  'now have to write constructor.
  cst.AddNew
    cst("ID_CONSTRUCTOR") = 1
    cst("SYS_REF_CONTACT") = constructorContID
    cst("LEN_NAME") = hzn(licentie_appName())
    cst("LEN_Version") = hzn(licentie_versie())
  cst.Update
  
  lx("ID_LENEX") = 1
  
  
  Select Case lxVersion
    Case LX_VERSION_2
      lx("LEN_VERSION") = "2.0"
    Case LX_VERSION_3
      lx("LEN_VERSION") = "3.0"
    Case Else
      Err.Raise 1, , "Ongeldige lenex versie geselecteerd."
  End Select
   


lx.Update




appCleanRS lx
appCleanRS mts
appCleanRS recs
appCleanRS limS
appCleanRS cst



lenWriteLenexHeader = True
Exit Function
fout:
If (Err = 3021) Then Resume Next
MsgBox Err & " " & Error$, 16

Exit Function

'debug
On Error GoTo 0
Resume

Exit Function


End Function




Private Function lenWriteTimestandardsToXMLTables(ByVal lxVersion As Long, ByVal wedDate As Date, ByVal lftBep As String, ByRef maxUsedAGID As Long, maxUsedSWSTID As Long) As Boolean
On Error GoTo fout
lenWriteTimestandardsToXMLTables = False


Dim skTStdRefs As Recordset
Set skTStdRefs = Nothing

If (lxVersion >= LX_VERSION_3) Then
  Set skTStdRefs = CurrentDb().OpenRecordset("~len_write_time_std_refs")
  skTStdRefs.Index = "PrimaryKey"
End If


Dim skPrWithTStdRef As Recordset
Set skPrWithTStdRef = Nothing

If (lxVersion >= LX_VERSION_3) Then
  Set skPrWithTStdRef = CurrentDb().OpenRecordset("~len_progs_with_time_std_refs")
  skPrWithTStdRef.Index = "PrimaryKey"
End If

Dim rsTStdRef As Recordset
Set rsTStdRef = CurrentDb().OpenRecordset("LEN_TIMESTANDARDREF")

Dim rsTStdRefColl As Recordset
Set rsTStdRefColl = CurrentDb().OpenRecordset("LEN_TIMESTANDARDREF_COLL")



Dim maxUsedTStdRefXID As Long
maxUsedTStdRefXID = 0





Dim curIsVVT As Boolean
Dim curIsMinLim As Boolean
Dim curIsMaxLim As Boolean
Dim curBaan As Integer
Dim curCat As String
Dim curName As String

curBaan = -1
curIsVVT = False
curIsMinLim = False
curIsMaxLim = False
curCat = ""
curName = ""

Dim inp As Recordset
Set inp = CurrentDb().OpenRecordset("Select * from gIMP_LEN_limieten where nz([lim_tijd]) > 0.01 order by lim_isVVT, lim_isMinLim, lim_isMaxLim, lim_baan, lim_categorie, lim_name;", dbOpenDynaset)

inp.MoveFirst

Dim maxUsedListID As Long
maxUsedListID = 0

Dim muTStdRefXID As Long
muTStdRefXID = 0


Dim listColl As Recordset
Set listColl = CurrentDb().OpenRecordset("LEN_TIMESTANDARDLIST_COLL")
Dim lst As Recordset
Set lst = CurrentDb().OpenRecordset("LEN_TIMESTANDARDLIST")
Dim stds As Recordset
Set stds = CurrentDb().OpenRecordset("LEN_TIMESTANDARDS")
Dim stdColl As Recordset
Set stdColl = CurrentDb().OpenRecordset("LEN_TIMESTANDARD_COLL")
Dim std As Recordset
Set std = CurrentDb().OpenRecordset("LEN_TIMESTANDARD")

Dim ag As Recordset
Set ag = CurrentDb().OpenRecordset("LEN_AGEGROUP")

Dim swst As Recordset
Set swst = CurrentDb().OpenRecordset("LEN_SWIMSTYLE")

Do Until inp.EOF
  Dim tpIsVVT As Boolean, tpIsMinLim As Boolean, tpIsMaxLim As Boolean, tpBaan As Integer, tpCat As String, tpName As String
  Dim curListID As Long
  
  Dim curListLenID As Long
  
  
  tpIsVVT = Nz(inp("LIM_IsVVT"))
  tpIsMinLim = Nz(inp("LIM_IsMinLim"))
  tpIsMaxLim = Nz(inp("LIM_IsMaxLim"))
  tpBaan = Nz(inp("LIM_Baan"))
  tpCat = Nz(inp("LIM_Categorie"))
  tpName = Nz(inp("LIM_NAME"))
  

  
  If (tpIsVVT <> curIsVVT Or tpIsMinLim <> curIsMinLim Or tpIsMaxLim <> curIsMaxLim Or tpBaan <> curBaan Or tpCat <> curCat Or tpName <> curName) Then
  
    'Have to start a new list.
    maxUsedListID = maxUsedListID + 1
    curListID = maxUsedListID
    
    curListLenID = curListID
    
    If Not lenAddToCollection(listColl, 1, curListID, "TIMESTANDARDLIST") Then Exit Function
    
    
    
    lst.AddNew
      lst("ID_TIMESTANDARDLIST") = curListID
      
      lst("LEN_timestandardlistid") = curListLenID
    
      lst("LEN_TYPE") = hzn(lenFormatLimitType(tpIsVVT, tpIsMinLim, tpIsMaxLim))
      
      
      Dim minAge As Integer, maxAge As Integer, isTotAge As Boolean, gender As String, isMCat As Boolean
      'Use X for mixed categories
      If Not lenFormatCategorie(tpCat, wedDate, lftBep, gender, minAge, maxAge, isTotAge, isMCat, True) Then
        Err.Raise 1, , "Ongeldige categorie: " + Trim(tpCat)
        Exit Function
      End If
      lst("LEN_Gender") = hzn(gender)
      
      If (minAge = -1 And maxAge = -1) Then
        'do not need to append ageGroup.
        lst("SYS_REF_AGEGROUP") = Null
      Else
        maxUsedAGID = maxUsedAGID + 1
        
        Dim tpAGID As Long
        tpAGID = 3 * maxUsedAGID + 2
        
        lst("SYS_REF_AGEGROUP") = tpAGID
        If Not lenAppendLXAgeGroupBare(lxVersion, ag, tpAGID, -1, gender, minAge, maxAge, isTotAge, catBeschrijving(tpCat), , True) Then Exit Function
      End If
      
      lst("LEN_COURSE") = hzn(lenFormatBaanlengte(tpBaan))
      lst("LEN_NAME") = tpName
      
      Dim qlfFrom As Date, qlfUntil As Date
      qlfFrom = Nz(inp("LIM_QLF_FROM"), #1/1/1900#)
      qlfUntil = Nz(inp("LIM_QLF_UNTIL"), #1/1/1900#)
      If (lenDateIsValid(qlfFrom)) Then
        lst("LEN_QUALIFYFROM") = lenFormatDate(qlfFrom)
      End If
      If (lenDateIsValid(qlfUntil)) Then
        lst("LEN_QUALIFYUNTIL") = lenFormatDate(qlfUntil)
      End If
      
      lst("SYS_REF_TIMESTANDARDS") = curListID
    lst.Update
    
    If Not lenWriteSimpleCollection(stds, curListID, "TIMESTANDARD") Then Exit Function
      
      
      
    
  
    curIsVVT = tpIsVVT
    curIsMinLim = tpIsMinLim
    curIsMaxLim = tpIsMaxLim
    curBaan = tpBaan
    curCat = tpCat
    curName = tpName
  End If
  
  
  Dim tpTime As Double
  Dim tpAf As String, tpSlag As String
  tpTime = Nz(inp("LIM_TIJD"))
  tpAf = Nz(inp("LIM_Afstand"))
  tpSlag = Nz(inp("LIM_SLAG"))
  
  Dim tpPrXID As Long
  tpPrXID = Nz(inp("LIM_PR_ID"), -1)
  
  'Need to check if we need to add a reference to this timestandardlist in the timestandardrefs section of an event.
  If (tpPrXID >= 0) Then
    If (lxVersion >= LX_VERSION_3) Then
      If Not lenAppendTStdRef(skTStdRefs, skPrWithTStdRef, rsTStdRef, rsTStdRefColl, muTStdRefXID, tpPrXID, curListLenID) Then
        Exit Function
      End If
    End If
  End If
    
  
  
  maxUsedSWSTID = maxUsedSWSTID + 1
  If Not lenAppendLXSwimStyle(swst, maxUsedSWSTID, tpAf, tpSlag, "") Then Exit Function
  
  Dim stdID As Long
  stdID = Nz(inp("LIM_ID"))
  
  std.AddNew
    std("ID_Timestandard") = stdID
    std("SYS_REF_SWIMSTYLE") = maxUsedSWSTID
    std("LEN_SWIMTIME") = hzn(lenFormatSwimTime(tpTime))
  std.Update
  
  If Not lenAddToCollection(stdColl, curListID, stdID, "TIMESTANDARD") Then Exit Function
  
  inp.MoveNext
Loop




appCleanRS inp
appCleanRS listColl
appCleanRS lst
appCleanRS stds
appCleanRS stdColl
appCleanRS std
appCleanRS ag
appCleanRS swst



lenWriteTimestandardsToXMLTables = True
Exit Function
fout:
If (Err = 3021) Then Resume Next
MsgBox Err & " " & Error$, 16
Exit Function

'debug
On Error GoTo 0
Resume

End Function

Private Function lenWriteRecordsToXMLTables(ByVal lxVersion As Long, ByVal wedDate As Date, ByRef maxUsedAGID As Long, maxUsedSWSTID As Long, maxUsedMeetInfo As Long, maxUsedSplitID) As Boolean
On Error GoTo fout
lenWriteRecordsToXMLTables = False


Dim curType As String
Dim curBaan As Integer
Dim curCat As String
Dim curName As String

curBaan = -1
curType = ""
curCat = ""
curName = ""

Dim inp As Recordset
Set inp = CurrentDb().OpenRecordset("Select * from gIMP_LEN_records where nz([rec_tijd]) > 0.01 order by rec_type, rec_baan, rec_categorie, rec_name;", dbOpenDynaset)

inp.MoveFirst

Dim maxUsedListID As Long
maxUsedListID = 0

Dim listColl As Recordset
Set listColl = CurrentDb().OpenRecordset("LEN_RECORDLIST_COLL")
Dim lst As Recordset
Set lst = CurrentDb().OpenRecordset("LEN_RECORDLIST")
Dim recs As Recordset
Set recs = CurrentDb().OpenRecordset("LEN_RECORDS")
Dim recColl As Recordset
Set recColl = CurrentDb().OpenRecordset("LEN_RECORD_COLL")
Dim rec As Recordset
Set rec = CurrentDb().OpenRecordset("LEN_RECORD")

Dim ag As Recordset
Set ag = CurrentDb().OpenRecordset("LEN_AGEGROUP")

Dim swst As Recordset
Set swst = CurrentDb().OpenRecordset("LEN_SWIMSTYLE")

Dim sps As Recordset
Set sps = CurrentDb().OpenRecordset("LEN_SPLITS")

Dim spColl As Recordset
Set spColl = CurrentDb().OpenRecordset("LEN_SPLIT_COLL")

Dim sp As Recordset
Set sp = CurrentDb().OpenRecordset("LEN_SPLIT")


Dim mtInf As Recordset
Set mtInf = CurrentDb().OpenRecordset("LEN_MEETINFO")


Do Until inp.EOF
  Dim tpType As String, tpBaan As Integer, tpCat As String, tpName As String
  Dim curListID As Long
  
  tpType = Nz(inp("REC_TYPE"))
  tpBaan = Nz(inp("REC_Baan"))
  tpCat = Nz(inp("REC_Categorie"))
  tpName = Nz(inp("REC_NAME"))
  

  
  If (tpType <> curType Or tpBaan <> curBaan Or tpCat <> curCat Or tpName <> curName) Then
  
    'Have to start a new list.
    maxUsedListID = maxUsedListID + 1
    curListID = maxUsedListID
    
    
    Dim recAgeMode As String
    recAgeMode = Nz(inp("REC_AGEMODE"))
    If (recAgeMode = "") Then
      recAgeMode = LFT_MODE_WEDYR_START
    End If
    
    If Not lenAddToCollection(listColl, 1, curListID, "RECORDLIST") Then Exit Function
    
    
    
    lst.AddNew
      lst("ID_RECORDLIST") = curListID
    
      lst("LEN_TYPE") = inp("REC_TYPE")
      
      
      Dim minAge As Integer, maxAge As Integer, isTotAge As Boolean, gender As String, isMCat As Boolean
      'Use X for mixed categories
      If Not lenFormatCategorie(tpCat, wedDate, recAgeMode, gender, minAge, maxAge, isTotAge, isMCat, True) Then
        Err.Raise 1, , "Ongeldige categorie: " + Trim(tpCat)
        Exit Function
      End If
      
      lst("LEN_Gender") = hzn(gender)
      
      If (minAge = -1 And maxAge = -1) Then
        'do not need to append ageGroup.
        lst("SYS_REF_AGEGROUP") = Null
      Else
        maxUsedAGID = maxUsedAGID + 1
        Dim tpAGID As Long
        tpAGID = 3 * maxUsedAGID + 2
        lst("SYS_REF_AGEGROUP") = tpAGID
        If Not lenAppendLXAgeGroupBare(lxVersion, ag, tpAGID, -1, gender, minAge, maxAge, isTotAge, catBeschrijving(tpCat), , True) Then Exit Function
      End If
      
      lst("LEN_COURSE") = hzn(lenFormatBaanlengte(tpBaan))
      lst("LEN_NAME") = hzn(tpName)
      
      lst("LEN_AGEDATETYPE") = hzn(lenFormatLftBepaling(recAgeMode))
      
      
      
      
      lst("SYS_REF_RECORDS") = curListID
    lst.Update
    
    If Not lenWriteSimpleCollection(recs, curListID, "RECORD") Then Exit Function
      
      
      
    
    curType = tpType
    curBaan = tpBaan
    curCat = tpCat
    curName = tpName
  End If
  
  
  Dim tpTime As Double, tpNDecimals As Integer
  Dim tpAf As String, tpSlag As String
  tpTime = Nz(inp("REC_TIJD"))
  tpNDecimals = Nz(inp("REC_AantalDecimalen"), 0)
  tpAf = Nz(inp("REC_Afstand"))
  tpSlag = Nz(inp("REC_SLAG"))
  
  
  maxUsedSWSTID = maxUsedSWSTID + 1
  If Not lenAppendLXSwimStyle(swst, maxUsedSWSTID, tpAf, tpSlag, "") Then Exit Function
  
  Dim recID As Long
  'remember....
  'I think this is not necessary
  recID = 3 * Nz(inp("REC_ID")) + 2
  
  rec.AddNew
    rec("ID_RECORD") = recID
    Dim isEstaf As Boolean
    isEstaf = Nz(inp("REC_IsEstaf"))
    
    If (isEstaf) Then
      'remember that relay teams have odd ids.
      If (IsNull(inp("REC_PLOEG_ID"))) Then
        rec("SYS_REF_RELAY") = Null
      Else
        rec("SYS_REF_RELAY") = (14 * Nz(inp("REC_PLOEG_ID"))) + 9
      End If
      rec("SYS_REF_ATHLETE") = Null
    Else
      rec("SYS_REF_RELAY") = Null
      'remember that athletes have even ids.
      If (IsNull(inp("REC_ZWEMMER_ID"))) Then
        rec("SYS_REF_ATHLETE") = Null
      Else
        rec("SYS_REF_ATHLETE") = 2 * inp("REC_Zwemmer_ID")
      End If
    End If
    
    rec("SYS_REF_SWIMSTYLE") = maxUsedSWSTID
    
    rec("LEN_SWIMTIME") = hzn(lenFormatSwimTime(tpTime))
    If (tpNDecimals = 1) Or (tpNDecimals = 2) Then
      rec("LEN_HUP_NDECIMALS") = tpNDecimals
    End If
    rec("LEN_COMMENT") = inp("REC_Opm")
    
    
    
    
    Dim tstAf(0 To MAX_N_TUSSENTIJDEN) As Integer
   Dim tstTd(0 To MAX_N_TUSSENTIJDEN) As Double
   Dim tstCnt As Integer
   
   tstCnt = 0
   If Not (tstExtractTussenTijden(Nz(inp("REC_Tussentijden")), tstCnt, tstAf, tstTd)) Then
      Exit Function
   End If
   
      
   If tstCnt > 0 Then
     'need to append splits
     If (Not lenWriteSimpleCollection(sps, recID, "SPLIT")) Then Exit Function
     rec("SYS_REF_SPLITS") = recID
     
     Dim tpTstI As Integer
     For tpTstI = 0 To tstCnt - 1
       maxUsedSplitID = maxUsedSplitID + 1
       If Not lenAppendLXSplit(sp, maxUsedSplitID, tstAf(tpTstI), tstTd(tpTstI)) Then Exit Function
       If Not lenAddToCollection(spColl, recID, maxUsedSplitID, "SPLIT") Then Exit Function
     Next tpTstI
     
    End If
    
    
    
    
    Dim mtPlaats As String, mtDate As Date, mtNation As String, mtWedDes As String
    mtPlaats = Nz(inp("REC_PLaats"))
    mtDate = Nz(inp("REC_Datum"), #1/1/1900#)
    mtNation = Nz(inp("REC_NATION"))
    mtWedDes = Nz(inp("REC_WedDescription"))
    
    
    If (mtPlaats <> "") And (lenDateIsValid(mtDate)) Then

      maxUsedMeetInfo = maxUsedMeetInfo + 1
    
      If Not lenAppendLXMeetInfo(mtInf, maxUsedMeetInfo, Nz(inp("REC_BAAN")), mtPlaats, mtNation, mtDate, mtWedDes, 0) Then Exit Function
      rec("SYS_REF_MEETINFO") = maxUsedMeetInfo
    Else
      rec("SYS_REF_MEETINFO") = Null
    End If
    
    
    
    
    
    
    
  rec.Update
  
  
  
  If Not lenAddToCollection(recColl, curListID, recID, "RECORD") Then Exit Function
  
  inp.MoveNext
Loop



appCleanRS inp
appCleanRS listColl
appCleanRS lst
appCleanRS recs
appCleanRS recColl
appCleanRS rec
appCleanRS ag
appCleanRS swst
appCleanRS sps
appCleanRS spColl
appCleanRS sp
appCleanRS mtInf



lenWriteRecordsToXMLTables = True
Exit Function
fout:
If (Err = 3021) Then Resume Next
MsgBox Err & " lenWriteRecordsToXMLTables" & vbCrLf & Error$, 16


Exit Function
'debug
On Error GoTo 0
Resume

Exit Function
End Function


Private Function lenWriteToXMLTables_cleanTempTables() As Boolean
On Error GoTo fout
lenWriteToXMLTables_cleanTempTables = False


DoCmd.DeleteObject acTable, "~len_write_heats"
DoCmd.DeleteObject acTable, "~len_progs_with_heats"
DoCmd.DeleteObject acTable, "~len_ag_with_rankings"
DoCmd.DeleteObject acTable, "~len_write_time_std_refs"
DoCmd.DeleteObject acTable, "~len_progs_with_time_std_refs"


lenWriteToXMLTables_cleanTempTables = True
Exit Function

fout:
If (Err = 3011) Or (Err = 7874) Then Resume Next
MsgBox Err & " lenWriteToXMLTables_cleanTempTables" & vbCrLf & Error$, 16
Exit Function
End Function

Private Function lenWriteToXMLTables_prepareTempTables() As Boolean
On Error GoTo fout
lenWriteToXMLTables_prepareTempTables = False


If Not lenWriteToXMLTables_cleanTempTables() Then
  Exit Function
End If


Dim db As Database
Set db = CurrentDb()


Dim tb As TableDef

Set tb = db.CreateTableDef("~len_write_heats")

tb.Fields.Append tb.CreateField("HT_PR_ID", dbLong)
tb.Fields.Append tb.CreateField("HT_Serie", dbLong)
tb.Fields.Append tb.CreateField("HT_HT_LEN_ID", dbLong)

Dim idx As Index
Set idx = tb.CreateIndex("PrimaryKey")
idx.Fields.Append idx.CreateField("HT_PR_ID", dbLong)
idx.Fields.Append idx.CreateField("HT_Serie", dbLong)
idx.Primary = True

tb.Indexes.Append idx

db.TableDefs.Append tb

Set idx = Nothing
Set tb = Nothing



'now create table for prXIDs that have heats

Set tb = db.CreateTableDef("~len_progs_with_heats")

tb.Fields.Append tb.CreateField("PWH_PR_XID", dbLong)
Set idx = tb.CreateIndex("PrimaryKey")
idx.Fields.Append idx.CreateField("PWH_PR_XID", dbLong)
tb.Indexes.Append idx
db.TableDefs.Append tb

Set idx = Nothing
Set tb = Nothing


Set tb = db.CreateTableDef("~len_ag_with_rankings")

tb.Fields.Append tb.CreateField("AWR_AG_XID", dbLong)
Set idx = tb.CreateIndex("PrimaryKey")
idx.Fields.Append idx.CreateField("AWR_AG_XID", dbLong)
tb.Indexes.Append idx
db.TableDefs.Append tb

Set idx = Nothing
Set tb = Nothing






Set tb = db.CreateTableDef("~len_write_time_std_refs")

tb.Fields.Append tb.CreateField("TSR_PR_XID", dbLong)
tb.Fields.Append tb.CreateField("TSR_LIST_LEN_ID", dbLong)


Set idx = tb.CreateIndex("PrimaryKey")
idx.Fields.Append idx.CreateField("TSR_PR_XID", dbLong)
idx.Fields.Append idx.CreateField("TSR_LIST_LEN_ID", dbLong)
idx.Primary = True

tb.Indexes.Append idx

db.TableDefs.Append tb

Set idx = Nothing
Set tb = Nothing



Set tb = db.CreateTableDef("~len_progs_with_time_std_refs")

tb.Fields.Append tb.CreateField("PWTS_PR_XID", dbLong)
Set idx = tb.CreateIndex("PrimaryKey")
idx.Fields.Append idx.CreateField("PWTS_PR_XID", dbLong)
tb.Indexes.Append idx
db.TableDefs.Append tb

Set idx = Nothing
Set tb = Nothing


Set db = Nothing


lenWriteToXMLTables_prepareTempTables = True
Exit Function

fout:
If (Err = 3011) Or (Err = 7874) Then Resume Next
MsgBox Err & " lenWriteToXMLTables_prepareTempTables" & vbCrLf & Error$, 16
Exit Function

'debug
On Error GoTo 0
Resume
End Function

Private Function lenWriteHeatSmyToXMLTables() As Boolean
On Error GoTo fout
lenWriteHeatSmyToXMLTables = False

Dim rs As Recordset
Set rs = CurrentDb().OpenRecordset("~len_progs_with_heats")

Dim skEvs As Recordset
Set skEvs = CurrentDb().OpenRecordset("LEN_EVENT")
skEvs.Index = "P"

Dim rsHeats As Recordset
Set rsHeats = CurrentDb().OpenRecordset("LEN_HEATS")

rs.MoveFirst
Do Until rs.EOF

  Dim tpPrXID As Long
  tpPrXID = Nz(rs("PWH_PR_XID"))
  
  skEvs.Seek "=", tpPrXID
  If skEvs.NoMatch Then
    Err.Raise 1, , "Internal error"
  End If
  
  skEvs.Edit
    skEvs("SYS_REF_HEATS") = tpPrXID
  skEvs.Update
  
  If Not lenWriteSimpleCollection(rsHeats, tpPrXID, "HEAT") Then
    Exit Function
  End If
  

  rs.MoveNext
Loop

appCleanRS rs
appCleanRS rsHeats
appCleanRS skEvs


lenWriteHeatSmyToXMLTables = True
Exit Function
fout:
If (Err = 3021) Then Resume Next
MsgBox Err & " lenWriteHeatSmyToXMLTables" & vbCrLf & Error$, 16
Exit Function
End Function
Private Function lenWriteRnkSmyToXMLTables() As Boolean
On Error GoTo fout
lenWriteRnkSmyToXMLTables = False



Dim rs As Recordset
Set rs = CurrentDb().OpenRecordset("~len_ag_with_rankings")

Dim skAgs As Recordset
Set skAgs = CurrentDb().OpenRecordset("LEN_AGEGROUP")
skAgs.Index = "P"

Dim rsRnks As Recordset
Set rsRnks = CurrentDb().OpenRecordset("LEN_RANKINGS")

rs.MoveFirst
Do Until rs.EOF

  Dim tpAgXID As Long
  tpAgXID = Nz(rs("AWR_AG_XID"))
  
  skAgs.Seek "=", tpAgXID
  
  'It is possible that there is no age group. In this case, ignore the ranking
  
  If Not skAgs.NoMatch Then
    
    skAgs.Edit
      skAgs("SYS_REF_RANKINGS") = tpAgXID
    skAgs.Update
    
    If Not lenWriteSimpleCollection(rsRnks, tpAgXID, "RANKING") Then
      Exit Function
    End If
    
  End If
  
  
  

  rs.MoveNext
Loop

appCleanRS rs
appCleanRS rsRnks
appCleanRS skAgs



lenWriteRnkSmyToXMLTables = True
Exit Function
fout:
If (Err = 3021) Then Resume Next
MsgBox Err & " lenWriteRnkSmyToXMLTables" & vbCrLf & Error$, 16
Exit Function
'debug
On Error GoTo 0
Resume
End Function


Private Function lenWriteTStdRefSmyToXMLTables() As Boolean
On Error GoTo fout
lenWriteTStdRefSmyToXMLTables = False


Dim rs As Recordset
Set rs = CurrentDb().OpenRecordset("~len_progs_with_time_std_refs")

Dim skEvs As Recordset
Set skEvs = CurrentDb().OpenRecordset("LEN_EVENT")
skEvs.Index = "P"

Dim rsTStdRefs As Recordset
Set rsTStdRefs = CurrentDb().OpenRecordset("LEN_TIMESTANDARDREFS")

rs.MoveFirst
Do Until rs.EOF

  Dim tpPrXID As Long
  tpPrXID = Nz(rs("PWTS_PR_XID"))
  
  skEvs.Seek "=", tpPrXID
  
   
  If (skEvs.NoMatch) Then
    Err.Raise 1, , "Internal error."
  End If
  
  
    
  skEvs.Edit
    skEvs("SYS_REF_TIMESTANDARDREFS") = tpPrXID
  skEvs.Update

  If Not lenWriteSimpleCollection(rsTStdRefs, tpPrXID, "TIMESTANDARDREF") Then
    Exit Function
  End If
    
   
  
  

  rs.MoveNext
Loop

appCleanRS rs
appCleanRS rsTStdRefs
appCleanRS skEvs



lenWriteTStdRefSmyToXMLTables = True
Exit Function
fout:
If (Err = 3021) Then Resume Next
MsgBox Err & " lenWriteTStdRefSmyToXMLTables" & vbCrLf & Error$, 16
Exit Function
'debug
On Error GoTo 0
Resume
End Function


Public Function lenWriteToXMLTables(ByVal lxVersion As Long) As Boolean
On Error GoTo fout
lenWriteToXMLTables = False

If Not gXMLWriter.prepareXMLStructureTables("fdtgLEN_XML_OBJECTS", "fdtgLEN_XML_OBJECT_RELATIONS", "LEN_") Then Exit Function



If (lxVersion >= LX_VERSION_3) Then
  If Not lenWriteToXMLTables_prepareTempTables() Then
    Exit Function
  End If
End If

'Dim maxUsedContID As Long
'maxUsedContID = 0
Dim maxUsedKostenID As Long
maxUsedKostenID = 0

Dim maxUsedSwimStyleID As Long
Dim maxUsedAgeGroupID As Long

maxUsedSwimStyleID = 0
maxUsedAgeGroupID = 0

Dim lftMode As String

Dim currencyStr As String

Dim wedDate As Date

If Not lenWriteSessionsToXMLTables(maxUsedKostenID, wedDate, lftMode, currencyStr) Then Exit Function

If Not lenWriteProgrammaToXMLTables(lxVersion, wedDate, lftMode, currencyStr, maxUsedSwimStyleID, maxUsedKostenID) Then Exit Function


Dim constructorContID As Long

If Not lenWriteContactsToXMLTables(constructorContID) Then Exit Function

If Not lenWriteClubsToXMLTables() Then Exit Function

If Not lenWriteAthletesToXMLTables() Then Exit Function

Dim maxUsedMeetInfoID As Long
maxUsedMeetInfoID = 0

Dim maxUsedSplitID As Long
maxUsedSplitID = 0

Dim maxUsedHeatXID As Long
maxUsedHeatXID = 0



If Not lenWritePloegenToXMLTables(wedDate, lftMode) Then Exit Function

If Not lenWritePloegledenToXMLTables(maxUsedMeetInfoID) Then Exit Function

If Not lenWriteDeelnemersToXMLTables(lxVersion, maxUsedMeetInfoID, maxUsedHeatXID) Then Exit Function

If Not lenWriteTijdenToXMLTables(lxVersion, maxUsedSplitID, maxUsedHeatXID) Then Exit Function

If Not lenWriteArchivedTimesToXMLTables(maxUsedMeetInfoID, maxUsedSwimStyleID) Then Exit Function


If Not lenWriteTimestandardsToXMLTables(lxVersion, wedDate, lftMode, maxUsedAgeGroupID, maxUsedSwimStyleID) Then Exit Function

If Not lenWriteRecordsToXMLTables(lxVersion, wedDate, maxUsedAgeGroupID, maxUsedSwimStyleID, maxUsedMeetInfoID, maxUsedSplitID) Then Exit Function


If Not lenWriteLenexHeader(lxVersion, constructorContID) Then Exit Function



If (lxVersion >= LX_VERSION_3) Then

  If Not lenWriteHeatSmyToXMLTables() Then
    Exit Function
  End If
  
  If Not lenWriteRnkSmyToXMLTables() Then
    Exit Function
  End If
  
  If Not lenWriteTStdRefSmyToXMLTables() Then
    Exit Function
  End If

End If


If Not lenWriteToXMLTables_cleanTempTables() Then
  Exit Function
End If


lenWriteToXMLTables = True
Exit Function
fout:
MsgBox Err & " " & Error$, 16

Exit Function

'debug
On Error GoTo 0
Resume
Exit Function
End Function



Public Function lenApplyCorrectionsUsingAuxData(corrPrIDs As Boolean, corrVerIDs As Boolean, corrZwIDs As Boolean) As Boolean
On Error GoTo fout
lenApplyCorrectionsUsingAuxData = False

DoCmd.SetWarnings False

Dim sql As String

'update vorig_prog field.
sql = "UPDATE gIMP_LEN_Programma INNER JOIN gIMP_LEN_Programma AS gIMP_LEN_Programma_1 ON gIMP_LEN_Programma.AUX_Vorig_Prog = gIMP_LEN_Programma_1.PR_Programmanummer SET gIMP_LEN_Programma.PR_Vorig_Prog_ID = [gIMP_LEN_Programma_1].[pr_id];"

DoCmd.RunSQL sql



If (corrPrIDs) Then
  sql = "UPDATE gIMP_LEN_Leeftijdsgroepen INNER JOIN gIMP_LEN_Programma ON (gIMP_LEN_Programma.PR_Programmanummer = gIMP_LEN_Leeftijdsgroepen.AUX_Programmanummer) AND (gIMP_LEN_Leeftijdsgroepen.AUX_Wedstrijdnummer = gIMP_LEN_Programma.PR_WED_ID) SET gIMP_LEN_Leeftijdsgroepen.LF_PR_ID = [pr_id];"
  DoCmd.RunSQL sql

sql = "UPDATE gIMP_LEN_Deelnemers INNER JOIN gIMP_LEN_Programma ON (gIMP_LEN_Programma.PR_Programmanummer = gIMP_LEN_Deelnemers.AUX_Programmanummer) AND (gIMP_LEN_Deelnemers.AUX_Wedstrijdnummer = gIMP_LEN_Programma.PR_WED_ID) SET gIMP_LEN_Deelnemers.DE_PROG_ID = [pr_id];"
DoCmd.RunSQL sql

sql = "UPDATE gIMP_LEN_Tijden INNER JOIN gIMP_LEN_Programma ON (gIMP_LEN_Programma.PR_Programmanummer = gIMP_LEN_Tijden.AUX_Programmanummer) AND (gIMP_LEN_Tijden.AUX_Wedstrijdnummer = gIMP_LEN_Programma.PR_WED_ID) SET gIMP_LEN_Tijden.TY_PROG_ID = [pr_id];"
DoCmd.RunSQL sql

End If


If (corrVerIDs) Then
  sql = "UPDATE gIMP_LEN_Zwemmers INNER JOIN gIMP_LEN_Ver ON gIMP_LEN_Zwemmers.AUX_Depotnummer = gIMP_LEN_Ver.V_Depot SET gIMP_LEN_Zwemmers.ZW_VER_ID = [v_id];"
  DoCmd.RunSQL sql
  
  sql = "UPDATE gIMP_LEN_Deelnemers INNER JOIN gIMP_LEN_Ver ON gIMP_LEN_Deelnemers.AUX_Depotnummer = gIMP_LEN_Ver.V_Depot SET gIMP_LEN_Deelnemers.DE_VER_ID = [v_id];"
  DoCmd.RunSQL sql
  
  sql = "UPDATE gIMP_LEN_Tijden INNER JOIN gIMP_LEN_Ver ON gIMP_LEN_Tijden.AUX_Depotnummer = gIMP_LEN_Ver.V_Depot SET gIMP_LEN_Tijden.TY_VER_ID = [v_id];"
  DoCmd.RunSQL sql
  
  sql = "UPDATE gIMP_LEN_Ploeg INNER JOIN gIMP_LEN_Ver ON gIMP_LEN_Ploeg.AUX_Depotnummer = gIMP_LEN_Ver.V_Depot SET gIMP_LEN_Ploeg.PL_VER_ID = [v_id];"
  DoCmd.RunSQL sql
  
  sql = "UPDATE gIMP_LEN_Ploegleden INNER JOIN gIMP_LEN_Ver ON gIMP_LEN_Ploegleden.AUX_Depotnummer = gIMP_LEN_Ver.V_Depot SET gIMP_LEN_Ploegleden.AUX_INT_VER_ID = [v_id];"
  DoCmd.RunSQL sql
  
  sql = "UPDATE gIMP_LEN_RECORDS INNER JOIN gIMP_LEN_Ver ON gIMP_LEN_Records.AUX_Depotnummer = gIMP_LEN_Ver.V_Depot SET gIMP_LEN_Records.AUX_INT_VER_ID = [v_id];"
  DoCmd.RunSQL sql

End If


If (corrZwIDs) Then
  sql = "UPDATE gIMP_LEN_Deelnemers INNER JOIN gIMP_LEN_Zwemmers ON (gIMP_LEN_Deelnemers.AUX_Startnummer = gIMP_LEN_Zwemmers.ZW_Startnummer) AND (gIMP_LEN_Deelnemers.DE_Ver_ID = gIMP_LEN_Zwemmers.ZW_VER_ID) SET gIMP_LEN_Deelnemers.DE_Zwemmer_ID = [zw_id];"
  DoCmd.RunSQL sql
  
  sql = "UPDATE gIMP_LEN_TIJDEN INNER JOIN gIMP_LEN_Zwemmers ON (gIMP_LEN_TIJDEN.AUX_Startnummer = gIMP_LEN_Zwemmers.ZW_Startnummer) AND (gIMP_LEN_TIJDEN.TY_Ver_ID = gIMP_LEN_Zwemmers.ZW_VER_ID) SET gIMP_LEN_TIJDEN.TY_Zwemmer_ID = [zw_id];"
  DoCmd.RunSQL sql
  
  sql = "UPDATE gIMP_LEN_PLOEGLEDEN INNER JOIN gIMP_LEN_Zwemmers ON (gIMP_LEN_Ploegleden.AUX_Startnummer = gIMP_LEN_Zwemmers.ZW_Startnummer) AND (gIMP_LEN_Ploegleden.AUX_INT_Ver_ID = gIMP_LEN_Zwemmers.ZW_VER_ID) SET gIMP_LEN_PLOEGLEDEN.PLL_Zwemmer_ID = [zw_id];"
  DoCmd.RunSQL sql
  
  sql = "UPDATE gIMP_LEN_RECORDS INNER JOIN gIMP_LEN_Zwemmers ON (gIMP_LEN_RECORDS.AUX_Startnummer = gIMP_LEN_Zwemmers.ZW_Startnummer) AND (gIMP_LEN_RECORDS.AUX_INT_Ver_ID = gIMP_LEN_Zwemmers.ZW_VER_ID) SET gIMP_LEN_RECORDS.REC_Zwemmer_ID = [zw_id];"
  DoCmd.RunSQL sql
  
  

End If



sql = "UPDATE gIMP_LEN_Deelnemers INNER JOIN gIMP_LEN_Leeftijdsgroepen ON (gIMP_LEN_Deelnemers.AUX_Categorie = gIMP_LEN_Leeftijdsgroepen.LF_Categorie) " & _
"AND (gIMP_LEN_Deelnemers.DE_PROG_ID = gIMP_LEN_Leeftijdsgroepen.LF_PR_ID) SET gIMP_LEN_Deelnemers.DE_Agegroup_ID = gIMP_LEN_Leeftijdsgroepen.LF_ID;"
DoCmd.RunSQL sql


sql = "UPDATE gIMP_LEN_Tijden INNER JOIN gIMP_LEN_Leeftijdsgroepen ON (gIMP_LEN_Tijden.AUX_Categorie = gIMP_LEN_Leeftijdsgroepen.LF_Categorie) " & _
"AND (gIMP_LEN_Tijden.TY_PROG_ID = gIMP_LEN_Leeftijdsgroepen.LF_PR_ID) SET gIMP_LEN_Tijden.TY_Agegroup_ID = gIMP_LEN_Leeftijdsgroepen.LF_ID;"
DoCmd.RunSQL sql






DoCmd.SetWarnings True
lenApplyCorrectionsUsingAuxData = True
Exit Function
fout:
DoCmd.SetWarnings True
MsgBox Err & " " & Error$, 16
Exit Function
End Function



Public Function lenFillAuxFieldsCorrectPloegNummers() As Boolean
On Error GoTo fout
lenFillAuxFieldsCorrectPloegNummers = False

Dim sql As String

DoCmd.SetWarnings False

'update ploegleden.
sql = "UPDATE gIMP_LEN_Ploegleden INNER JOIN gIMP_LEN_Deelnemers ON gIMP_LEN_Ploegleden.PLL_Deelnemer_ID = " & _
"gIMP_LEN_Deelnemers.DE_ID SET gIMP_LEN_Ploegleden.AUX_Wedstrijdnummer = [gIMP_LEN_Deelnemers].[aux_wedstrijdnummer], " & _
"gIMP_LEN_Ploegleden.AUX_Estafettenummer = [gIMP_LEN_Deelnemers].[aux_estafettenummer], gIMP_LEN_Ploegleden.AUX_Programmanummer = " & _
"[gIMP_LEN_Deelnemers].[aux_programmanummer], gIMP_LEN_Ploegleden.AUX_Depotnummer = [gIMP_LEN_Deelnemers].[aux_depotnummer];"
DoCmd.RunSQL sql

sql = "UPDATE gIMP_LEN_Ploegleden INNER JOIN gIMP_LEN_Tijden ON gIMP_LEN_Ploegleden.PLL_Tijd_ID = " & _
"gIMP_LEN_Tijden.TY_ID SET gIMP_LEN_Ploegleden.AUX_Wedstrijdnummer = [gIMP_LEN_Tijden].[aux_wedstrijdnummer], " & _
"gIMP_LEN_Ploegleden.AUX_Estafettenummer = [gIMP_LEN_Tijden].[aux_estafettenummer], gIMP_LEN_Ploegleden.AUX_Programmanummer = " & _
"[gIMP_LEN_Tijden].[aux_programmanummer], gIMP_LEN_Ploegleden.AUX_Depotnummer = [gIMP_LEN_Tijden].[aux_depotnummer];"
DoCmd.RunSQL sql


DoCmd.SetWarnings True

lenFillAuxFieldsCorrectPloegNummers = True
Exit Function
fout:
MsgBox Err & " " & Error$, 16
DoCmd.SetWarnings True
Exit Function
End Function















Private Function lenWriteFromXMLTables(lxfDir As String, lxfFileName As String, ByVal strictLenex As Boolean, ByVal lxVersion As Long, ByRef actFileName As String) As Boolean
On Error GoTo fout

Dim lxfCompleteName As String
lxfCompleteName = directory_goedmaak(lxfDir) & "\" & lxfFileName

Dim sLefFileName As String


Dim zipData As ZIP_INTERNAL

If Not zipWrite(lxfCompleteName, "lef", "lxf", sLefFileName, zipData) Then
  Exit Function
End If

On Error GoTo fout_cleanup

Dim isOK As Boolean

isOK = gXMLWriter.exportStructureToXML(sLefFileName, "fdtgLEN_XML_OBJECTS", "fdtgLEN_XML_OBJECT_RELATIONS", "LEN_", lxVersion, , , strictLenex)


On Error GoTo fout

Dim sDummy As String, isPackedOK As Boolean

If (Not isOK) Then
  If Not zipWrite_finish(False, isPackedOK, False, sDummy, zipData) Then
    Exit Function
  End If
Else
  If Not zipWrite_finish(True, isPackedOK, True, sDummy, zipData) Then
    Exit Function
  End If
  If Not isPackedOK Then
    Exit Function
  End If
End If

If (Not isOK) Then
  Exit Function
End If





actFileName = lxfCompleteName



lenWriteFromXMLTables = True
Exit Function


fout:
Dim msg As String
Dim errCode As Long
errCode = Err

msg = errCode & " lenWriteFromXMLTables" & vbCrLf & Error$


If (errCode = 1) Then
  MsgBox msg, 16
Else
  MsgBox "An unexpected error has occurred. " & Chr(13) & "This may be caused by the fact that hupswim.dll and hupswim_zip32.dll have not been copied into the windows system directory (c:\windows\system)" & _
  Chr(13) & "These dll's are automatically installed by the setup.exe program, but can also be downloaded from the Hupswim website (See About-box for details)." & Chr(13) & "The error that prompted this message is described below: " & Chr(13) & msg, 16
End If

Exit Function


fout_cleanup:

errCode = Err

msg = errCode & " lenWriteFromXMLTables" & Error$


zipWrite_finish False, isPackedOK, False, sDummy, zipData



If (errCode = 1) Then
  MsgBox msg, 16
Else
  MsgBox "An unexpected error has occurred. " & Chr(13) & "This may be caused by the fact that hupswim.dll and hupswim_zip32.dll have not been copied into the windows system directory (c:\windows\system)" & _
  Chr(13) & "These dll's are automatically installed by the setup.exe program, but can also be downloaded from the Hupswim website (See About-box for details)." & Chr(13) & "The error that prompted this message is described below: " & Chr(13) & msg, 16
End If
Exit Function
   


End Function


Public Function lenWriteFile(lxfDir As String, lxfFileName As String, strictLenex As Boolean, ByVal lxVersion As Long, ByRef actFileName As String) As Boolean
On Error GoTo fout
lenWriteFile = False

If Not lenApplyCorrectionsUsingAuxData(True, True, True) Then Exit Function

If Not gXMLWriter.prepareXMLStructureTables("fdtgLEN_XML_OBJECTS", "fdtgLEN_XML_OBJECT_RELATIONS", "LEN_") Then Exit Function

If Not lenWriteToXMLTables(lxVersion) Then Exit Function
 
If Not lenWriteFromXMLTables(lxfDir, lxfFileName, strictLenex, lxVersion, actFileName) Then Exit Function



lenWriteFile = True
Exit Function
fout:
MsgBox Err & " lenWriteFile" & vbCrLf & Error$, 16
Exit Function

End Function

Public Function lenAnalyzeFile(ByVal lxfName As String, ByRef blValid As Boolean, ByRef lxInvalidReason As Integer, ByRef lxInvalidString As String, ByRef wedDate As String, ByRef wedDescription As String, ByRef wedPlace As String) As Boolean
On Error GoTo fout
lenAnalyzeFile = False

Dim lxfDir As String
Dim lxfFName As String
lxfDir = extractFilePath(lxfName)
lxfFName = extractFileName(lxfName)

If (Not lenAnalyzeFile_Perform(lxfDir, lxfFName, False, True, False, blValid, lxInvalidReason, lxInvalidString, wedDate, wedDescription, wedPlace)) Then
  Exit Function
End If

lenAnalyzeFile = True
Exit Function
fout:
MsgBox Err & " " & Error$, 16
Exit Function
End Function


Private Function lenAnalyzeFile_processLXFile(ByVal lxfName As String, ByVal blImpStructure As Boolean, blGetInfo As Boolean, ByVal blDisplayErr As Boolean, ByRef blValid As Boolean, ByRef lxInvalidReason As Integer, ByRef lxInvalidString As String, ByRef wedDateS As String, ByRef wedDescription As String, ByRef wedPlace As String) As Boolean
On Error GoTo fout
lenAnalyzeFile_processLXFile = False

blValid = False

  
  If Not gXMLReader.isNodePresent(lxfName, "LENEX", True, 20) Then
    lxInvalidReason = LX_XML_STR_INVALID
    lxInvalidString = "Invalid lenex file. Could not find xml-element LENEX."
    Err.Raise 1, , lxInvalidString
  End If
  
  Dim tagNames(4) As String
  Dim tagOutput(4) As String
  Dim tagFound(4) As Boolean
  Dim nTags As Integer
  
  If (blGetInfo) Then
    tagNames(0) = "LENEX/MEETS/MEET/CITY"
    tagNames(1) = "LENEX/MEETS/MEET/NAME"
    tagNames(2) = "LENEX/MEETS/MEET/SESSIONS/SESSION/Date"
    nTags = 3
    
    
    Dim xmlErrCode As Integer
    Dim xmlErrMsg As String
    xmlErrCode = -1
    xmlErrMsg = ""

    
    
    On Error GoTo xmlFout
    'If Not (gXMLReader.readFirstTagsData(lxfCompleteName, tagNames, tagOutput, tagFound, nTags, True, 100, False)) Then
      'something unexpected was wrong. Error message has already been given.
      'Exit Function
      'should not get here.
    'End If
    
    'Error is reraised if something goes wrong.
    gXMLReader.readFirstTagsData lxfName, tagNames, tagOutput, tagFound, nTags, True, 100, False
    
    
    On Error GoTo fout
    
    If (xmlErrCode >= 0) Then
      lxInvalidReason = LX_XML_SYN_INVALID
      lxInvalidString = xmlErrMsg
      Err.Raise 1, , lxInvalidString
    End If
    
    wedPlace = ""
    wedDescription = ""
    wedDateS = ""
    
    If (tagFound(0)) Then
      wedPlace = tagOutput(0)
    End If
    If (tagFound(1)) Then
      wedDescription = tagOutput(1)
    End If
    If (tagFound(2)) Then
      wedDateS = tagOutput(2)
    End If
  End If
  
  If (blImpStructure) Then
    If Not (gXMLReader.importXMLStructure(lxfName, "fdtgLEN_XML_OBJECTS", "fdtgLEN_XML_OBJECT_RELATIONS", "LEN_")) Then
      Exit Function
    End If
  End If
  
  blValid = True

  lenAnalyzeFile_processLXFile = True
  Exit Function

fout:
Dim errCode As Long
Dim errMsg As String
errCode = Err
errMsg = Error$

If (Err = 1) Then
  If (blDisplayErr) Then
    MsgBox errCode & " " & errMsg, 16
  End If
  lenAnalyzeFile_processLXFile = True
  Exit Function
End If

'unexpected failure.
MsgBox Err & " " & Error$, 16
Exit Function

xmlFout:
xmlErrCode = Err
xmlErrMsg = Error$
Resume Next

End Function

Private Function lenAnalyzeFile_Perform(ByVal lxfDir As String, ByVal lxfFileName As String, ByVal blImpStructure As Boolean, blGetInfo As Boolean, ByVal blDisplayErr As Boolean, ByRef blValid As Boolean, ByRef lxInvalidReason As Integer, ByRef lxInvalidString As String, ByRef wedDate As String, ByRef wedDescription As String, ByRef wedPlace As String) As Boolean
On Error GoTo fout
lenAnalyzeFile_Perform = False


blValid = False
lxInvalidReason = LX_INVALID_FNAME
lxInvalidString = ""


Dim zipData As ZIP_INTERNAL
Dim blExtracted As Boolean, zipInvalidReason As Integer, zipInvalidString As String
Dim sLefFileName As String

'Do not display an error message. We will do so ourselves here if necessary.
If Not zipRead(directory_goedmaak(lxfDir) & "\" & lxfFileName, "lef", "lxf", blExtracted, False, zipInvalidReason, zipInvalidString, sLefFileName, zipData) Then
  Exit Function
End If


If (Not blExtracted) Then
  lxInvalidString = zipInvalidString
  Select Case zipInvalidReason
    Case ZIP_INVALID_CNT
      lxInvalidReason = LX_ZIP_CNT_INVALID
    Case ZIP_INVALID_FILE_NAME
      lxInvalidReason = LX_INVALID_FNAME
    Case ZIP_UNKNOWN_FILE
      lxInvalidReason = LX_INVALID_FNAME
    Case ZIP_UZIP_FAILURE
      lxInvalidReason = LX_UZIP_FAILURE
  End Select
  Err.Raise 1, , lxInvalidString
End If



On Error GoTo fout_cleanup

Dim ok As Boolean
ok = lenAnalyzeFile_processLXFile(sLefFileName, blImpStructure, blGetInfo, blDisplayErr, blValid, lxInvalidReason, lxInvalidString, wedDate, wedDescription, wedPlace)
  
zipRead_finish zipData

On Error GoTo fout

If Not ok Then
  Exit Function
End If


lenAnalyzeFile_Perform = True
Exit Function

fout:
Dim msg As String
Dim errCode As Long
errCode = Err

msg = errCode & " " & Error$


If (errCode = 1) Then
  If (blDisplayErr) Then
    MsgBox msg, 16
  End If
  lenAnalyzeFile_Perform = True
Else
  MsgBox "An unexpected error has occurred. " & Chr(13) & "This may be caused by the fact that hupswim.dll and hupswim_unzip32.dll have not been copied into the windows system directory (c:\windows\system)" & _
  Chr(13) & "These dll's are automatically installed by the setup.exe program, but can also be downloaded from the Hupswim website (See About-box for details)." & Chr(13) & "The error that prompted this message is described below: " & Chr(13) & msg, 16
End If

Exit Function


fout_cleanup:

errCode = Err

msg = errCode & " lenAnalyzeFile_perform" & vbCrLf & Error$

zipRead_finish zipData


If (errCode = 1) Then
  If (blDisplayErr) Then
    MsgBox msg, 16
  End If
  lenAnalyzeFile_Perform = True
Else
  MsgBox "An unexpected error has occurred. " & Chr(13) & "This may be caused by the fact that hupswim.dll and hupswim_unzip32.dll have not been copied into the windows system directory (c:\windows\system)" & _
  Chr(13) & "These dll's are automatically installed by the setup.exe program, but can also be downloaded from the Hupswim website (See About-box for details)." & Chr(13) & "The error that prompted this message is described below: " & Chr(13) & msg, 16
End If

Exit Function

'debug
On Error GoTo 0
Resume

End Function



Private Function lenReadToXMLTables(lxfDir As String, lxfFileName As String) As Boolean
On Error GoTo fout
lenReadToXMLTables = False

Dim blValid As Boolean, lxInvalidReason As Integer, lxInvalidString As String, wedDateS As String, wedPlaceS As String, wedDesS As String


If (Not lenAnalyzeFile_Perform(lxfDir, lxfFileName, True, False, True, blValid, lxInvalidReason, lxInvalidString, wedDateS, wedDesS, wedPlaceS)) Then
  Exit Function
End If

If (Not blValid) Then
  Exit Function
End If

lenReadToXMLTables = True
Exit Function
fout:
MsgBox Err & " lenReadToXMLTables" & vbCrLf & Error$, 16
Exit Function
End Function

Private Sub lenKillTemp(dirName As String, fName As String)
On Error Resume Next
FileSystem.Kill fName
FileSystem.RmDir dirName
End Sub






Public Function lenReadFile(lxfDir As String, lxfFileName As String, blReadOfficials As Boolean) As Boolean
On Error GoTo fout
lenReadFile = False

If Not lenReadToXMLTables(lxfDir, lxfFileName) Then Exit Function


'now write to imp_len structures.
If Not lenReadFromXMLTables(blReadOfficials) Then Exit Function

If Not gXMLUtils.cleanupXMLStructureTables("fdtgLEN_XML_OBJECTS", "LEN_") Then Exit Function


lenReadFile = True
Exit Function
fout:
MsgBox Err & " lenReadFile" & vbCrLf & Error$, 16
Exit Function
End Function









Private Function lenRecList_BuildTable(tbName As String) As Boolean
On Error GoTo fout
lenRecList_BuildTable = False

DoCmd.DeleteObject acTable, tbName

Dim db As Database, tb As TableDef

Set db = CurrentDb()

Set tb = db.CreateTableDef(tbName)

tb.Fields.Append tb.CreateField("RL_FileURL", dbText)
tb.Fields.Append tb.CreateField("RL_Description", dbText, 255)
tb.Fields.Append tb.CreateField("RL_Type", dbText, 50)



db.TableDefs.Append tb

Set tb = Nothing
Set db = Nothing





lenRecList_BuildTable = True
Exit Function

fout:
If Err = 3011 Or Err = 7874 Then Resume Next 'could not find object to delete

MsgBox Err & " lenRecList_BuildTable" & vbCrLf & Error$, 16
Exit Function

End Function


Public Function lenImportRecordLists(fName As String, rlTbName As String) As Boolean
On Error GoTo fout
lenImportRecordLists = False


If Not lenRecList_BuildTable(rlTbName) Then
  Exit Function
End If


If Not lenReadToXMLTables(extractFilePath(fName), extractFileName(fName)) Then
  'clean up
  gXMLUtils.cleanupXMLStructureTables "fdtgLEN_XML_OBJECTS", "LEN_"
  Exit Function
End If

Dim sql As String
sql = "SELECT LEN_RECORDLIST.LEN_recordlistid, LEN_RECORDLIST.LEN_name, LEN_RECORDLIST.LEN_type FROM LEN_RECORDLIST " & _
      "GROUP BY LEN_RECORDLIST.LEN_recordlistid, LEN_RECORDLIST.LEN_name, LEN_RECORDLIST.LEN_type;"
      
Dim rls As Recordset
Set rls = CurrentDb().OpenRecordset(sql)

Dim rlOut As Recordset
Set rlOut = CurrentDb().OpenRecordset(rlTbName)


rls.MoveFirst
Do Until rls.EOF
  
  Dim tpListID As Long, tpListName As String, tpListType As String
  tpListID = Nz(rls("LEN_recordlistid"))
  tpListName = Nz(rls("LEN_name"))
  tpListType = Nz(rls("LEN_Type"))
  
  rlOut.AddNew
    rlOut("RL_FileURL") = "http://www.swimrankings.net/services/RecordLenex/records.lxf?RecordListId=" & tpListID
    rlOut("RL_Description") = hzn(tpListName)
    rlOut("RL_Type") = hzn(tpListType)
  rlOut.Update
  
  rls.MoveNext
Loop

appCleanRS rls
appCleanRS rlOut

If Not gXMLUtils.cleanupXMLStructureTables("fdtgLEN_XML_OBJECTS", "LEN_") Then
  Exit Function
End If


lenImportRecordLists = True
Exit Function
fout:
If (Err = 3021) Then Resume Next
MsgBox Err & " lenImportRecordLists" & vbCrLf & Error$, 16
Exit Function
End Function