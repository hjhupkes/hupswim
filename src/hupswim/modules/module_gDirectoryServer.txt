Option Compare Database
Option Explicit

Global Const MAX_N_DIR_SERVER_PRV_IDS = 10

'The maximum subtree directory depth
Global Const MAX_N_DIR_TREE_DEPTH = 100

Private Type DS_CACHE
  lCapacity As Long
  lDirtyProps() As Long
  nDirtyProps As Integer
  rbtPstIDToCacheID As RB_TREE_DATA
  rbtKeyToCacheID As RB_TREE_DATA
  lPropPstIDs() As Long
  sPropNames() As String
  sPropValues() As String
  blPropDirty() As Boolean
  nProps As Integer
  blIsTemporary As Boolean
  sLoadedSubtree As String
  blIsComplete As Boolean
  blAllowDirty As Boolean
End Type

Private Type DS_PST

  blIsTempTable As Boolean
  sTempTableName As String

  skDSIdx As Recordset
  skDSNP As Recordset

  nPrvFullNames As Integer
  sPrvFullNames(0 To MAX_N_DIR_SERVER_PRV_IDS) As String
  lPrvFullNameIDs(0 To MAX_N_DIR_SERVER_PRV_IDS) As Long
  iPrvFullNameHeader As Integer
  
  nPrvPartNames As Integer
  sPrvPartNames(0 To MAX_N_DIR_SERVER_PRV_IDS) As String
  lPrvPartParentIDs(0 To MAX_N_DIR_SERVER_PRV_IDS) As Long
  lPrvPartNameIDs(0 To MAX_N_DIR_SERVER_PRV_IDS) As Long
  iPrvPartNameHeader As Integer
End Type

Private Type PARTIAL_MATCH
  blIsFullMatch As Boolean
  lFullPropID As Long
  lLastParentPropID As Long
  sNameLeftToMatch As String
End Type

Type DIR_SERVER_DATA
  lMaxUsedID As Long
  cache As DS_CACHE
  pst As DS_PST
End Type

Private Function dsPstIntCreateTable(ByRef db As Database, ByVal tbName As String) As Boolean
On Error GoTo fout
dsPstIntCreateTable = False

DoCmd.DeleteObject acTable, tbName


Dim tb As TableDef

Set tb = db.CreateTableDef(tbName)


tb.Fields.Append tb.CreateField("DIR_ID", dbLong)
tb.Fields.Append tb.CreateField("DIR_PARENT_ID", dbLong)
tb.Fields.Append tb.CreateField("DIR_Name", dbText, 50)
tb.Fields.Append tb.CreateField("DIR_Value", dbText, 255)

Dim idx As Index

Set idx = tb.CreateIndex("PrimaryKey")

idx.Fields.Append idx.CreateField("DIR_ID", dbLong)
idx.Primary = True

tb.Indexes.Append idx

Set idx = Nothing

Set idx = tb.CreateIndex("LocateByNameAndParent")
idx.Fields.Append idx.CreateField("DIR_Name", dbText, 50)
idx.Fields.Append idx.CreateField("DIR_PARENT_ID", dbLong)
idx.Unique = True

tb.Indexes.Append idx

Set idx = Nothing

db.TableDefs.Append tb

Set tb = Nothing





dsPstIntCreateTable = True
Exit Function

fout:
If (Err = 3011) Or (Err = 7874) Then Resume Next

MsgBox Err & " dsPstIntCreateTable" & vbCrLf & Error$, 16
Exit Function

End Function



Private Sub dsPstIntPrvListAddFullName(ByRef dsData As DIR_SERVER_DATA, ByVal sFullName As String, ByVal propID As Long)

'first check if it currently is in list

Dim isInList As Boolean
isInList = False

Dim i As Integer
For i = 0 To dsData.pst.nPrvFullNames - 1
  If (dsData.pst.sPrvFullNames(i) = sFullName) Then
    isInList = True
    Exit For
  End If
Next i


If (Not isInList) Then
  Dim insPos As Integer
  
  If (dsData.pst.nPrvFullNames < MAX_N_DIR_SERVER_PRV_IDS) Then
    insPos = dsData.pst.nPrvFullNames
    dsData.pst.nPrvFullNames = dsData.pst.nPrvFullNames + 1
  Else
    dsData.pst.iPrvFullNameHeader = dsData.pst.iPrvFullNameHeader - 1
    If (dsData.pst.iPrvFullNameHeader < 0) Then
      dsData.pst.iPrvFullNameHeader = MAX_N_DIR_SERVER_PRV_IDS - 1
    End If
    insPos = dsData.pst.iPrvFullNameHeader
  End If
  
  dsData.pst.sPrvFullNames(insPos) = sFullName
  dsData.pst.lPrvFullNameIDs(insPos) = propID
  
End If



End Sub


Private Sub dsPstIntPrvListAddPartName(ByRef dsData As DIR_SERVER_DATA, ByVal sPartName As String, ByVal lParentID As Long, ByVal propID As Long)

'first check if it currently is in list

Dim isInList As Boolean
isInList = False

Dim i As Integer
For i = 0 To dsData.pst.nPrvPartNames - 1
  If (dsData.pst.sPrvPartNames(i) = sPartName) And (dsData.pst.lPrvPartParentIDs(i) = lParentID) Then
    isInList = True
    Exit For
  End If
Next i


If (Not isInList) Then
  Dim insPos As Integer
  
  If (dsData.pst.nPrvPartNames < MAX_N_DIR_SERVER_PRV_IDS) Then
    insPos = dsData.pst.nPrvPartNames
    dsData.pst.nPrvPartNames = dsData.pst.nPrvPartNames + 1
  Else
    dsData.pst.iPrvPartNameHeader = dsData.pst.iPrvPartNameHeader - 1
    If (dsData.pst.iPrvPartNameHeader < 0) Then
      dsData.pst.iPrvPartNameHeader = MAX_N_DIR_SERVER_PRV_IDS - 1
    End If
    insPos = dsData.pst.iPrvPartNameHeader
  End If
  
  dsData.pst.sPrvPartNames(insPos) = sPartName
  dsData.pst.lPrvPartParentIDs(insPos) = lParentID
  dsData.pst.lPrvPartNameIDs(insPos) = propID
  
End If



End Sub



Private Function dsPstIntPrvListCheckFullNames(ByRef dsData As DIR_SERVER_DATA, ByVal sFullName As String, ByRef isFnd As Boolean, ByRef propID As Long) As Boolean
On Error GoTo fout
dsPstIntPrvListCheckFullNames = False


isFnd = False
propID = -1

Dim i As Integer
For i = 0 To dsData.pst.nPrvFullNames - 1
  If (dsData.pst.sPrvFullNames(i) = sFullName) Then
    isFnd = True
    propID = dsData.pst.lPrvFullNameIDs(i)
    Exit For
  End If
Next i



dsPstIntPrvListCheckFullNames = True
Exit Function

fout:
MsgBox Err & " dsPstIntPrvListCheckFullNames" & vbCrLf & Error$, 16
Exit Function

End Function

Private Function dsPstIntPrvListCheckPartNames(ByRef dsData As DIR_SERVER_DATA, ByVal sPartName As String, ByVal lParentID As Long, ByRef isFnd As Boolean, ByRef propID As Long) As Boolean
On Error GoTo fout
dsPstIntPrvListCheckPartNames = False


isFnd = False
propID = -1

Dim i As Integer
For i = 0 To dsData.pst.nPrvPartNames - 1
  If (dsData.pst.sPrvPartNames(i) = sPartName) And (dsData.pst.lPrvPartParentIDs(i) = lParentID) Then
    isFnd = True
    propID = dsData.pst.lPrvPartNameIDs(i)
    Exit For
  End If
Next i



dsPstIntPrvListCheckPartNames = True
Exit Function

fout:
MsgBox Err & " dsPstIntPrvListCheckPartNames" & vbCrLf & Error$, 16
Exit Function

End Function


Private Function dsPstIntPrvListDelete_delPartList(ByRef dsData As DIR_SERVER_DATA, lPropID As Long) As Boolean
On Error GoTo fout
dsPstIntPrvListDelete_delPartList = False



Dim isInList As Boolean, listPos As Integer
isInList = False

Dim i As Integer
For i = 0 To dsData.pst.nPrvPartNames - 1
  If (dsData.pst.lPrvPartNameIDs(i) = lPropID) Then
    isInList = True
    listPos = i
    Exit For
  End If
Next i


If (isInList) Then

  'Need to extract from the list.
  'Simply move last item back & reset the header
  
  dsData.pst.nPrvPartNames = dsData.pst.nPrvPartNames - 1
  dsData.pst.iPrvPartNameHeader = 0
  
  If (listPos <> dsData.pst.nPrvPartNames) Then
    dsData.pst.sPrvPartNames(listPos) = dsData.pst.sPrvPartNames(dsData.pst.nPrvPartNames)
    dsData.pst.lPrvPartParentIDs(listPos) = dsData.pst.lPrvPartParentIDs(dsData.pst.nPrvPartNames)
    dsData.pst.lPrvPartNameIDs(listPos) = dsData.pst.lPrvPartNameIDs(dsData.pst.nPrvPartNames)
  End If
  
  
End If






dsPstIntPrvListDelete_delPartList = True
Exit Function

fout:
MsgBox Err & " dsPstIntPrvListDelete_delPartList" & vbCrLf & Error$, 16
Exit Function
End Function


Private Function dsPstIntPrvListDelete_delFullList(ByRef dsData As DIR_SERVER_DATA, lPropID As Long) As Boolean
On Error GoTo fout
dsPstIntPrvListDelete_delFullList = False



Dim isInList As Boolean, listPos As Integer
isInList = False

Dim i As Integer
For i = 0 To dsData.pst.nPrvFullNames - 1
  If (dsData.pst.lPrvFullNameIDs(i) = lPropID) Then
    isInList = True
    listPos = i
    Exit For
  End If
Next i


If (isInList) Then

  'Need to extract from the list.
  'Simply move last item back & reset the header
  
  dsData.pst.nPrvFullNames = dsData.pst.nPrvFullNames - 1
  dsData.pst.iPrvFullNameHeader = 0
  
  If (listPos <> dsData.pst.nPrvFullNames) Then
    dsData.pst.sPrvFullNames(listPos) = dsData.pst.sPrvFullNames(dsData.pst.nPrvFullNames)
    dsData.pst.lPrvFullNameIDs(listPos) = dsData.pst.lPrvFullNameIDs(dsData.pst.nPrvFullNames)
  End If
  
  
End If






dsPstIntPrvListDelete_delFullList = True
Exit Function

fout:
MsgBox Err & " dsPstIntPrvListDelete_delFullList" & vbCrLf & Error$, 16
Exit Function
End Function



Private Function dsPstIntPrvListDelete(ByRef dsData As DIR_SERVER_DATA, lPropID As Long) As Boolean
On Error GoTo fout
dsPstIntPrvListDelete = False


If Not dsPstIntPrvListDelete_delPartList(dsData, lPropID) Then
  Exit Function
End If

If Not dsPstIntPrvListDelete_delFullList(dsData, lPropID) Then
  Exit Function
End If


dsPstIntPrvListDelete = True
Exit Function

fout:
MsgBox Err & " dsPstIntPrvListDelete" & vbCrLf & Error$, 16
Exit Function
End Function


Private Sub dsPstIntPrvListClean(ByRef dsData As DIR_SERVER_DATA)

dsData.pst.nPrvFullNames = 0
dsData.pst.iPrvFullNameHeader = 0

dsData.pst.nPrvPartNames = 0
dsData.pst.iPrvPartNameHeader = 0

End Sub

Private Function dsPstClean(ByRef dsData As DIR_SERVER_DATA) As Boolean
On Error GoTo fout
dsPstClean = False

appCleanRS dsData.pst.skDSIdx
appCleanRS dsData.pst.skDSNP

If (dsData.pst.blIsTempTable) Then
  DoCmd.DeleteObject acTable, dsData.pst.sTempTableName
End If

dsPstClean = True
Exit Function

fout:
If (Err = 3011) Or (Err = 7874) Then Resume Next

Dim errInf As ERR_INFO
appRecordError "dsPstClean", errInf

appDisplayError errInf
Exit Function

End Function

Private Function dsPstInit(ByRef db As Database, ByRef dsData As DIR_SERVER_DATA, ByVal blUseTempTable, ByVal sTableName As String, ByRef lPstMaxUsedID As Long) As Boolean
On Error GoTo fout
dsPstInit = False


dsData.pst.blIsTempTable = False
dsData.pst.sTempTableName = ""

Dim sActTableName As String

If (sTableName = "") Then
  sActTableName = "dtgDirectoryServer"
Else
  sActTableName = sTableName
End If

If (blUseTempTable) Then
  If Not dsPstIntCreateTable(db, sActTableName) Then
    Exit Function
  End If
  
  dsData.pst.blIsTempTable = True
  dsData.pst.sTempTableName = sActTableName
  
End If

Set dsData.pst.skDSIdx = db.OpenRecordset(sActTableName)
dsData.pst.skDSIdx.Index = "PrimaryKey"

Set dsData.pst.skDSNP = db.OpenRecordset(sActTableName)
dsData.pst.skDSNP.Index = "LocateByNameAndParent"



lPstMaxUsedID = Nz(DMax("DIR_ID", sActTableName), 0)


'Initialize the previous lookup list
dsPstIntPrvListClean dsData



dsPstInit = True
Exit Function

fout:
Dim errInf As ERR_INFO
appRecordError "dsPstInit", errInf

appDisplayError errInf
Exit Function

End Function



Public Function dsInit(ByRef dsData As DIR_SERVER_DATA, ByVal blUseTempTable As Boolean, ByVal sTableName As String, Optional lCacheCapacity As Long = 0) As Boolean
On Error GoTo fout
dsInit = False

Dim db As Database
Set db = CurrentDb()

If Not dsInit_Transactional(db, dsData, blUseTempTable, sTableName, lCacheCapacity) Then
  Exit Function
End If

Set db = Nothing

dsInit = True
Exit Function

fout:
MsgBox Err & " dsInit" & vbCrLf & Error$, 16
Exit Function
End Function


Public Function dsInit_Transactional(ByRef db As Database, ByRef dsData As DIR_SERVER_DATA, ByVal blUseTempTable As Boolean, ByVal sTableName As String, Optional ByVal lCacheCapacity As Long = 0) As Boolean
On Error GoTo fout
dsInit_Transactional = False

Dim lPstMaxUsedID As Long

If Not dsPstInit(db, dsData, blUseTempTable, sTableName, lPstMaxUsedID) Then
  appRaiseSilentError
End If

dsData.lMaxUsedID = lPstMaxUsedID

If Not dsCacheInit(dsData, lCacheCapacity, blUseTempTable) Then
  appRaiseSilentError
End If


dsInit_Transactional = True

Exit Function

fout:

Dim errInf As ERR_INFO
appRecordError "dsInit_Transactional", errInf

appDisplayError errInf
Exit Function

'debug
On Error GoTo 0
Resume

End Function


Public Function dsClean(ByRef dsData As DIR_SERVER_DATA) As Boolean
On Error GoTo fout

dsClean = False


If Not dsPstClean(dsData) Then
  appRaiseSilentError
End If

If Not dsCacheClean(dsData) Then
  appRaiseSilentError
End If

dsClean = True

Exit Function

fout:
Dim errInf As ERR_INFO
appRecordError "dsClean", errInf

appDisplayError errInf
Exit Function

End Function

Private Function dsPstFindPropertyID(ByRef dsData As DIR_SERVER_DATA, ByVal sPropFullName As String, ByRef pm As PARTIAL_MATCH) As Boolean
On Error GoTo fout
dsPstFindPropertyID = False


  


Dim tpPropFullName As String
tpPropFullName = sPropFullName

pm.blIsFullMatch = False
pm.lFullPropID = -1
pm.lLastParentPropID = -1
pm.sNameLeftToMatch = ""


'Need to explicitly exclude empty name
If (tpPropFullName = "") Then
  dsPstFindPropertyID = True
  Exit Function
End If




If Not dsPstIntPrvListCheckFullNames(dsData, tpPropFullName, pm.blIsFullMatch, pm.lFullPropID) Then
  appRaiseSilentError
End If

If (Not pm.blIsFullMatch) Then

    
  Dim curParentID As Long
  Dim curName As String
  
  curParentID = -1
  curName = extractToken(tpPropFullName, "\")
  
  While (curName <> "")
  
    Dim tpPartIsFnd As Boolean
    Dim tpPartID As Long
    
    If Not dsPstIntPrvListCheckPartNames(dsData, curName, curParentID, tpPartIsFnd, tpPartID) Then
      Exit Function
    End If
    
    If (Not tpPartIsFnd) Then
    
      dsData.pst.skDSNP.Seek "=", curName, curParentID
      
      If (dsData.pst.skDSNP.NoMatch) Then
        pm.blIsFullMatch = False
        pm.lLastParentPropID = curParentID
        pm.sNameLeftToMatch = curName
        If (tpPropFullName <> "") Then
          pm.sNameLeftToMatch = pm.sNameLeftToMatch & "\" & tpPropFullName
        End If
        
        dsPstFindPropertyID = True
        Exit Function
      End If
      
      Dim tpNewID As Long
      tpNewID = Nz(dsData.pst.skDSNP("DIR_ID"), -1)
      
      If (tpNewID < 0) Then
        Err.Raise 1, , "Internal error"
      End If
      
      dsPstIntPrvListAddPartName dsData, curName, curParentID, tpNewID
      
      curParentID = tpNewID
    Else
      curParentID = tpPartID
    End If
    
    curName = extractToken(tpPropFullName, "\")
  
  Wend
  
  'We have found the property
  pm.lFullPropID = curParentID
  pm.blIsFullMatch = True
  
  dsPstIntPrvListAddFullName dsData, sPropFullName, pm.lFullPropID


End If 'if not isFnd


dsPstFindPropertyID = True

Exit Function

fout:

Dim errInf As ERR_INFO
appRecordError "dsPstFindPropertyID", errInf

appDisplayError errInf
Exit Function

End Function



Private Function dsPstLookupPropertyByName(ByRef dsData As DIR_SERVER_DATA, ByVal sPropFullName As String, ByRef sPropValue As String, ByRef isPresent As Boolean, ByRef lPropID As Long, ByRef pm As PARTIAL_MATCH) As Boolean
On Error GoTo fout
dsPstLookupPropertyByName = False


lPropID = -1
isPresent = False
sPropValue = ""


If Not dsPstFindPropertyID(dsData, sPropFullName, pm) Then
  appRaiseSilentError
End If

If (pm.blIsFullMatch) Then
  lPropID = pm.lFullPropID
  If Not dsPstLookupPropertyValueByID(dsData, lPropID, sPropValue, isPresent) Then
    Exit Function
  End If
End If


dsPstLookupPropertyByName = True

Exit Function

fout:
Dim errInf As ERR_INFO
appRecordError "dsPstLookupPropertyByName", errInf

appDisplayError errInf
Exit Function

End Function



Private Function dsIntLookupPropertyByName(ByRef dsData As DIR_SERVER_DATA, ByVal sPropFullName As String, ByRef sPropValue As String, ByRef isPresent As Boolean, ByRef lPropID As Long) As Boolean
On Error GoTo fout
dsIntLookupPropertyByName = False


lPropID = -1
isPresent = False
sPropValue = ""

'first look in cache
Dim lCacheID As Long, blIsFinal As Boolean
If Not dsCacheLookupByName(dsData, sPropFullName, isPresent, sPropValue, lPropID, lCacheID, blIsFinal) Then
  appRaiseSilentError
End If


'if not found in cache; look in persistent storage
If (Not blIsFinal) And (Not isPresent) Then
  Dim pm As PARTIAL_MATCH
  If Not dsPstLookupPropertyByName(dsData, sPropFullName, sPropValue, isPresent, lPropID, pm) Then
    appRaiseSilentError
  End If
End If


dsIntLookupPropertyByName = True

Exit Function

fout:
Dim errInf As ERR_INFO
appRecordError "dsIntLookupPropertyByName", errInf

appDisplayError errInf
Exit Function

End Function

Private Function dsPstLookupPropertyNameByID(ByRef dsData As DIR_SERVER_DATA, ByVal lPropID As Long, ByRef sPropName As String, ByRef isPresent As Boolean) As Boolean
On Error GoTo fout
dsPstLookupPropertyNameByID = False

isPresent = False
sPropName = ""

dsData.pst.skDSIdx.Seek "=", lPropID
If (Not dsData.pst.skDSIdx.NoMatch) Then
  isPresent = True
  
  sPropName = Nz(dsData.pst.skDSIdx("DIR_Name"))
  
  Dim tpPropID As Long
  tpPropID = Nz(dsData.pst.skDSIdx("DIR_Parent_ID"))
    
  While tpPropID <> -1
    dsData.pst.skDSIdx.Seek "=", tpPropID
    If dsData.pst.skDSIdx.NoMatch Then
      Err.Raise 1, , "internal error"
    End If
    sPropName = Nz(dsData.pst.skDSIdx("DIR_Name")) & "\" & sPropName
    tpPropID = Nz(dsData.pst.skDSIdx("DIR_Parent_ID"))
  Wend
  
End If

dsPstLookupPropertyNameByID = False = True

Exit Function

fout:
MsgBox Err & " dsPstLookupPropertyNameByID" & vbCrLf & Error$, 16
Exit Function

End Function

Private Function dsPstLookupPropertyValueByID(ByRef dsData As DIR_SERVER_DATA, ByVal lPropID As Long, ByRef sPropValue As String, ByRef isPresent As Boolean) As Boolean
On Error GoTo fout
dsPstLookupPropertyValueByID = False

isPresent = False
sPropValue = ""

dsData.pst.skDSIdx.Seek "=", lPropID
If (Not dsData.pst.skDSIdx.NoMatch) Then
  isPresent = True
  sPropValue = Nz(dsData.pst.skDSIdx("DIR_Value"))
End If

dsPstLookupPropertyValueByID = True

Exit Function

fout:
MsgBox Err & " dsPstLookupPropertyValueByID" & vbCrLf & Error$, 16
Exit Function
End Function

Private Function dsIntLookupPropertyByID(ByRef dsData As DIR_SERVER_DATA, ByVal lPropID As Long, ByRef sPropFullName As String, ByRef sPropValue As String, ByRef isPresent As Boolean) As Boolean
On Error GoTo fout
dsIntLookupPropertyByID = False

isPresent = False
sPropValue = ""


'first look in cache
Dim lCacheID As Long, blIsFinal As Boolean
If Not dsCacheLookupByID(dsData, lPropID, isPresent, sPropFullName, sPropValue, lCacheID, blIsFinal) Then
  appRaiseSilentError
End If


'if not found in cache; look in persistent storage
If (Not blIsFinal) And (Not isPresent) Then
  If Not dsPstLookupPropertyValueByID(dsData, lPropID, sPropValue, isPresent) Then
    appRaiseSilentError
  End If
  If Not dsPstLookupPropertyNameByID(dsData, lPropID, sPropFullName, isPresent) Then
    appRaiseSilentError
  End If
End If



dsIntLookupPropertyByID = True

Exit Function

fout:
Dim errInf As ERR_INFO
appRecordError "dsIntLookupPropertyByID", errInf

appDisplayError errInf
Exit Function

End Function



Private Function dsPstIntDirAddProperty(ByRef dsData As DIR_SERVER_DATA, ByVal lPropID As Long, ByVal lParentID As Long) As Boolean
On Error GoTo fout
dsPstIntDirAddProperty = False


 
'need to mark propery in parent directory listing.
Dim tpParentListID As Long
dsData.pst.skDSNP.Seek "=", "_int_ds_listing", lParentID
If (dsData.pst.skDSNP.NoMatch) Then
  dsData.pst.skDSNP.AddNew
    tpParentListID = dsData.lMaxUsedID + 1
    dsData.lMaxUsedID = tpParentListID
  
    dsData.pst.skDSNP("DIR_ID") = tpParentListID
  
    dsData.pst.skDSNP("DIR_Parent_ID") = lParentID
    dsData.pst.skDSNP("DIR_NAME") = "_int_ds_listing"
    dsData.pst.skDSNP("DIR_VALUE") = Null
  dsData.pst.skDSNP.Update
Else
  tpParentListID = Nz(dsData.pst.skDSNP("DIR_ID"), -1)
End If

If (tpParentListID < 0) Then
  Err.Raise 1, , "Internal error"
End If

'Now need to find counter
Dim tpIdxInDir As Long

dsData.pst.skDSNP.Seek "=", "_int_ds_counter", tpParentListID

If (dsData.pst.skDSNP.NoMatch) Then
  'Need to add counter
  dsData.pst.skDSNP.AddNew
    Dim tpNewID As Long
    tpNewID = dsData.lMaxUsedID + 1
    dsData.lMaxUsedID = tpNewID
  
    dsData.pst.skDSNP("DIR_ID") = tpNewID
    
    dsData.pst.skDSNP("DIR_Parent_ID") = tpParentListID
    dsData.pst.skDSNP("DIR_NAME") = "_int_ds_counter"
    dsData.pst.skDSNP("DIR_VALUE") = "1"
  dsData.pst.skDSNP.Update
  tpIdxInDir = 0
Else
  'Need to increment counter
  tpIdxInDir = CLng(Nz(dsData.pst.skDSNP("DIR_Value")))
  dsData.pst.skDSNP.Edit
    dsData.pst.skDSNP("DIR_Value") = tpIdxInDir + 1
  dsData.pst.skDSNP.Update
End If

'Need to add record for new property
dsData.pst.skDSNP.AddNew

  tpNewID = dsData.lMaxUsedID + 1
  dsData.lMaxUsedID = tpNewID

  dsData.pst.skDSNP("DIR_ID") = tpNewID

  dsData.pst.skDSNP("DIR_Name") = "_int_ds_id_for_pos_" & tpIdxInDir
  dsData.pst.skDSNP("DIR_Value") = lPropID
  dsData.pst.skDSNP("DIR_Parent_ID") = tpParentListID
dsData.pst.skDSNP.Update

dsData.pst.skDSNP.AddNew
  tpNewID = dsData.lMaxUsedID + 1
  dsData.lMaxUsedID = tpNewID

  dsData.pst.skDSNP("DIR_ID") = tpNewID
  
  dsData.pst.skDSNP("DIR_Name") = "_int_ds_pos_for_id_" & lPropID
  dsData.pst.skDSNP("DIR_Value") = tpIdxInDir
  dsData.pst.skDSNP("DIR_Parent_ID") = tpParentListID
dsData.pst.skDSNP.Update
  

dsPstIntDirAddProperty = True
Exit Function

fout:
MsgBox Err & " dsPstIntDirAddProperty" & vbCrLf & Error$, 16
Exit Function
End Function




Private Function dsIntDeletePropertyByID(ByRef dsData As DIR_SERVER_DATA, ByVal lPropID As Long, ByRef sPrevValue As String) As Boolean
On Error GoTo fout
dsIntDeletePropertyByID = False


If Not dsCachePrepPstOp(dsData) Then
  appRaiseSilentError
End If

If Not dsPstDeletePropertyByID(dsData, lPropID, sPrevValue) Then
  appRaiseSilentError
End If

dsIntDeletePropertyByID = True
Exit Function

fout:
Dim errInf As ERR_INFO
appRecordError "dsIntDeletePropertyByID", errInf

appDisplayError errInf
Exit Function
End Function


Private Function dsPstDeletePropertyByName(ByRef dsData As DIR_SERVER_DATA, ByVal sPropFullName As String, ByRef blWasPresent As Boolean, ByRef sPrevValue As String) As Boolean
On Error GoTo fout
dsPstDeletePropertyByName = False

blWasPresent = False

Dim pm As PARTIAL_MATCH
If Not dsPstFindPropertyID(dsData, sPropFullName, pm) Then
  appRaiseSilentError
End If

If pm.blIsFullMatch Then
  blWasPresent = True
  If Not dsPstDeletePropertyByID(dsData, pm.lFullPropID, sPrevValue) Then
    appRaiseSilentError
  End If
End If

dsPstDeletePropertyByName = True
Exit Function

fout:
Dim errInf As ERR_INFO
appRecordError "dsPstDeletePropertyByName", errInf

appDisplayError errInf
Exit Function
End Function



Private Function dsPstDeletePropertyByID(ByRef dsData As DIR_SERVER_DATA, ByVal lPropID As Long, ByRef sPrevValue As String) As Boolean
On Error GoTo fout
dsPstDeletePropertyByID = False


Dim lParentID As Long

dsData.pst.skDSIdx.Seek "=", lPropID

If (dsData.pst.skDSIdx.NoMatch) Then
  Err.Raise 1, , "Internal error. Property not found"
End If



lParentID = CLng(Nz(dsData.pst.skDSIdx("DIR_PARENT_ID")))

sPrevValue = Nz(dsData.pst.skDSIdx("DIR_Value"))

dsData.pst.skDSIdx.Delete

If Not dsPstIntPrvListDelete(dsData, lPropID) Then
  Exit Function
End If


If Not dsPstIntDirRemoveProperty(dsData, lPropID, lParentID) Then
  Exit Function
End If

If Not dsPstIntDeletePropertyByID_clearSubTree(dsData, lPropID) Then
  Exit Function
End If




dsPstDeletePropertyByID = True
Exit Function

fout:
MsgBox Err & " dsPstDeletePropertyByID" & vbCrLf & Error$, 16
Exit Function
End Function


Private Function dsPstIntDirRemoveProperty(ByRef dsData As DIR_SERVER_DATA, ByVal lPropID As Long, ByVal lParentID As Long) As Boolean
On Error GoTo fout
dsPstIntDirRemoveProperty = False


'Remove the property from any lists from the list
  
Dim tpParentListID As Long
dsData.pst.skDSNP.Seek "=", "_int_ds_listing", lParentID
  
If (dsData.pst.skDSNP.NoMatch) Then
  Err.Raise 1, , "Internal error"
End If

tpParentListID = Nz(dsData.pst.skDSNP("DIR_ID"), -1)
  
dsData.pst.skDSNP.Seek "=", "_int_ds_counter", tpParentListID
  
If (dsData.pst.skDSNP.NoMatch) Then
  Err.Raise 1, , "internal error"
End If
    
'Need to decrement counter

Dim tpDirCnt As Long
tpDirCnt = CLng(Nz(dsData.pst.skDSNP("DIR_Value")))

dsData.pst.skDSNP.Edit
  dsData.pst.skDSNP("DIR_Value") = tpDirCnt - 1
dsData.pst.skDSNP.Update


Dim tpPropIDToDel As Long


Dim tpIdxInDir As Integer

    
  
dsData.pst.skDSNP.Seek "=", "_int_ds_pos_for_id_" & lPropID, tpParentListID

If (dsData.pst.skDSNP.NoMatch) Then
  Err.Raise 1, , "Internal error"
End If

tpIdxInDir = CLng(Nz(dsData.pst.skDSNP("DIR_Value")))

'Now remove this node

tpPropIDToDel = Nz(dsData.pst.skDSNP("DIR_ID"))

dsData.pst.skDSNP.Delete

If Not dsPstIntPrvListDelete(dsData, tpPropIDToDel) Then
  Exit Function
End If


'get the id at the last position
dsData.pst.skDSNP.Seek "=", "_int_ds_id_for_pos_" & (tpDirCnt - 1), tpParentListID

If (dsData.pst.skDSNP.NoMatch) Then
  Err.Raise 1, , "Internal error"
End If

Dim tpIDLastPos As Long
tpIDLastPos = CLng(Nz(dsData.pst.skDSNP("DIR_Value")))

'remove this node

tpPropIDToDel = Nz(dsData.pst.skDSNP("DIR_ID"))

dsData.pst.skDSNP.Delete

If Not dsPstIntPrvListDelete(dsData, tpPropIDToDel) Then
  Exit Function
End If


If (tpIdxInDir <> (tpDirCnt - 1)) Then
  
  'now move the last position to the freed up position
  dsData.pst.skDSNP.Seek "=", "_int_ds_pos_for_id_" & tpIDLastPos, tpParentListID
  
  If (dsData.pst.skDSNP.NoMatch) Then
    Err.Raise 1, , "internal error"
  End If
  
  dsData.pst.skDSNP.Edit
    dsData.pst.skDSNP("DIR_Value") = tpIdxInDir
  dsData.pst.skDSNP.Update
  
  dsData.pst.skDSNP.Seek "=", "_int_ds_id_for_pos_" & tpIdxInDir, tpParentListID
  
  If (dsData.pst.skDSNP.NoMatch) Then
    Err.Raise 1, , "internal error"
  End If
  
  dsData.pst.skDSNP.Edit
    dsData.pst.skDSNP("DIR_Value") = tpIDLastPos
  dsData.pst.skDSNP.Update
  
End If


dsPstIntDirRemoveProperty = True
Exit Function

fout:
MsgBox Err & " dsPstIntDirRemoveProperty" & vbCrLf & Error$, 16
Exit Function

'debug
On Error GoTo 0
Resume

End Function

'This deletes everything in the directory specified by rootID (including subdirectories).
'The element rootID itself is not deleted
Private Function dsPstIntDeletePropertyByID_clearSubTree(ByRef dsData As DIR_SERVER_DATA, ByVal rootID As Long) As Boolean
On Error GoTo fout
dsPstIntDeletePropertyByID_clearSubTree = False


'We will perform a depth first search, deleting everything as we go.

Dim dirIDs(0 To MAX_N_DIR_TREE_DEPTH) As Long
Dim dirIDCurPos(0 To MAX_N_DIR_TREE_DEPTH) As Long
Dim dirIDCnt(0 To MAX_N_DIR_TREE_DEPTH) As Long
Dim dirIDListID(0 To MAX_N_DIR_TREE_DEPTH) As Long


Dim curDepth As Integer
curDepth = 0

dirIDs(0) = rootID
dirIDCurPos(0) = -1

While (curDepth >= 0)
  
  
  If (dirIDCurPos(curDepth) = -1) Then
    'need to initialize count
    dirIDCnt(curDepth) = 0
    dirIDListID(curDepth) = -1
    
    
    dsData.pst.skDSNP.Seek "=", "_int_ds_listing", dirIDs(curDepth)
    
    If (Not dsData.pst.skDSNP.NoMatch) Then
      dirIDListID(curDepth) = Nz(dsData.pst.skDSNP("DIR_ID"))
      'delete the list directory main node
            
      Dim tpPropIDToDel As Long
      tpPropIDToDel = Nz(dsData.pst.skDSNP("DIR_ID"))

      dsData.pst.skDSNP.Delete
      
      If Not dsPstIntPrvListDelete(dsData, tpPropIDToDel) Then
        Exit Function
      End If

      
     
      'look for the count node
      dsData.pst.skDSNP.Seek "=", "_int_ds_counter", dirIDListID(curDepth)
      
      If (Not dsData.pst.skDSNP.NoMatch) Then
        dirIDCnt(curDepth) = CLng(Nz(dsData.pst.skDSNP("DIR_VALUE")))
        
        'delete the count node
        
        tpPropIDToDel = Nz(dsData.pst.skDSNP("DIR_ID"))

        dsData.pst.skDSNP.Delete
        
        If Not dsPstIntPrvListDelete(dsData, tpPropIDToDel) Then
          Exit Function
        End If

      End If
    End If
    
    
    
  End If
  
  'advance the current position
  dirIDCurPos(curDepth) = dirIDCurPos(curDepth) + 1
  
  'Check if we are done in the current subdirectory.
  
  If (dirIDCurPos(curDepth) >= dirIDCnt(curDepth)) Then
    'we are done with this directory
    curDepth = curDepth - 1
  Else
  
    'need to process the current position.
    
    Dim lChildID As Long
    dsData.pst.skDSNP.Seek "=", "_int_ds_id_for_pos_" & dirIDCurPos(curDepth), dirIDListID(curDepth)
    
    If (dsData.pst.skDSNP.NoMatch) Then
      Err.Raise 1, , "internal error"
    End If
    
    lChildID = CLng(Nz(dsData.pst.skDSNP("DIR_Value")))
    
    'delete the node
            
    tpPropIDToDel = Nz(dsData.pst.skDSNP("DIR_ID"))
        
    dsData.pst.skDSNP.Delete
    
    If Not dsPstIntPrvListDelete(dsData, tpPropIDToDel) Then
      Exit Function
    End If
    
    
    'find the pos_for_id node and delete it
    dsData.pst.skDSNP.Seek "=", "_int_ds_pos_for_id_" & lChildID, dirIDListID(curDepth)
    
    If (dsData.pst.skDSNP.NoMatch) Then
      Err.Raise 1, , "internal error"
    End If
    
    tpPropIDToDel = Nz(dsData.pst.skDSNP("DIR_ID"))
        
    dsData.pst.skDSNP.Delete
    
    If Not dsPstIntPrvListDelete(dsData, tpPropIDToDel) Then
      Exit Function
    End If
        
    
    'Now delete the child node
    dsData.pst.skDSIdx.Seek "=", lChildID
    If dsData.pst.skDSIdx.NoMatch Then
      Err.Raise 1, , "internal error"
    End If
    dsData.pst.skDSIdx.Delete
    
    If Not dsPstIntPrvListDelete(dsData, lChildID) Then
      Exit Function
    End If
    
  
    dirIDs(curDepth + 1) = lChildID
    dirIDCurPos(curDepth + 1) = -1
    
    
    'move on to this new directory
    
    curDepth = curDepth + 1
  
  
  
  End If
  




Wend




dsPstIntDeletePropertyByID_clearSubTree = True

Exit Function

fout:

MsgBox Err & " dsPstIntDeletePropertyByID_clearSubTree" & vbCrLf & Error$, 16
Exit Function
End Function


Private Function dsIntRenamePropertyByName(ByRef dsData As DIR_SERVER_DATA, ByVal sPropFullName As String, ByVal sNewFullName As String) As Boolean
On Error GoTo fout
dsIntRenamePropertyByName = False

If Not dsCachePrepPstOp(dsData) Then
  appRaiseSilentError
End If

If Not dsPstRenamePropertyByName(dsData, sPropFullName, sNewFullName) Then
  appRaiseSilentError
End If

dsIntRenamePropertyByName = True
Exit Function

fout:
Dim errInf As ERR_INFO
appRecordError "dsIntRenamePropertyByName", errInf

appDisplayError errInf
Exit Function

End Function



Private Function dsPstRenamePropertyByName(ByRef dsData As DIR_SERVER_DATA, ByVal sPropFullName As String, ByVal sNewFullName As String) As Boolean
On Error GoTo fout
dsPstRenamePropertyByName = False

Dim blDummy As Boolean
Dim lPropID As Long, blIsFnd As Boolean
Dim lDummy As Long, sDummy As String

Dim pm As PARTIAL_MATCH

If Not dsPstFindPropertyID(dsData, sPropFullName, pm) Then
  Exit Function
End If

If (pm.blIsFullMatch) Then
  If Not dsPstRenamePropertyByID(dsData, pm.lFullPropID, sNewFullName) Then
    Exit Function
  End If
End If



dsPstRenamePropertyByName = True
Exit Function

fout:
MsgBox Err & " dsPstRenamePropertyByName" & vbCrLf & Error$, 16
Exit Function

End Function


Private Function dsIntRenamePropertyByID(ByRef dsData As DIR_SERVER_DATA, ByVal lPropID As Long, ByVal sNewFullName As String) As Boolean
On Error GoTo fout
dsIntRenamePropertyByID = False

If Not dsCachePrepPstOp(dsData) Then
  appRaiseSilentError
End If

If Not dsPstRenamePropertyByID(dsData, lPropID, sNewFullName) Then
  appRaiseSilentError
End If

dsIntRenamePropertyByID = True
Exit Function

fout:
Dim errInf As ERR_INFO
appRecordError "dsIntRenamePropertyByID", errInf

appDisplayError errInf
Exit Function
End Function


Private Function dsPstRenamePropertyByID(ByRef dsData As DIR_SERVER_DATA, ByVal lPropID As Long, ByVal sNewFullName As String) As Boolean
On Error GoTo fout
dsPstRenamePropertyByID = False


Dim lParentID As Long

dsData.pst.skDSIdx.Seek "=", lPropID

If (dsData.pst.skDSIdx.NoMatch) Then
  Err.Raise 1, , "Internal error. Property not found"
End If

Dim lCurParentID As Long
lCurParentID = Nz(dsData.pst.skDSIdx("DIR_PARENT_ID"))


Dim newPM As PARTIAL_MATCH
If Not dsPstFindPropertyID(dsData, sNewFullName, newPM) Then
  Exit Function
End If

If (newPM.blIsFullMatch) Then
  Err.Raise 1, , "Property with name: " & sNewFullName & " already exists."
End If

'Need to reset the lookup list, as an entire subtree will be moved.
dsPstIntPrvListClean dsData



'Delete property from parent directory
If Not dsPstIntDirRemoveProperty(dsData, lPropID, lCurParentID) Then
  Exit Function
End If

'The property and its subtree have now been orphaned.

'Now move to new position.
Dim sNewPartName As String, lNewParentID As Long
If Not dsPstIntTreeLinkProperty(dsData, lPropID, newPM.sNameLeftToMatch, newPM.lLastParentPropID, sNewPartName, lNewParentID) Then
  Exit Function
End If

If (sNewPartName = "") Then
  Err.Raise 1, , "Internal error"
End If

dsData.pst.skDSIdx.Seek "=", lPropID

If (dsData.pst.skDSIdx.NoMatch) Then
  Err.Raise 1, , "Internal error. Property not found"
End If

dsData.pst.skDSIdx.Edit
  dsData.pst.skDSIdx("DIR_Parent_ID") = lNewParentID
  dsData.pst.skDSIdx("DIR_Name") = sNewPartName
dsData.pst.skDSIdx.Update



dsPstRenamePropertyByID = True
Exit Function

fout:
MsgBox Err & " dsPstRenamePropertyByID" & vbCrLf & Error$, 16
Exit Function
End Function


Private Function dsPstIntTreeLinkProperty(ByRef dsData As DIR_SERVER_DATA, ByVal lPropID As Long, ByVal sNameLeftToMatch As String, ByVal lLastParentID As Long, ByRef sPartName As String, lParentID As Long) As Boolean
On Error GoTo fout
dsPstIntTreeLinkProperty = False

Dim tpPartName As String
tpPartName = extractToken(sNameLeftToMatch, "\")

If (tpPartName = "") Then
 Err.Raise 1, , "Internal error"
End If

While (tpPartName <> "")

  Dim tpNewPropID As Long
  
  If (sNameLeftToMatch = "") Then
    tpNewPropID = lPropID
    sPartName = tpPartName
    lParentID = lLastParentID
  Else
    tpNewPropID = dsData.lMaxUsedID + 1
    dsData.lMaxUsedID = tpNewPropID
    
    dsData.pst.skDSIdx.AddNew
      dsData.pst.skDSIdx("DIR_ID") = tpNewPropID
      dsData.pst.skDSIdx("DIR_Name") = tpPartName
      dsData.pst.skDSIdx("DIR_Parent_ID") = lLastParentID
      dsData.pst.skDSIdx("DIR_Value") = Null
    dsData.pst.skDSIdx.Update
    
  End If

  If Not dsPstIntDirAddProperty(dsData, tpNewPropID, lLastParentID) Then
    Exit Function
  End If
    
  tpPartName = extractToken(sNameLeftToMatch, "\")
  lLastParentID = tpNewPropID
  
Wend


dsPstIntTreeLinkProperty = True

Exit Function

fout:
MsgBox Err & " dsPstIntTreeLinkProperty" & vbCrLf & Error$, 16
Exit Function
End Function


Private Function dsIntSetPropertyByName(ByRef dsData As DIR_SERVER_DATA, ByVal sPropFullName As String, ByVal sPropValue As String, ByRef lPropID As Long, ByRef blWasPresent As Boolean, ByRef sPrevValue As String) As Boolean
On Error GoTo fout
dsIntSetPropertyByName = False


lPropID = -1
blWasPresent = False
sPrevValue = ""


'first look in cache
Dim lCacheID As Long, blIsFinal As Boolean
If Not dsCacheLookupByName(dsData, sPropFullName, blWasPresent, sPrevValue, lPropID, lCacheID, blIsFinal) Then
  appRaiseSilentError
End If


Dim blPMAv As Boolean, pm As PARTIAL_MATCH
blPMAv = False

'if not found in cache; look in persistent storage
If (Not blIsFinal) And (Not blWasPresent) Then
  blPMAv = True
  If Not dsPstLookupPropertyByName(dsData, sPropFullName, sPrevValue, blWasPresent, lPropID, pm) Then
    appRaiseSilentError
  End If
End If


Dim blShouldWrite As Boolean
blShouldWrite = True

If (Not blWasPresent) Then
  lPropID = dsData.lMaxUsedID + 1
  dsData.lMaxUsedID = lPropID
End If

If (blWasPresent) And (sPrevValue = sPropValue) Then
  blShouldWrite = False
End If


If (blShouldWrite) Then

  Dim blWriteToPst As Boolean
  blWriteToPst = True
  
  If Not dsCacheSet(dsData, sPropFullName, sPropValue, lPropID, lCacheID, True, blWriteToPst) Then
    appRaiseSilentError
  End If
  
  If blWriteToPst Then
    If Not dsPstSetProperty(dsData, sPropFullName, sPropValue, lPropID, blPMAv, pm) Then
      appRaiseSilentError
    End If
  End If

End If


dsIntSetPropertyByName = True

Exit Function

fout:
Dim errInf As ERR_INFO
appRecordError "dsIntSetPropertyByName", errInf

appDisplayError errInf
Exit Function

End Function


Private Function dsPstSetProperty(ByRef dsData As DIR_SERVER_DATA, ByVal sPropFullName As String, ByVal sPropValue As String, ByVal lPropID As Long, ByVal blPartMatchAvl As Boolean, ByRef pm As PARTIAL_MATCH) As Boolean
On Error GoTo fout
dsPstSetProperty = False




dsData.pst.skDSIdx.Seek "=", lPropID

If (Not dsData.pst.skDSIdx.NoMatch) Then

  dsData.pst.skDSIdx.Edit
    dsData.pst.skDSIdx("DIR_Value") = hzn(sPropValue)
  dsData.pst.skDSIdx.Update
  
Else

  'Need to add node
  If Not blPartMatchAvl Then
    If Not dsPstFindPropertyID(dsData, sPropFullName, pm) Then
      appRaiseSilentError
    End If
  End If
  
  If (pm.blIsFullMatch) Then
    'This should not happen, since then lPropID should already have been found in skDSIdx
    Err.Raise 1, , "Internal error"
  End If
  
  Dim lParentID As Long
  Dim sPropPartName As String
  
  If Not dsPstIntTreeLinkProperty(dsData, lPropID, pm.sNameLeftToMatch, pm.lLastParentPropID, sPropPartName, lParentID) Then
    appRaiseSilentError
  End If
  
  If (sPropPartName = "") Then
    Err.Raise 1, , "Internal error"
  End If
  
  dsData.pst.skDSIdx.AddNew
    dsData.pst.skDSIdx("DIR_ID") = lPropID
    dsData.pst.skDSIdx("DIR_Name") = sPropPartName
    dsData.pst.skDSIdx("DIR_Parent_ID") = lParentID
    dsData.pst.skDSIdx("DIR_Value") = hzn(sPropValue)
  dsData.pst.skDSIdx.Update
  

End If



dsPstSetProperty = True

Exit Function

fout:
MsgBox Err & " dsPstSetProperty" & vbCrLf & Error$, 16
Exit Function

End Function



Private Function dsIntSetPropertyByID(ByRef dsData As DIR_SERVER_DATA, ByVal lPropID As Long, ByVal sPropValue As String, ByRef sPrevValue As String) As Boolean
On Error GoTo fout
dsIntSetPropertyByID = False

Dim blWasPresent As Boolean

blWasPresent = False
sPrevValue = ""

Dim sPropFullName As String


'first look in cache
Dim lCacheID As Long, blIsFinal As Boolean
If Not dsCacheLookupByID(dsData, lPropID, blWasPresent, sPropFullName, sPrevValue, lCacheID, blIsFinal) Then
  appRaiseSilentError
End If


'if not found in cache; look in persistent storage
If (Not blIsFinal) And (Not blWasPresent) Then
  If Not dsPstLookupPropertyValueByID(dsData, lPropID, sPrevValue, blWasPresent) Then
    appRaiseSilentError
  End If
  If Not dsPstLookupPropertyNameByID(dsData, lPropID, sPropFullName, blWasPresent) Then
    appRaiseSilentError
  End If
End If


If (Not blWasPresent) Then
  Err.Raise 1, , "Property ID not found"
End If

Dim blShouldWrite As Boolean
blShouldWrite = True

If (sPropValue = sPrevValue) Then
  blShouldWrite = False
End If

If (blShouldWrite) Then

  Dim blWriteToPst As Boolean
  blWriteToPst = True
  
  If Not dsCacheSet(dsData, sPropFullName, sPropValue, lPropID, lCacheID, True, blWriteToPst) Then
    appRaiseSilentError
  End If
  
  If blWriteToPst Then
    Dim pm As PARTIAL_MATCH
    If Not dsPstSetProperty(dsData, sPropFullName, sPropValue, lPropID, False, pm) Then
      appRaiseSilentError
    End If
  End If
  
End If


dsIntSetPropertyByID = True

Exit Function

fout:
Dim errInf As ERR_INFO
appRecordError "dsIntSetPropertyByID", errInf

appDisplayError errInf
Exit Function




End Function


Private Function dsIntDeletePropertyByName(ByRef dsData As DIR_SERVER_DATA, ByVal sPropFullName As String, ByRef wasPresent As Boolean, ByRef sPropValue As String) As Boolean
On Error GoTo fout
dsIntDeletePropertyByName = False


If Not dsCachePrepPstOp(dsData) Then
  appRaiseSilentError
End If

If Not dsPstDeletePropertyByName(dsData, sPropFullName, wasPresent, sPropValue) Then
  appRaiseSilentError
End If


dsIntDeletePropertyByName = True
Exit Function

fout:
Dim errInf As ERR_INFO
appRecordError "dsIntDeletePropertyByName", errInf

appDisplayError errInf
Exit Function

End Function



Private Function dsIntCopyPropertyByName(ByRef dsSrcData As DIR_SERVER_DATA, ByVal sSrcPropFullName As String, ByRef dsTgtData As DIR_SERVER_DATA, ByVal sTgtPropFullName As String) As Boolean
On Error GoTo fout
dsIntCopyPropertyByName = False


If Not dsCachePrepPstOp(dsSrcData) Then
  appRaiseSilentError
End If

If Not dsCachePrepPstOp(dsTgtData) Then
  appRaiseSilentError
End If


If Not dsPstCopyPropertyByName(dsSrcData, sSrcPropFullName, dsTgtData, sTgtPropFullName) Then
  appRaiseSilentError
End If



dsIntCopyPropertyByName = True
Exit Function

fout:
Dim errInf As ERR_INFO
appRecordError "dsIntCopyPropertyByName", errInf

appDisplayError errInf
Exit Function

End Function

Private Function dsPstCopyPropertyByName(ByRef dsSrcData As DIR_SERVER_DATA, ByVal sSrcPropFullName As String, ByRef dsTgtData As DIR_SERVER_DATA, ByVal sTgtPropFullName As String) As Boolean
On Error GoTo fout
dsPstCopyPropertyByName = False

Dim srcPM As PARTIAL_MATCH

If Not dsPstFindPropertyID(dsSrcData, sSrcPropFullName, srcPM) Then
  Exit Function
End If

If (srcPM.blIsFullMatch) Then
  If Not dsPstCopyPropertyByID(dsSrcData, srcPM.lFullPropID, dsTgtData, sTgtPropFullName) Then
    Exit Function
  End If
End If



dsPstCopyPropertyByName = True
Exit Function

fout:
MsgBox Err & " dsPstCopyPropertyByName" & vbCrLf & Error$, 16
Exit Function

End Function





'This copies everything in the directory specified by srcRootID (including subdirectories) to the directory tgtRootID.
'The element tgtRootID must already exist and srcRootID itself is not copied
Private Function dsPstIntCopyPropertyByID_copySubTree(dsSrcData As DIR_SERVER_DATA, lSrcRootID As Long, dsTgtData As DIR_SERVER_DATA, lTgtRootID As Long) As Boolean
On Error GoTo fout
dsPstIntCopyPropertyByID_copySubTree = False


'We will perform a depth first search, copying everything as we go.

Dim dirSrcIDs(0 To MAX_N_DIR_TREE_DEPTH) As Long
Dim dirSrcIDCurPos(0 To MAX_N_DIR_TREE_DEPTH) As Long
Dim dirSrcIDCnt(0 To MAX_N_DIR_TREE_DEPTH) As Long
Dim dirSrcIDListID(0 To MAX_N_DIR_TREE_DEPTH) As Long
Dim dirTgtIDs(0 To MAX_N_DIR_TREE_DEPTH) As Long

Dim curDepth As Integer
curDepth = 0

dirSrcIDs(0) = lSrcRootID
dirSrcIDCurPos(0) = -1
dirTgtIDs(0) = lTgtRootID

While (curDepth >= 0)
  
  
  If (dirSrcIDCurPos(curDepth) = -1) Then
    'need to initialize count
    dirSrcIDCnt(curDepth) = 0
    dirSrcIDListID(curDepth) = -1
    
    
    dsSrcData.pst.skDSNP.Seek "=", "_int_ds_listing", dirSrcIDs(curDepth)
    
    If (Not dsSrcData.pst.skDSNP.NoMatch) Then
      dirSrcIDListID(curDepth) = Nz(dsSrcData.pst.skDSNP("DIR_ID"))
     
      'look for the count node
      dsSrcData.pst.skDSNP.Seek "=", "_int_ds_counter", dirSrcIDListID(curDepth)
      
      If (Not dsSrcData.pst.skDSNP.NoMatch) Then
        dirSrcIDCnt(curDepth) = CLng(Nz(dsSrcData.pst.skDSNP("DIR_VALUE")))
      End If
      
    End If
    
    
    
  End If
  
  'advance the current position
  dirSrcIDCurPos(curDepth) = dirSrcIDCurPos(curDepth) + 1
  
  'Check if we are done in the current subdirectory.
  
  If (dirSrcIDCurPos(curDepth) >= dirSrcIDCnt(curDepth)) Then
    'we are done with this directory
    curDepth = curDepth - 1
  Else
  
    'need to process the current position.
    
    Dim lSrcChildID As Long
    dsSrcData.pst.skDSNP.Seek "=", "_int_ds_id_for_pos_" & dirSrcIDCurPos(curDepth), dirSrcIDListID(curDepth)
    
    If (dsSrcData.pst.skDSNP.NoMatch) Then
      Err.Raise 1, , "internal error"
    End If
    
    lSrcChildID = CLng(Nz(dsSrcData.pst.skDSNP("DIR_Value")))
    
    Dim lTgtChildID As Long
    lTgtChildID = dsTgtData.lMaxUsedID + 1
    dsTgtData.lMaxUsedID = lTgtChildID
    
    
    'get child data
    dsSrcData.pst.skDSIdx.Seek "=", lSrcChildID
    If dsSrcData.pst.skDSIdx.NoMatch Then
      Err.Raise 1, , "internal error"
    End If
    
    Dim sChildPartName As String, sChildValue As String
    sChildPartName = Nz(dsSrcData.pst.skDSIdx("DIR_Name"))
    sChildValue = Nz(dsSrcData.pst.skDSIdx("DIR_Value"))
    
    If (sChildPartName = "") Then
      Err.Raise 1, , "Internal error"
    End If
    
    
    
    'copy child data over to target
    
    dsTgtData.pst.skDSIdx.AddNew
      dsTgtData.pst.skDSIdx("DIR_ID") = lTgtChildID
      dsTgtData.pst.skDSIdx("DIR_Name") = sChildPartName
      dsTgtData.pst.skDSIdx("DIR_Value") = hzn(sChildValue)
      dsTgtData.pst.skDSIdx("DIR_Parent_ID") = dirTgtIDs(curDepth)
    dsTgtData.pst.skDSIdx.Update
    
    'tie in new node in target tree
    
    If Not dsPstIntDirAddProperty(dsTgtData, lTgtChildID, dirTgtIDs(curDepth)) Then
      Exit Function
    End If
    
    
    
  
    dirSrcIDs(curDepth + 1) = lSrcChildID
    dirSrcIDCurPos(curDepth + 1) = -1
    dirTgtIDs(curDepth + 1) = lTgtChildID
    
    
    'move on to this new directory
    
    curDepth = curDepth + 1
  
  
  
  End If
  




Wend




dsPstIntCopyPropertyByID_copySubTree = True
Exit Function

fout:
MsgBox Err & " dsPstIntCopyPropertyByID_copySubTree" & vbCrLf & Error$, 16
Exit Function

End Function



Private Function dsIntCopyPropertyByID(dsSrcData As DIR_SERVER_DATA, lSrcPropID As Long, dsTgtData As DIR_SERVER_DATA, sTgtFullName As String) As Boolean
On Error GoTo fout
dsIntCopyPropertyByID = False

If Not dsCachePrepPstOp(dsSrcData) Then
  appRaiseSilentError
End If

If Not dsCachePrepPstOp(dsTgtData) Then
  appRaiseSilentError
End If

If Not dsPstCopyPropertyByID(dsSrcData, lSrcPropID, dsTgtData, sTgtFullName) Then
  appRaiseSilentError
End If


dsIntCopyPropertyByID = True
Exit Function

fout:
Dim errInf As ERR_INFO
appRecordError "dsIntCopyPropertyByID", errInf

appDisplayError errInf
Exit Function

End Function




Private Function dsPstCopyPropertyByID(dsSrcData As DIR_SERVER_DATA, lSrcPropID As Long, dsTgtData As DIR_SERVER_DATA, sTgtFullName As String) As Boolean
On Error GoTo fout
dsPstCopyPropertyByID = False


Dim tgtPM As PARTIAL_MATCH
If Not dsPstFindPropertyID(dsTgtData, sTgtFullName, tgtPM) Then
  Exit Function
End If

If (tgtPM.blIsFullMatch) Then
  Err.Raise 1, , "Property with name: " & sTgtFullName & " already exists in target tree."
End If


dsSrcData.pst.skDSIdx.Seek "=", lSrcPropID

If (dsSrcData.pst.skDSIdx.NoMatch) Then
  Err.Raise 1, , "Internal error. Property not found"
End If

Dim sSrcValue As String
sSrcValue = Nz(dsSrcData.pst.skDSIdx("DIR_Value"))


'Copy the property itself.
Dim lTgtPropID As Long
lTgtPropID = dsTgtData.lMaxUsedID + 1
dsTgtData.lMaxUsedID = lTgtPropID



'Tie in new property in destination tree
Dim sTgtPartName As String, lTgtParentID As Long
If Not dsPstIntTreeLinkProperty(dsTgtData, lTgtPropID, tgtPM.sNameLeftToMatch, tgtPM.lLastParentPropID, sTgtPartName, lTgtParentID) Then
  Exit Function
End If

If (sTgtPartName = "") Then
  Err.Raise 1, , "Internal error"
End If

dsTgtData.pst.skDSIdx.AddNew
  dsTgtData.pst.skDSIdx("DIR_ID") = lTgtPropID
  dsTgtData.pst.skDSIdx("DIR_Name") = sTgtPartName
  dsTgtData.pst.skDSIdx("DIR_Parent_ID") = lTgtParentID
  dsTgtData.pst.skDSIdx("DIR_Value") = hzn(sSrcValue)
dsTgtData.pst.skDSIdx.Update
  
'Now need to copy over entire subtree
If Not dsPstIntCopyPropertyByID_copySubTree(dsSrcData, lSrcPropID, dsTgtData, lTgtPropID) Then
  Exit Function
End If

dsPstCopyPropertyByID = True
Exit Function

fout:
MsgBox Err & " dsPstCopyPropertyByID" & vbCrLf & Error$, 16
Exit Function

End Function







Private Function dsIntComparePropertyByName(ByRef dsSrcData As DIR_SERVER_DATA, ByVal sSrcPropFullName As String, ByRef dsTgtData As DIR_SERVER_DATA, ByVal sTgtPropFullName As String, ByRef isMatch As Boolean) As Boolean
On Error GoTo fout
dsIntComparePropertyByName = False

If Not dsCachePrepPstOp(dsSrcData) Then
  appRaiseSilentError
End If

If Not dsCachePrepPstOp(dsTgtData) Then
  appRaiseSilentError
End If

If Not dsPstComparePropertyByName(dsSrcData, sSrcPropFullName, dsTgtData, sTgtPropFullName, isMatch) Then
  appRaiseSilentError
End If

dsIntComparePropertyByName = True
Exit Function

fout:
Dim errInf As ERR_INFO
appRecordError "dsIntComparePropertyByName", errInf

appDisplayError errInf
Exit Function

End Function


Private Function dsPstComparePropertyByName(ByRef dsSrcData As DIR_SERVER_DATA, ByVal sSrcPropFullName As String, ByRef dsTgtData As DIR_SERVER_DATA, ByVal sTgtPropFullName As String, ByRef isMatch As Boolean) As Boolean
On Error GoTo fout
dsPstComparePropertyByName = False

Dim blDummy As Boolean
Dim srcPM As PARTIAL_MATCH, tgtPM As PARTIAL_MATCH

If Not dsPstFindPropertyID(dsSrcData, sSrcPropFullName, srcPM) Then
  Exit Function
End If

If Not dsPstFindPropertyID(dsTgtData, sTgtPropFullName, tgtPM) Then
  Exit Function
End If

If (Not srcPM.blIsFullMatch) And (Not tgtPM.blIsFullMatch) Then
  isMatch = True
ElseIf (srcPM.blIsFullMatch) And (Not tgtPM.blIsFullMatch) Then
  isMatch = False
ElseIf (tgtPM.blIsFullMatch) And (Not srcPM.blIsFullMatch) Then
  isMatch = False
ElseIf (srcPM.blIsFullMatch) And (tgtPM.blIsFullMatch) Then
  If Not dsPstComparePropertyByID(dsSrcData, srcPM.lFullPropID, dsTgtData, tgtPM.lFullPropID, isMatch) Then
    Exit Function
  End If
End If



dsPstComparePropertyByName = True
Exit Function

fout:
MsgBox Err & " dsPstComparePropertyByName" & vbCrLf & Error$, 16
Exit Function

End Function





'This compares everything in the directory specified by srcRootID (including subdirectories) to the directory tgtRootID.
'The elements srcRootID and tgtRootID must both exist and srcRootID itself is not compare with tgtRootID
Private Function dsPstIntComparePropertyByID_compareSubTree(dsSrcData As DIR_SERVER_DATA, lSrcRootID As Long, dsTgtData As DIR_SERVER_DATA, lTgtRootID As Long, ByRef isMatch As Boolean) As Boolean
On Error GoTo fout
dsPstIntComparePropertyByID_compareSubTree = False

isMatch = True

'We will perform a depth first search, comparing everything as we go.

Dim dirSrcIDs(0 To MAX_N_DIR_TREE_DEPTH) As Long
Dim dirSrcIDCurPos(0 To MAX_N_DIR_TREE_DEPTH) As Long
Dim dirSrcIDCnt(0 To MAX_N_DIR_TREE_DEPTH) As Long
Dim dirSrcIDListID(0 To MAX_N_DIR_TREE_DEPTH) As Long
Dim dirTgtIDs(0 To MAX_N_DIR_TREE_DEPTH) As Long

Dim curDepth As Integer
curDepth = 0

dirSrcIDs(0) = lSrcRootID
dirSrcIDCurPos(0) = -1
dirTgtIDs(0) = lTgtRootID

Do While (curDepth >= 0)
  
  
  If (dirSrcIDCurPos(curDepth) = -1) Then
    'need to initialize count
    dirSrcIDCnt(curDepth) = 0
    dirSrcIDListID(curDepth) = -1
    
    
    
    dsSrcData.pst.skDSNP.Seek "=", "_int_ds_listing", dirSrcIDs(curDepth)
    
    If (Not dsSrcData.pst.skDSNP.NoMatch) Then
      dirSrcIDListID(curDepth) = Nz(dsSrcData.pst.skDSNP("DIR_ID"))
     
      'look for the count node
      dsSrcData.pst.skDSNP.Seek "=", "_int_ds_counter", dirSrcIDListID(curDepth)
      
      If (Not dsSrcData.pst.skDSNP.NoMatch) Then
        dirSrcIDCnt(curDepth) = CLng(Nz(dsSrcData.pst.skDSNP("DIR_VALUE")))
      End If
      
    End If
    
    Dim tpTgtIDCnt As Long, tpTgtIDListID As Long
    
    tpTgtIDCnt = 0
    tpTgtIDListID = -1
    
    dsTgtData.pst.skDSNP.Seek "=", "_int_ds_listing", dirTgtIDs(curDepth)
    
    If (Not dsTgtData.pst.skDSNP.NoMatch) Then
      tpTgtIDListID = Nz(dsTgtData.pst.skDSNP("DIR_ID"))
     
      'look for the count node
      dsTgtData.pst.skDSNP.Seek "=", "_int_ds_counter", tpTgtIDListID
      
      If (Not dsTgtData.pst.skDSNP.NoMatch) Then
        tpTgtIDCnt = CLng(Nz(dsTgtData.pst.skDSNP("DIR_VALUE")))
      End If
      
    End If
    
    If (dirSrcIDCnt(curDepth) <> tpTgtIDCnt) Then
      isMatch = False
      Exit Do
    End If
    
    
  End If
  
  'advance the current position
  dirSrcIDCurPos(curDepth) = dirSrcIDCurPos(curDepth) + 1
  
  'Check if we are done in the current subdirectory.
  
  If (dirSrcIDCurPos(curDepth) >= dirSrcIDCnt(curDepth)) Then
    'we are done with this directory
    curDepth = curDepth - 1
  Else
  
    'need to process the current position.
    
    Dim lSrcChildID As Long
    dsSrcData.pst.skDSNP.Seek "=", "_int_ds_id_for_pos_" & dirSrcIDCurPos(curDepth), dirSrcIDListID(curDepth)
    
    If (dsSrcData.pst.skDSNP.NoMatch) Then
      Err.Raise 1, , "internal error"
    End If
    
    lSrcChildID = CLng(Nz(dsSrcData.pst.skDSNP("DIR_Value")))
    
    
    'get child data
    dsSrcData.pst.skDSIdx.Seek "=", lSrcChildID
    If dsSrcData.pst.skDSIdx.NoMatch Then
      Err.Raise 1, , "internal error"
    End If
    
    Dim sChildPartName As String, sChildValue As String
    sChildPartName = Nz(dsSrcData.pst.skDSIdx("DIR_Name"))
    sChildValue = Nz(dsSrcData.pst.skDSIdx("DIR_Value"))
    
    If (sChildPartName = "") Then
      Err.Raise 1, , "Internal error"
    End If
    
    
    Dim lTgtChildID As Long
    
    'check if target contains a similar node.
    dsTgtData.pst.skDSNP.Seek "=", sChildPartName, dirTgtIDs(curDepth)
    If dsTgtData.pst.skDSNP.NoMatch Then
      isMatch = False
      Exit Do
    End If
    
    lTgtChildID = dsTgtData.pst.skDSNP("DIR_ID")
    If Nz(dsTgtData.pst.skDSNP("DIR_Value")) <> sChildValue Then
      isMatch = False
      Exit Do
    End If
    
  
    dirSrcIDs(curDepth + 1) = lSrcChildID
    dirSrcIDCurPos(curDepth + 1) = -1
    dirTgtIDs(curDepth + 1) = lTgtChildID
    
    
    'move on to this new directory
    
    curDepth = curDepth + 1
  
  End If

Loop




dsPstIntComparePropertyByID_compareSubTree = True
Exit Function

fout:
MsgBox Err & " dsPstIntComparePropertyByID_compareSubTree" & vbCrLf & Error$, 16
Exit Function

End Function


Private Function dsIntComparePropertyByID(ByRef dsSrcData As DIR_SERVER_DATA, ByVal lSrcPropID As Long, ByRef dsTgtData As DIR_SERVER_DATA, ByVal lTgtPropID As Long, ByRef isMatch As Boolean) As Boolean
On Error GoTo fout
dsIntComparePropertyByID = False


If Not dsCachePrepPstOp(dsSrcData) Then
  appRaiseSilentError
End If

If Not dsCachePrepPstOp(dsTgtData) Then
  appRaiseSilentError
End If

If Not dsPstComparePropertyByID(dsSrcData, lSrcPropID, dsTgtData, lTgtPropID, isMatch) Then
  appRaiseSilentError
End If

dsIntComparePropertyByID = True
Exit Function

fout:
Dim errInf As ERR_INFO
appRecordError "dsIntComparePropertyByID", errInf

appDisplayError errInf
Exit Function

End Function


Private Function dsPstComparePropertyByID(ByRef dsSrcData As DIR_SERVER_DATA, ByVal lSrcPropID As Long, ByRef dsTgtData As DIR_SERVER_DATA, ByVal lTgtPropID As Long, ByRef isMatch As Boolean) As Boolean
On Error GoTo fout
dsPstComparePropertyByID = False

isMatch = True

dsSrcData.pst.skDSIdx.Seek "=", lSrcPropID

If (dsSrcData.pst.skDSIdx.NoMatch) Then
  Err.Raise 1, , "Internal error. Property not found"
End If


Dim sSrcValue As String
sSrcValue = Nz(dsSrcData.pst.skDSIdx("DIR_Value"))


dsTgtData.pst.skDSIdx.Seek "=", lTgtPropID

If (dsTgtData.pst.skDSIdx.NoMatch) Then
  Err.Raise 1, , "Internal error. Property not found"
End If


Dim sTgtValue As String
sTgtValue = Nz(dsTgtData.pst.skDSIdx("DIR_Value"))


If (sTgtValue <> sSrcValue) Then
  isMatch = False
Else
  'Now need to compare entire subtree
  If Not dsPstIntComparePropertyByID_compareSubTree(dsSrcData, lSrcPropID, dsTgtData, lTgtPropID, isMatch) Then
    Exit Function
  End If
End If

dsPstComparePropertyByID = True
Exit Function

fout:
MsgBox Err & " dsPstComparePropertyByID" & vbCrLf & Error$, 16
Exit Function

End Function

Private Function dsPstCacheSubtree(ByRef dsData As DIR_SERVER_DATA, ByVal sPropName As String) As Boolean
On Error GoTo fout
dsPstCacheSubtree = False


Dim pm As PARTIAL_MATCH
If Not dsPstFindPropertyID(dsData, sPropName, pm) Then
  Exit Function
End If

If pm.blIsFullMatch Then
  Dim sRootValue As String
  
  Dim lDummy As Long, blDummy As Boolean, sDummy As String
  
  If Not dsPstLookupPropertyValueByID(dsData, pm.lFullPropID, sRootValue, blDummy) Then
    appRaiseSilentError
  End If
  
  If Not dsCachePrepSubtreeCache(dsData, sPropName) Then
    appRaiseSilentError
  End If
  
  Dim lCacheID As Long
  'need to get cacheID before we can call cacheSet.
  If Not dsCacheLookupByID(dsData, pm.lFullPropID, blDummy, sDummy, sDummy, lCacheID, blDummy) Then
    appRaiseSilentError
  End If
  
  If Not dsCacheSet(dsData, sPropName, sRootValue, pm.lFullPropID, lCacheID, False, blDummy) Then
    appRaiseSilentError
  End If
  
  If Not dsPstIntCacheSubtree_cacheSubTree(dsData, pm.lFullPropID, sPropName) Then
    Exit Function
  End If
End If


dsPstCacheSubtree = True
Exit Function

fout:
Dim errInf As ERR_INFO
appRecordError "dsPstCacheSubtree", errInf

appDisplayError errInf
Exit Function
End Function


'This caches everything in the directory specified by lRootID (including subdirectories)
'The element lRootID must exist and is not cached itself
Private Function dsPstIntCacheSubtree_cacheSubTree(dsData As DIR_SERVER_DATA, ByVal lRootID As Long, ByVal sRootFullName As String) As Boolean
On Error GoTo fout
dsPstIntCacheSubtree_cacheSubTree = False

'We will perform a depth first search, comparing everything as we go.

Dim dirIDs(0 To MAX_N_DIR_TREE_DEPTH) As Long
Dim dirFullNames(0 To MAX_N_DIR_TREE_DEPTH) As String
Dim dirIDCurPos(0 To MAX_N_DIR_TREE_DEPTH) As Long
Dim dirIDCnt(0 To MAX_N_DIR_TREE_DEPTH) As Long
Dim dirIDListID(0 To MAX_N_DIR_TREE_DEPTH) As Long

Dim curDepth As Integer
curDepth = 0

dirIDs(0) = lRootID
dirFullNames(0) = sRootFullName
dirIDCurPos(0) = -1


Do While (curDepth >= 0)
  
  
  If (dirIDCurPos(curDepth) = -1) Then
    'need to initialize count
    dirIDCnt(curDepth) = 0
    dirIDListID(curDepth) = -1
    
    
    
    dsData.pst.skDSNP.Seek "=", "_int_ds_listing", dirIDs(curDepth)
    
    If (Not dsData.pst.skDSNP.NoMatch) Then
      dirIDListID(curDepth) = Nz(dsData.pst.skDSNP("DIR_ID"))
     
      'look for the count node
      dsData.pst.skDSNP.Seek "=", "_int_ds_counter", dirIDListID(curDepth)
      
      If (Not dsData.pst.skDSNP.NoMatch) Then
        dirIDCnt(curDepth) = CLng(Nz(dsData.pst.skDSNP("DIR_VALUE")))
      End If
      
    End If
    
    
  End If
  
  'advance the current position
  dirIDCurPos(curDepth) = dirIDCurPos(curDepth) + 1
  
  'Check if we are done in the current subdirectory.
  
  If (dirIDCurPos(curDepth) >= dirIDCnt(curDepth)) Then
    'we are done with this directory
    curDepth = curDepth - 1
  Else
  
    'need to process the current position.
    
    Dim lChildID As Long
    dsData.pst.skDSNP.Seek "=", "_int_ds_id_for_pos_" & dirIDCurPos(curDepth), dirIDListID(curDepth)
    
    If (dsData.pst.skDSNP.NoMatch) Then
      Err.Raise 1, , "internal error"
    End If
    
    lChildID = CLng(Nz(dsData.pst.skDSNP("DIR_Value")))
    
    
    'get child data
    dsData.pst.skDSIdx.Seek "=", lChildID
    If dsData.pst.skDSIdx.NoMatch Then
      Err.Raise 1, , "internal error"
    End If
    
    Dim sChildPartName As String, sChildValue As String
    sChildPartName = Nz(dsData.pst.skDSIdx("DIR_Name"))
    sChildValue = Nz(dsData.pst.skDSIdx("DIR_Value"))
    
    If (sChildPartName = "") Then
      Err.Raise 1, , "Internal error"
    End If
    
    Dim sChildFullName As String
    sChildFullName = dirFullNames(curDepth) & "\" & sChildPartName
    
    
    Dim lDummy As Long, blDummy As Boolean, sDummy As String
    
    
    Dim lCacheID As Long
    'Need to get cacheID before we can call dsCacheSet
    If Not dsCacheLookupByID(dsData, lChildID, blDummy, sDummy, sDummy, lCacheID, blDummy) Then
      appRaiseSilentError
    End If
    
    If Not dsCacheSet(dsData, sChildFullName, sChildValue, lChildID, lCacheID, False, blDummy) Then
      appRaiseSilentError
    End If
    
    
    
  
    dirIDs(curDepth + 1) = lChildID
    dirFullNames(curDepth + 1) = sChildFullName
    dirIDCurPos(curDepth + 1) = -1
    
    
    'move on to this new directory
    
    curDepth = curDepth + 1
  
  End If

Loop




dsPstIntCacheSubtree_cacheSubTree = True
Exit Function

fout:
MsgBox Err & " dsPstIntCacheSubtree_cacheSubTree" & vbCrLf & Error$, 16
Exit Function

End Function





Private Function dsCacheInit(ByRef dsData As DIR_SERVER_DATA, ByVal lCapacity As Long, ByVal blIsTemporary As Boolean) As Boolean
On Error GoTo fout
dsCacheInit = False

If (lCapacity < 1000) Then
  lCapacity = 1000
End If

If Not rbtInit(dsData.cache.rbtKeyToCacheID, lCapacity, False, False) Then
  appRaiseSilentError
End If

If Not rbtInit(dsData.cache.rbtPstIDToCacheID, lCapacity, False, False) Then
  appRaiseSilentError
End If

dsData.cache.sLoadedSubtree = ""
dsData.cache.blIsComplete = False

dsData.cache.blIsTemporary = blIsTemporary

dsData.cache.lCapacity = lCapacity

dsData.cache.blAllowDirty = False

dsData.cache.nDirtyProps = 0

ReDim dsData.cache.lPropPstIDs(lCapacity)
ReDim dsData.cache.sPropNames(lCapacity)
ReDim dsData.cache.sPropValues(lCapacity)
ReDim dsData.cache.blPropDirty(lCapacity)
dsData.cache.nProps = 0

If (blIsTemporary) Then
  dsData.cache.blAllowDirty = True
  
  dsData.cache.sLoadedSubtree = ""
  dsData.cache.blIsComplete = True
  
  ReDim dsData.cache.lDirtyProps(lCapacity)
 
     
End If



dsCacheInit = True
Exit Function

fout:
Dim errInf As ERR_INFO
appRecordError "dsCacheInit", errInf

appDisplayError errInf
Exit Function
End Function

Private Function dsCacheClean(ByRef dsData As DIR_SERVER_DATA) As Boolean
On Error GoTo fout
dsCacheClean = False


If (Not dsData.cache.blIsTemporary) Then
  If Not dsCacheIntWriteAllDirty(dsData) Then
    appRaiseSilentError
  End If
End If


ReDim dsData.cache.lPropPstIDs(0)
ReDim dsData.cache.sPropNames(0)
ReDim dsData.cache.sPropValues(0)
ReDim dsData.cache.blPropDirty(0)
dsData.cache.nProps = 0

ReDim dsData.cache.lDirtyProps(0)
dsData.cache.nDirtyProps = 0

dsData.cache.sLoadedSubtree = ""
dsData.cache.blIsComplete = False

If Not rbtClean(dsData.cache.rbtKeyToCacheID) Then
  appRaiseSilentError
End If

If Not rbtClean(dsData.cache.rbtPstIDToCacheID) Then
  appRaiseSilentError
End If



dsCacheClean = True
Exit Function

fout:
Dim errInf As ERR_INFO
appRecordError "dsCacheClean", errInf

appDisplayError errInf
Exit Function
End Function

Private Function dsCacheLookupByName(ByRef dsData As DIR_SERVER_DATA, ByVal sPropName As String, ByRef blPropPresent As Boolean, ByRef sPropValue As String, ByRef lPropID As Long, ByRef lCacheID As Long, ByRef blIsFinal As Boolean) As Boolean
On Error GoTo fout
dsCacheLookupByName = False



blPropPresent = False
lPropID = -1
sPropValue = ""
lCacheID = -1

blIsFinal = False


Dim lEC As Long, lDummy As Long
Dim sVal As String

If Not rbtLookupKey(dsData.cache.rbtKeyToCacheID, sPropName, RBTREE_MT_EQUAL, lEC, sVal, lDummy) Then
  appRaiseSilentError
End If

blPropPresent = (lEC <> -1)
If (blPropPresent) Then
  lCacheID = CLng(sVal)
  lPropID = dsData.cache.lPropPstIDs(lCacheID)
  sPropValue = dsData.cache.sPropValues(lCacheID)
  
  blIsFinal = True
  
Else
  
  If (dsData.cache.blIsComplete) Then
    If (dsData.cache.sLoadedSubtree = "") Then
      blIsFinal = True
    ElseIf (dsData.cache.sLoadedSubtree = sPropName) Then
      blIsFinal = True
    ElseIf (Left(sPropName, Len(dsData.cache.sLoadedSubtree) + 1) = dsData.cache.sLoadedSubtree & "\") Then
      blIsFinal = True
    End If
  End If
  
End If




dsCacheLookupByName = True
Exit Function

fout:
Dim errInf As ERR_INFO
appRecordError "dsCacheLookupByName", errInf

appDisplayError errInf
Exit Function
End Function


Private Function dsCacheLookupByID(ByRef dsData As DIR_SERVER_DATA, ByVal lPropID As Long, ByRef blPropPresent As Boolean, ByRef sPropFullName As String, ByRef sPropValue As String, ByRef lCacheID As Long, ByRef blIsFinal As Boolean) As Boolean
On Error GoTo fout
dsCacheLookupByID = False



blPropPresent = False
sPropValue = ""
lCacheID = -1

blIsFinal = False


Dim lEC As Long, lDummy As Long
Dim sVal As String

If Not rbtLookupKey(dsData.cache.rbtPstIDToCacheID, CStr(lPropID), RBTREE_MT_EQUAL, lEC, sVal, lDummy) Then
  appRaiseSilentError
End If

blPropPresent = (lEC <> -1)
If (blPropPresent) Then
  lCacheID = CLng(sVal)
  If (lPropID <> dsData.cache.lPropPstIDs(lCacheID)) Then
    Err.Raise 1, , "Internal error"
  End If
  sPropFullName = dsData.cache.sPropNames(lCacheID)
  sPropValue = dsData.cache.sPropValues(lCacheID)
  
  blIsFinal = True
  
Else
  'can only say that an ID is definitely not in the set if we have loaded the entire subtree.
  blIsFinal = dsData.cache.blIsComplete And (dsData.cache.sLoadedSubtree = "")
End If

dsCacheLookupByID = True
Exit Function

fout:
Dim errInf As ERR_INFO
appRecordError "dsCacheLookupByID", errInf

appDisplayError errInf
Exit Function
End Function


Private Function dsCacheSet(ByRef dsData As DIR_SERVER_DATA, ByVal sPropName As String, ByVal sPropValue As String, ByVal lPropID As Long, ByVal lCacheID As Long, ByVal blIsDirty As Boolean, ByRef blWriteToPst As Boolean) As Boolean
On Error GoTo fout
dsCacheSet = False

If (lCacheID = -1) Then
  'need to create new entry
  
  
  If (dsData.cache.nProps = dsData.cache.lCapacity) Then
    'need to make room in cache
    
    'write all dirty data
    If Not dsCacheIntWriteAllDirty(dsData) Then
      appRaiseSilentError
    End If
    
    'delete first element from the cache to make room
    Dim tpDelPstPropID As Long
    Dim tpDelPropName As String
    tpDelPstPropID = dsData.cache.lPropPstIDs(0)
    tpDelPropName = dsData.cache.sPropNames(0)
    
    Dim blDummy As Boolean, lDummy As Long, sDummy As String
    
    If Not rbtDeleteByKey(dsData.cache.rbtPstIDToCacheID, CStr(tpDelPstPropID), lDummy, sDummy) Then
      appRaiseSilentError
    End If
    
    If Not rbtDeleteByKey(dsData.cache.rbtKeyToCacheID, tpDelPropName, lDummy, sDummy) Then
      appRaiseSilentError
    End If
    
    'mark that the cache is no longer complete
    dsData.cache.blIsComplete = False
    
    lCacheID = 0
  Else
    lCacheID = dsData.cache.nProps
    dsData.cache.nProps = dsData.cache.nProps + 1
  End If
  
  dsData.cache.blPropDirty(lCacheID) = False
  dsData.cache.sPropNames(lCacheID) = sPropName
  dsData.cache.sPropValues(lCacheID) = sPropValue
  dsData.cache.lPropPstIDs(lCacheID) = lPropID
  
  
  
  
  
  If Not rbtSetByKey(dsData.cache.rbtKeyToCacheID, sPropName, CStr(lCacheID), False, False, blDummy, lDummy, lDummy, blDummy, sDummy) Then
    appRaiseSilentError
  End If
  
  If Not rbtSetByKey(dsData.cache.rbtPstIDToCacheID, CStr(lPropID), CStr(lCacheID), False, False, blDummy, lDummy, lDummy, blDummy, sDummy) Then
    appRaiseSilentError
  End If
  
Else
  If (dsData.cache.lPropPstIDs(lCacheID) <> lPropID) Then
    Err.Raise 1, , "internal error"
  End If
  If (dsData.cache.sPropNames(lCacheID) <> sPropName) Then
    Err.Raise 1, , "internal error"
  End If
  
  'need to update value
  dsData.cache.sPropValues(lCacheID) = sPropValue
End If

If (blIsDirty) Then
  If (dsData.cache.blAllowDirty) Then
    blWriteToPst = False
  Else
    blWriteToPst = True
  End If
Else
  blWriteToPst = False
End If


If (blIsDirty) And (Not blWriteToPst) Then
  'need to add to dirty list
  If (Not dsData.cache.blPropDirty(lCacheID)) Then
    dsData.cache.lDirtyProps(dsData.cache.nDirtyProps) = lCacheID
    dsData.cache.nDirtyProps = dsData.cache.nDirtyProps + 1
    
    dsData.cache.blPropDirty(lCacheID) = True
  End If
End If





dsCacheSet = True
Exit Function

fout:
Dim errInf As ERR_INFO
appRecordError "dsCacheSet", errInf

appDisplayError errInf
Exit Function

'debug
On Error GoTo 0
Resume
End Function


Private Function dsCacheIntWriteAllDirty(ByRef dsData As DIR_SERVER_DATA) As Boolean
On Error GoTo fout
dsCacheIntWriteAllDirty = False


Dim i As Integer
For i = 0 To dsData.cache.nDirtyProps - 1
  Dim lCacheID As Long
  lCacheID = dsData.cache.lDirtyProps(i)
  
  Dim sPropName As String, sPropValue As String, lPropPstID As Long
  sPropName = dsData.cache.sPropNames(i)
  sPropValue = dsData.cache.sPropValues(i)
  lPropPstID = dsData.cache.lPropPstIDs(i)
  
  Dim pm As PARTIAL_MATCH
  If Not dsPstSetProperty(dsData, sPropName, sPropValue, lPropPstID, False, pm) Then
    appRaiseSilentError
  End If
  
Next i

dsData.cache.nDirtyProps = 0


dsCacheIntWriteAllDirty = True
Exit Function

fout:
Dim errInf As ERR_INFO
appRecordError "dsCacheIntWriteAllDirty", errInf

appDisplayError errInf
Exit Function
End Function

Private Function dsCachePrepPstOp(ByRef dsData As DIR_SERVER_DATA) As Boolean
On Error GoTo fout
dsCachePrepPstOp = False

If Not dsCacheIntWriteAllDirty(dsData) Then
  appRaiseSilentError
End If

dsData.cache.sLoadedSubtree = ""
dsData.cache.blIsComplete = False

If Not rbtClearAll(dsData.cache.rbtPstIDToCacheID) Then
  appRaiseSilentError
End If

If Not rbtClearAll(dsData.cache.rbtKeyToCacheID) Then
  appRaiseSilentError
End If

dsData.cache.nProps = 0


dsCachePrepPstOp = True
Exit Function

fout:
Dim errInf As ERR_INFO
appRecordError "dsCachePrepPstOp", errInf

appDisplayError errInf
Exit Function
End Function

Private Function dsCachePrepSubtreeCache(ByRef dsData As DIR_SERVER_DATA, ByVal sPropName As String) As Boolean
On Error GoTo fout
dsCachePrepSubtreeCache = False


dsData.cache.sLoadedSubtree = sPropName
dsData.cache.blIsComplete = True



dsCachePrepSubtreeCache = True
Exit Function

fout:
Dim errInf As ERR_INFO
appRecordError "dsCachePrepSubtreeCache", errInf

appDisplayError errInf
Exit Function
End Function










Public Sub dsSetString(ByRef dsData As DIR_SERVER_DATA, ByVal sPropFullName As String, ByVal sPropValue As String)
Dim lDummy As Long, blDummy As Boolean, sDummy As String
If Not dsIntSetPropertyByName(dsData, sPropFullName, sPropValue, lDummy, blDummy, sDummy) Then
  Err.Raise 1, , "Could not set value " & sPropValue & " for property: " & sPropFullName
End If
End Sub


Public Function dsGetString(ByRef dsData As DIR_SERVER_DATA, ByVal sPropFullName As String) As String
Dim sPropValue As String
Dim blDummy As Boolean, lDummy As Long
If Not dsIntLookupPropertyByName(dsData, sPropFullName, sPropValue, blDummy, lDummy) Then
  Err.Raise 1, , "Error looking up property"
End If

dsGetString = sPropValue

End Function

Public Sub dsSetLong(ByRef dsData As DIR_SERVER_DATA, ByVal sPropFullName As String, ByVal lPropValue As Long)
Dim lDummy As Long, blDummy As Boolean, sDummy As String
If Not dsIntSetPropertyByName(dsData, sPropFullName, CStr(lPropValue), lDummy, blDummy, sDummy) Then
  Err.Raise 1, , "Could not set value " & CStr(lPropValue) & " for property: " & sPropFullName
End If

End Sub


Public Function dsGetLong(ByRef dsData As DIR_SERVER_DATA, ByVal sPropFullName As String) As Long
Dim sPropValue As String
Dim blDummy As Boolean, lDummy As Long
If Not dsIntLookupPropertyByName(dsData, sPropFullName, sPropValue, blDummy, lDummy) Then
  Err.Raise 1, , "Error looking up property"
End If

dsGetLong = CLng(val(sPropValue))

End Function

Public Sub dsSetBoolean(ByRef dsData As DIR_SERVER_DATA, ByVal sPropFullName As String, ByVal blPropValue As Boolean)
Dim lDummy As Long, blDummy As Boolean, sDummy As String
If Not dsIntSetPropertyByName(dsData, sPropFullName, rxpFormatBoolean(blPropValue), lDummy, blDummy, sDummy) Then
  Err.Raise 1, , "Could not set value " & rxpFormatBoolean(blPropValue) & " for property: " & sPropFullName
End If
End Sub


Public Function dsGetBoolean(ByRef dsData As DIR_SERVER_DATA, ByVal sPropFullName As String) As Boolean
Dim sPropValue As String
Dim blDummy As Boolean, lDummy As Long
If Not dsIntLookupPropertyByName(dsData, sPropFullName, sPropValue, blDummy, lDummy) Then
  Err.Raise 1, , "Error looking up property"
End If

dsGetBoolean = rxpParseBoolean(sPropValue)

End Function

Public Sub dsSetDate(ByRef dsData As DIR_SERVER_DATA, ByVal sPropFullName As String, ByVal dPropValue As Date)
Dim lDummy As Long, blDummy As Boolean, sDummy As String
If Not dsIntSetPropertyByName(dsData, sPropFullName, rxpFormatDateNL(dPropValue), lDummy, blDummy, sDummy) Then
  Err.Raise 1, , "Could not set value " & rxpFormatDateNL(dPropValue) & " for property: " & sPropFullName
End If
End Sub


Public Function dsGetDate(ByRef dsData As DIR_SERVER_DATA, ByVal sPropFullName As String) As Date
Dim sPropValue As String
Dim blDummy As Boolean, lDummy As Long
If Not dsIntLookupPropertyByName(dsData, sPropFullName, sPropValue, blDummy, lDummy) Then
  Err.Raise 1, , "Error looking up property"
End If

dsGetDate = rxpParseDateNL(sPropValue)

End Function



Public Function dsSetPropertyByName(ByRef dsData As DIR_SERVER_DATA, ByVal sPropFullName As String, ByVal sPropValue As String, ByRef lPropID As Long, ByRef blWasPresent As Boolean, ByRef sPrevValue As String) As Boolean
dsSetPropertyByName = dsIntSetPropertyByName(dsData, sPropFullName, sPropValue, lPropID, blWasPresent, sPrevValue)
End Function
Public Function dsSetPropertyByID(ByRef dsData As DIR_SERVER_DATA, ByVal lPropID As Long, ByVal sPropValue As String, ByRef sPrevValue As String) As Boolean
dsSetPropertyByID = dsIntSetPropertyByID(dsData, lPropID, sPropValue, sPrevValue)
End Function


Public Function dsLookupPropertyByName(ByRef dsData As DIR_SERVER_DATA, ByVal sPropFullName As String, ByRef blIsPresent As Boolean, ByRef sPropValue As String, ByRef lPropID As Long) As Boolean
dsLookupPropertyByName = dsIntLookupPropertyByName(dsData, sPropFullName, sPropValue, blIsPresent, lPropID)
End Function


Public Function dsLookupPropertyByID(ByRef dsData As DIR_SERVER_DATA, ByVal lPropID As Long, ByRef sPropName As String, ByRef sPropValue As String, ByRef blIsPresent As Boolean) As Boolean
dsLookupPropertyByID = dsIntLookupPropertyByID(dsData, lPropID, sPropName, sPropValue, blIsPresent)
End Function


Public Function dsDeletePropertyByName(ByRef dsData As DIR_SERVER_DATA, ByVal sPropFullName As String, ByRef blWasPresent As Boolean, ByRef sPropValue As String) As Boolean
dsDeletePropertyByName = dsIntDeletePropertyByName(dsData, sPropFullName, blWasPresent, sPropValue)
End Function

Public Function dsDeletePropertyByID(ByRef dsData As DIR_SERVER_DATA, ByVal lPropID As Long, ByRef sPropValue As String) As Boolean
dsDeletePropertyByID = dsIntDeletePropertyByID(dsData, lPropID, sPropValue)
End Function


Public Function dsRenamePropertyByName(ByRef dsData As DIR_SERVER_DATA, ByVal sPropFullName As String, ByVal sPropNewFullName) As Boolean
dsRenamePropertyByName = dsIntRenamePropertyByName(dsData, sPropFullName, sPropNewFullName)
End Function

Public Function dsRenamePropertyByID(ByRef dsData As DIR_SERVER_DATA, ByVal lPropID As Long, ByVal sPropNewFullName) As Boolean
dsRenamePropertyByID = dsIntRenamePropertyByID(dsData, lPropID, sPropNewFullName)
End Function

Public Function dsCopyPropertyByName(ByRef dsSrcData As DIR_SERVER_DATA, ByVal sSrcPropFullName As String, ByRef dsTgtData As DIR_SERVER_DATA, ByVal sTgtPropFullName As String) As Boolean
dsCopyPropertyByName = dsIntCopyPropertyByName(dsSrcData, sSrcPropFullName, dsTgtData, sTgtPropFullName)
End Function

Public Function dsCopyPropertyByID(ByRef dsSrcData As DIR_SERVER_DATA, ByVal lSrcPropID As Long, ByRef dsTgtData As DIR_SERVER_DATA, ByVal sTgtPropFullName As String) As Boolean
dsCopyPropertyByID = dsIntCopyPropertyByID(dsSrcData, lSrcPropID, dsTgtData, sTgtPropFullName)
End Function

Public Function dsComparePropertyByName(ByRef dsSrcData As DIR_SERVER_DATA, ByVal sSrcPropFullName As String, ByRef dsTgtData As DIR_SERVER_DATA, ByVal sTgtPropFullName As String, ByRef isMatch As Boolean) As Boolean
dsComparePropertyByName = dsIntComparePropertyByName(dsSrcData, sSrcPropFullName, dsTgtData, sTgtPropFullName, isMatch)
End Function

Public Function dsComparePropertyByID(ByRef dsSrcData As DIR_SERVER_DATA, ByVal lSrcPropID As Long, ByRef dsTgtData As DIR_SERVER_DATA, ByVal sTgtPropFullName As String, ByRef isMatch As Boolean) As Boolean
dsComparePropertyByID = dsIntComparePropertyByID(dsSrcData, lSrcPropID, dsTgtData, sTgtPropFullName, isMatch)
End Function

Public Function dsCacheSubtree(ByRef dsData As DIR_SERVER_DATA, ByVal sPropName As String) As Boolean
dsCacheSubtree = dsPstCacheSubtree(dsData, sPropName)
End Function



Public Sub dsTestInsert(ByVal sName As String, sVal As String)
Dim dsData As DIR_SERVER_DATA
dsInit dsData, False, ""

Dim lDummy As Long, blDummy As Boolean, sDummy As String

dsIntSetPropertyByName dsData, sName, sVal, lDummy, blDummy, sDummy


dsClean dsData
End Sub

Public Sub dsTestDelete(ByVal sName As String)
Dim dsData As DIR_SERVER_DATA
dsInit dsData, False, ""

Dim lDummy As Long, blDummy As Boolean, sDummy As String

dsIntDeletePropertyByName dsData, sName, blDummy, sDummy

dsClean dsData
End Sub


Public Function dsTestLookup(ByVal sName As String) As String
Dim dsData As DIR_SERVER_DATA

dsInit dsData, False, ""

Dim lDummy As Long, blDummy As Boolean, sVal As String

dsLookupPropertyByName dsData, sName, blDummy, sVal, lDummy

dsTestLookup = sVal


dsClean dsData
End Function


Public Sub dsTestCopy(ByVal sSrcName As String, sTgtName As String)
Dim dsData As DIR_SERVER_DATA

dsInit dsData, False, ""

Dim lDummy As Long, blDummy As Boolean, sDummy As String

dsIntCopyPropertyByName dsData, sSrcName, dsData, sTgtName


dsClean dsData
End Sub

Public Function dsTestCompare(ByVal sSrcName As String, sTgtName As String) As Boolean
Dim dsData As DIR_SERVER_DATA

dsInit dsData, False, ""

Dim isMatch As Boolean

If Not dsIntComparePropertyByName(dsData, sSrcName, dsData, sTgtName, isMatch) Then
  Debug.Print "error"
End If

dsTestCompare = isMatch


dsClean dsData
End Function


Public Function dsTestTransactional() As Boolean

dsTestTransactional = False

Dim wrkSpace As Workspace
Set wrkSpace = DBEngine(0)

Dim db As Database
Set db = wrkSpace(0)


wrkSpace.BeginTrans


Dim dsData As DIR_SERVER_DATA
If Not dsInit_Transactional(db, dsData, False, "", 0) Then
  wrkSpace.Rollback
  Exit Function
End If

Dim blDummy As Boolean, lDummy As Long, sDummy As String
If Not dsSetPropertyByName(dsData, "TESTS\TX\TRee\prop1", "prop1", lDummy, blDummy, sDummy) Then
  wrkSpace.Rollback
  Exit Function
End If

If Not dsSetPropertyByName(dsData, "TESTS\TX\TRee\prop2", "prop2", lDummy, blDummy, sDummy) Then
  wrkSpace.Rollback
  Exit Function
End If

Dim blPresent As Boolean, sVal As String
If Not dsLookupPropertyByName(dsData, "TESTS\TX\Tree\prop1", blPresent, sVal, lDummy) Then
  wrkSpace.Rollback
  Exit Function
End If

If (sVal <> "prop1") Then
  wrkSpace.Rollback
  Exit Function
End If


dsClean dsData

wrkSpace.Rollback


If Not dsInit(dsData, False, "") Then
  Exit Function
End If


If Not dsLookupPropertyByName(dsData, "TESTS\TX\Tree\prop1", blPresent, sVal, lDummy) Then
  Exit Function
End If

If (blPresent) Then
  Exit Function
End If


dsTestTransactional = True


End Function


Public Function dsTestLong() As Boolean

dsTestLong = False

Dim dsData As DIR_SERVER_DATA
dsInit dsData, True, "__ds__test"


Dim lDummy As Long, blDummy As Boolean, sDummy As String

'If Not dsIntDeletePropertyByName(dsData, "ROOT", blDummy, sDummy) Then
'  Exit Function
'End If




Dim i As Integer
For i = 1 To 20

  If Not dsIntSetPropertyByName(dsData, "ROOT\TESTS\SUBDIR_0\PROP_0_" & i, "0_" & i, lDummy, blDummy, sDummy) Then
    Exit Function
  End If

Next i


For i = 1 To 20

  If Not dsIntSetPropertyByName(dsData, "ROOT\TESTS\SUBDIR_1\PROP_1_" & i, "1_" & i, lDummy, blDummy, sDummy) Then
    Exit Function
  End If

Next i

For i = 1 To 20

  Dim lkpS As String
  lkpS = ""
  If Not dsIntLookupPropertyByName(dsData, "ROOT\TESTS\SUBDIR_0\PROP_0_" & i, lkpS, blDummy, lDummy) Then
    Exit Function
  End If
  
  If (lkpS <> "0_" & i) Then
    Err.Raise 1, , "Internal error"
  End If

  If Not dsIntSetPropertyByName(dsData, "ROOT\TESTS\SUBDIR_0\PROP_0_" & i, "0_" & i & "_updated", lDummy, blDummy, sDummy) Then
    Exit Function
  End If

Next i


For i = 1 To 20
  Dim prvS As String
  prvS = ""

  If Not dsIntDeletePropertyByName(dsData, "ROOT\TESTS\SUBDIR_1\PROP_1_" & i, blDummy, prvS) Then
    Exit Function
  End If
  
  If (prvS <> "1_" & i) Then
    Err.Raise 1, , "Internal error"
  End If

Next i

If Not dsIntDeletePropertyByName(dsData, "ROOT\TESTS\SUBDIR_1", blDummy, sDummy) Then
  Exit Function
End If

If Not dsIntRenamePropertyByName(dsData, "ROOT\TESTS", "ROOT\TESTS_NEW_SUBDIR\TESTS") Then
  Exit Function
End If

For i = 1 To 20

  lkpS = ""
  If Not dsIntLookupPropertyByName(dsData, "ROOT\TESTS_NEW_SUBDIR\TESTS\SUBDIR_0\PROP_0_" & i, lkpS, blDummy, lDummy) Then
    Exit Function
  End If
  
  If (lkpS <> "0_" & i & "_updated") Then
    Err.Raise 1, , "Internal error"
  End If

  
Next i

If Not dsCopyPropertyByName(dsData, "ROOT", dsData, "ROOT_COPY") Then
  appRaiseSilentError
End If


If Not dsIntDeletePropertyByName(dsData, "ROOT", blDummy, sDummy) Then
  Exit Function
End If



dsClean dsData


dsTestLong = True


End Function


Public Function dsTestSpeed(ByVal nIts As Integer, ByVal blReadAndWrite As Boolean, ByVal lCacheCapacity As Long) As Boolean

dsTestSpeed = False

Dim dsData As DIR_SERVER_DATA
dsInit dsData, True, "__test__speed", lCacheCapacity


Dim lDummy As Long, blDummy As Boolean, sDummy As String

Dim sPropName As String, sPropValue As String
Dim i As Integer
For i = 0 To nIts
  sPropName = "BLAAT\BLA_" & i & "\BLA_" & i & "BLAAT"
  sPropValue = "Bla_" & i
  If Not dsSetPropertyByName(dsData, sPropName, sPropValue, lDummy, blDummy, sDummy) Then
    Err.Raise 1, , "internal error"
  End If
Next i


If (blReadAndWrite) Then
  Dim j As Integer
  For j = 0 To 4
    For i = 0 To nIts
      sPropName = "BLAAT\BLA_" & i & "\BLA_" & i & "BLAAT"
      sPropValue = ""
      If Not dsLookupPropertyByName(dsData, sPropName, blDummy, sPropValue, lDummy) Then
        appRaiseSilentError
      End If
      
      If (sPropValue <> "Bla_" & i) Then
        Err.Raise 1, , "internal error"
      End If
    Next i
  Next j
End If



dsClean dsData


dsTestSpeed = True


End Function



Public Function dsTestSpeedCache(sPropName As String, ByVal lCapacity As Long) As Boolean

dsTestSpeedCache = False

Dim dsData As DIR_SERVER_DATA
dsInit dsData, False, "", lCapacity

If Not dsCacheSubtree(dsData, sPropName) Then
  appRaiseSilentError
End If

dsClean dsData


dsTestSpeedCache = True


End Function




Public Function dsTestSpeedRef(ByVal nIts As Integer) As Boolean

dsTestSpeedRef = False

Dim dsData As DIR_SERVER_DATA
dsInit dsData, True, "__test__speed"

Dim rs As Recordset
Set rs = CurrentDb().OpenRecordset("__test__speed")

Dim i As Integer
For i = 0 To nIts
  rs.AddNew
    rs("DIR_ID") = i
    rs("DIR_Parent_ID") = -1
    rs("DIR_Value") = "blaat"
  rs.Update
Next i



rs.MoveFirst
Do Until rs.EOF
  Dim tpID As Long, tpVal As String
  tpID = Nz(rs("DIR_ID"))
  tpVal = Nz(rs("DIR_Value"))
  rs.MoveNext
Loop

For i = 0 To nIts
  dsData.pst.skDSIdx.Seek "=", tpID
Next i

appCleanRS rs

dsClean dsData






dsTestSpeedRef = True


End Function